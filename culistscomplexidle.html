<!DOCTYPE html>
<html lang="en">

<head>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/dist/tippy.css">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cultist's Complex.idle</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Creepster&family=Press+Start+2P&family=Orbitron:wght@400;700&family=Audiowide&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=UnifrakturMaguntia&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Indie+Flower&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        /* カラー設定 */
        :root {
            --bg-color: #0a0a0a;
            --text-color: #e0e0e0;
            --panel-bg: #1a1a1a;
            --highlight-color: #c31515;
            --button-color: #4CAF50;
            --button-hover: #45a049;
            --button-disabled: #9a1e1e;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Webkit ブラウザ (Chrome, Safari, newer versions of Edge) 用 */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 6px;
            border: 3px solid #1a1a1a;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }

        /* Firefox 用 (version 64 以降) */
        * {
            scrollbar-width: thin;
            scrollbar-color: #4CAF50 #1a1a1a;
        }

        body {
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
            user-select: none;
            position: relative;
            /* スキャンライン用 */
        }

        /* CRTオーバーレイ効果 */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                /* スキャンライン */
                repeating-linear-gradient(0deg,
                    rgba(124, 116, 116, 0.15),
                    rgba(19, 18, 18, 0.1) 1px,
                    transparent 1.5px,
                    transparent 4px),
                /* 緑のフィルター */
                linear-gradient(rgba(33, 222, 109, 0.05),
                    rgba(33, 222, 109, 0.05));
            pointer-events: none;
            z-index: 999999;
            mix-blend-mode: screen;
        }

        /* CRT曲面効果 */
        body::after {
            content: "";
            position: fixed;
            top: 0.5%;
            left: 0.5%;
            right: 0.5%;
            bottom: 0.5%;
            background: radial-gradient(circle at center,
                    transparent 50%,
                    rgba(0, 0, 0, 0.2) 100%);
            pointer-events: none;
            z-index: 999998;
        }

        /* ASCII アート用の特別なスタイル */
        #ascii-title,
        .ascii-cultosminer,
        .ascii-art,
        .follower-ascii-art,
        .monster-ascii-art {
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 2px currentColor;
            position: relative;
            animation: textFlicker 0.3s infinite;
        }

        @keyframes textFlicker {
            0% {
                opacity: 0.97;
            }

            5% {
                opacity: 0.95;
            }

            10% {
                opacity: 0.9;
            }

            15% {
                opacity: 0.95;
            }

            20% {
                opacity: 0.98;
            }

            25% {
                opacity: 0.95;
            }

            30% {
                opacity: 0.9;
            }

            35% {
                opacity: 0.95;
            }

            40% {
                opacity: 0.98;
            }

            45% {
                opacity: 0.95;
            }

            50% {
                opacity: 0.9;
            }

            55% {
                opacity: 0.95;
            }

            60% {
                opacity: 0.98;
            }

            65% {
                opacity: 0.95;
            }

            70% {
                opacity: 0.9;
            }

            75% {
                opacity: 0.95;
            }

            80% {
                opacity: 0.98;
            }

            85% {
                opacity: 0.95;
            }

            90% {
                opacity: 0.9;
            }

            95% {
                opacity: 0.95;
            }

            100% {
                opacity: 0.98;
            }
        }

        /* エンブレム専用のCRT効果強化 */
        #cultosminer {
            position: relative;
            overflow: hidden;
        }

        #eldritchDrum {
            font-size: 12px;
            margin: 0;
            font-family: 'Courier New', monospace;
            white-space: pre;
            line-height: 1.1;
        }

        #cultosminer {
            font-family: 'Courier New', monospace;
            line-height: 1.1;
            white-space: pre;
            text-align: center;
            font-size: 9px;
            font-weight: bold;
            margin: 0;
            padding: 10px;
        }

        /* パネルとカードのCRT効果強化 */
        .panel,
        .monster-card,
        .upgrade-card,
        .adventurer {
            position: relative;
            overflow: hidden;
            background-color: var(--panel-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1),
                inset 0 0 20px rgba(33, 222, 109, 0.05);
        }

        /* CRTフィルター無効時のスタイル */
        .crt-filter-disabled::before,
        .crt-filter-disabled::after {
            display: none !important;
        }

        .crt-filter-disabled #cultosminer::before,
        .crt-filter-disabled .pact-modal .pact-content::before {
            display: none !important;
        }

        .crt-filter-disabled #ascii-title,
        .crt-filter-disabled .ascii-art,
        .crt-filter-disabled .follower-ascii-art,
        .crt-filter-disabled .monster-ascii-art {
            animation: none !important;
            text-shadow: none !important;
        }

        .crt-filter-disabled .panel,
        .crt-filter-disabled .monster-card,
        .crt-filter-disabled .upgrade-card,
        .crt-filter-disabled .adventurer {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
        }

        /* トグルボタンのスタイル */
        #toggleCrtFilter {
            transition: all 0.3s ease;
            margin: 0 5px;
        }

        #toggleCrtFilter:hover {
            background-color: rgba(76, 175, 80, 0.2);
        }

        #toggleCrtFilter:active {
            background-color: rgba(76, 175, 80, 0.4);
        }

        /* フラッシュ効果の強化 */
        .white-flash {
            animation: enhanced-flash 0.5s;
        }

        @keyframes enhanced-flash {
            0% {
                filter: brightness(100%) sepia(0.2);
            }

            50% {
                filter: brightness(200%) sepia(0.3);
            }

            100% {
                filter: brightness(100%) sepia(0.2);
            }
        }

        /* 契約モーダル用の特別なCRT効果 */
        .pact-modal .pact-content {
            position: relative;
            overflow: hidden;
        }

        .pact-modal .pact-content::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(0deg,
                    rgba(124, 116, 116, 0.1),
                    rgba(19, 18, 18, 0.05) 1px,
                    transparent 2px,
                    transparent 4px);
            pointer-events: none;
            animation: scanline 10s linear infinite;
        }

        button {
            background-color: transparent;
            color: #e0e0e0;
            border: 1px solid #4CAF50;
            /* 線枠の色 */
            padding: 4px 8px;
            margin: 5px 0;
            cursor: pointer;
            border-radius: 3px;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 11px;
        }

        button:hover:not(:disabled) {
            background-color: rgba(76, 175, 80, 0.2);
            /* ホバー時の背景色 */
            color: #ffffff;
        }

        button:active:not(:disabled) {
            background-color: rgba(76, 175, 80, 0.4);
            /* アクティブ時の背景色 */
        }

        button:disabled {
            background-color: transparent;
            /* 無効時も透明に */
            border-color: #9a1e1e;
            /* 無効時の線枠の色 */
            cursor: not-allowed;
            opacity: 0.7;
        }

        button:disabled:hover {
            background-color: transparent;
        }

        @keyframes white-flash {
            0% {
                filter: brightness(100%);
            }

            50% {
                filter: brightness(200%);
            }

            100% {
                filter: brightness(100%);
            }
        }

        .white-flash {
            animation: white-flash 0.5s;
        }

        .red-filter {
            filter: sepia(100%) saturate(300%) brightness(70%) hue-rotate(300deg);
        }

        .floating-buttons-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        .floating-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: block;
            font-size: 16px;
            margin: 4px 2px;
            margin-bottom: 10px;
            cursor: pointer;
            border-radius: 12px;
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
            transition: 0.3s;
        }

        .floating-button:hover {
            background-color: #45a049;
            box-shadow: 0 8px 16px 0 rgba(0, 0, 0, 0.2);
        }

        #backToTopBtn {
            display: none;
            /* 初期状態では非表示 */
        }

        #backToTopBtn:hover {
            background-color: #45a049;
        }

        /* フローティングボタンコンテナの下部にマージンを追加 */
        .floating-buttons-container {
            margin-bottom: 70px;
            /* Back to Topボタンの高さ + 余白 */
        }


        #ascii-title-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0 0 0;
            /* 下部のマージンを削除 */
            padding: 10px;
            background-color: var(--bg-color);
            border-radius: 10px 10px 0 0;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #text-title {
            display: none;
            font-size: 2.5em;
            text-align: center;
            color: #4CAF50;
            margin: 20px 0;
        }

        /* アニメーション用のクラス */
        .fade-out {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .fade-in {
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        #ascii-title {
            font-family: 'Courier New', monospace;
            line-height: 1.1;
            white-space: pre;
            text-align: center;
            color: #1aff1a;
            text-shadow: 0 0 5px #1aff1a, 0 0 10px #1aff1a;
            margin-top: -15px;
            margin-bottom: 15px;
            font-size: 10px;
            font-weight: bold;
            margin: 0;
            padding: 0;
        }

        #version-display {
            font-family: 'Courier New', monospace;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            color: #1aff1a;
            background-color: var(--bg-color);
            padding: 5px;
            border-radius: 0 0 10px 10px;
        }

        @media (max-width: 768px) {
            #ascii-title {
                font-size: 8px;
            }

            #version-display {
                font-size: 12px;
            }
        }

        @media (max-width: 1200px) {
            #resourceDisplay {
                padding: 8px 10px;
                gap: 10px;
            }

            .resource-column {
                min-width: 150px;
            }
        }

        @media (max-width: 768px) {
            #resourceDisplay {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(3, auto);
            }

            .ascii-container {
                order: -1;
                margin-bottom: 10px;
            }

            .resource-column:first-child,
            .resource-column:last-child {
                justify-self: center;
                text-align: center;
            }

            .resource-value-container {
                justify-content: center;
            }

            .cultos-section {
                flex-direction: column;
                gap: 10px;
            }
        }


        .container {
            display: grid;
            grid-template-columns: 250px 1fr 300px;
            grid-template-rows: auto auto auto 1fr;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .panel {
            background-color: var(--panel-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        #debugControls button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 2px 2px;
            cursor: pointer;
            border-radius: 3px;
        }

        #debugControls span {
            font-size: 14px;
            margin-left: 10px;
        }

        h1 {
            grid-column: 1 / -1;
            grid-row: 1;
            text-align: center;
            color: #1aff1a;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(16, 209, 42, 0.5);
        }

        #resourceDisplay {
            position: sticky;
            top: 40px;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
            height: auto;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 255, 0, 0.2);
        }

        #cultosminer {
            grid-column: 2;
            grid-row: 1 / span 2;
        }

        /* 左側のリソース（Source） */
        .resource-column:first-child {
            justify-self: end;
            text-align: right;
        }

        /* 右側のリソース（Miasma） */
        .resource-column:last-child {
            justify-self: start;
            text-align: left;
        }

        #largeCultosCount {
            color: #42a5f5;
            text-shadow: 0 0 5px #42a5f5, 0 0 10px #42a5f5;
            font-family: 'Audiowide', cursive;
            font-size: 1.2em;
            margin: 0;
        }

        .cultos-section {
            grid-column: 1 / -1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px solid rgba(26, 255, 26, 0.2);
        }

        .cultos-value-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }


        .cultos-hidden {
            display: none !important;
        }

        .cultos-symbol {
            font-size: 1.2em;
            font-family: 'Press Start 2P', cursive;
        }

        .cultos-symbol.active {
            animation: rainbow-text 5s linear infinite;
        }

        @keyframes rainbow-text {
            0% {
                color: #ff0000;
            }

            17% {
                color: #ffa500;
            }

            33% {
                color: #ffff00;
            }

            50% {
                color: #008000;
            }

            67% {
                color: #0000ff;
            }

            83% {
                color: #4b0082;
            }

            100% {
                color: #ff0000;
            }
        }

        /* 非アクティブ時のスタイル */
        .cultos-symbol.inactive {
            animation: none;
            background: none;
            text-shadow: none;
            color: #272626;
        }

        .resource-rates {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            /* 右揃え */
        }

        #cultosRate {
            min-width: 120px;
            /* Cultosレートの最小幅を設定 */
            text-align: right;
        }

        #cultosHashRate {
            font-size: 0.9em;
            display: inline-block;
            min-width: 50px;
            text-align: right !important;
            font-family: 'Audiowide', cursive;
        }

        .rate-display {
            font-family: 'Audiowide', cursive;
            font-size: 0.9em;
            color: rgba(26, 255, 26, 0.8);
            white-space: nowrap;
            display: inline-block;
            width: 100px;
            /* 固定幅を設定 */
            text-align: right !important;
        }

        /* カルトスカウントのコンテナ */
        .cultos-value-container {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: flex-end;
        }

        .consumption-rate-container {
            display: flex;
            gap: 15px;
            font-size: 0.8em;
        }

        .consumption-rate {
            display: flex;
            align-items: center;
            white-space: nowrap;
        }

        .consumption-rate span {
            margin-left: 4px;
            min-width: 80px;
            /* 数値の最小幅を大きめに設定 */
            text-align: right;
            display: inline-block;
            /* ブロック要素として表示 */
        }

        .consumption-rate .rate-value {
            margin-left: 4px;
            min-width: 80px;
            /* 数値の最小幅を大きめに設定 */
            text-align: right;
            display: inline-block;
            /* ブロック要素として表示 */
        }

        .consumption-rate .rate-value.active {
            color: #4CAF50;
            /* アクティブ時は緑色 */
        }

        .consumption-rate .rate-value.inactive {
            color: #ff4444;
            /* 非アクティブ時は赤色 */
        }

        #upgradeSymbols {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            align-items: center;
        }

        #upgradeSymbols {
            overflow: visible !important;
            position: relative;
        }

        .upgrade-symbol {
            overflow: visible !important;
        }

        .upgrade-symbol {
            cursor: pointer;
            margin: 0 5px;
            position: relative;
            display: inline-block;
        }

        .upgrade-tooltip {
            visibility: hidden;
            position: absolute;
            background-color: rgba(0, 0, 0, 0.95);
            color: #e0e0e0;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #4CAF50;
            font-size: 12px;
            white-space: nowrap;
            z-index: 5000;
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 5px;
            width: max-content;
            max-width: 300px;
        }

        .upgrade-symbol:hover .upgrade-tooltip {
            visibility: visible;
        }

        /* ツールチップのベーススタイル */
        .tooltip-container {
            position: relative;
        }

        /* リソース値自体の固定幅設定 */
        .resource-value {
            min-width: 120px;
            /* リソース値の最小幅を設定 */
            text-align: right;
            display: inline-block;
        }

        .resource-rate {
            font-family: 'Courier New', monospace;
            font-size: 1em;
            width: 120px;
            display: inline-block;
            text-align: right;
            color: #1aff1a;
        }

        .resource-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            text-align: center;
        }


        .resource-column h2 {
            /*font-size: 1.2em;  /* Press Start 2P の場合 */
            font-size: 1.2em;
            /* Orbitron または Audiowide の場合 */
            margin-bottom: 5px;
            color: #1aff1a;
            text-shadow: 0 0 5px #1aff1a, 0 0 10px #1aff1a;
        }

        .resource-column:last-child h2 {
            color: #42a5f5;
            /* カルトス用の青色 */
            text-shadow: 0 0 5px #42a5f5, 0 0 10px #42a5f5;
            /* 青い発光エフェクト */
        }

        #largeSourceCount,
        #largeMiasmaCount {
            font-family: 'Audiowide', cursive;
            font-size: 1.2em;
            color: #1aff1a;
            text-shadow: 0 0 5px #1aff1a;
            margin: 0;
        }

        #largeSourcePerSecond,
        #largeMiasmaPerSecond {
            font-family: 'Audiowide', monospace;
            font-size: 1em;
            color: #1aff1a;
            min-width: 60px;
            /* 固定幅を設定 */
            text-align: right;
            /* 右寄せ */
            display: inline-block;
            /* インラインブロック要素に */
        }

        .resource-value-container {
            display: flex;
            align-items: baseline;
            gap: 10px;
            justify-content: flex-end;
        }


        .resource-column:last-child .resource-value-container {
            justify-content: flex-start;
        }

        .ascii-cultosminer {
            font-family: 'Courier New', monospace;
            font-size: 8px;
            line-height: 1.1;
            white-space: pre;
            text-align: center;
            margin: 0 20px;
            padding: 10px;
        }

        .ascii-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
        }

        .cultosminer-flash {
            animation: cultosminer-flash 1s ease-out;
        }

        /* 無効状態のスタイル */
        .cultosminer-disabled {
            filter: grayscale(100%) opacity(0.5) !important;
            pointer-events: none !important;
        }

        /* カルトスシンボルの無効化状態の強化 */
        .cultosminer-disabled .cultos-symbol,
        .cultosminer-disabled .cultos-symbol.active {
            animation: none !important;
            color: #666666 !important;
            text-shadow: none !important;
            -webkit-text-fill-color: #666666 !important;
            background: none !important;
            opacity: 0.5 !important;
        }

        /* cultosminerが無効時のシンボルスタイル */
        .cultos-symbol.inactive {
            animation: none !important;
            color: #666666 !important;
            text-shadow: none !important;
            -webkit-text-fill-color: #666666 !important;
            background: none !important;
            opacity: 0.5 !important;
        }

        /* カルトスシンボルの無効化状態の強化 */
        .cultosminer-disabled .cultos-symbol,
        .cultosminer-disabled .cultos-symbol.active {
            animation: none !important;
            color: #666666 !important;
            text-shadow: none !important;
            -webkit-text-fill-color: #666666 !important;
            background: none !important;
            opacity: 0.5 !important;
        }



        @keyframes pulse {
            0% {
                box-shadow: 0 0 5px var(--glow-color);
            }

            50% {
                box-shadow: 0 0 15px var(--glow-color);
            }

            100% {
                box-shadow: 0 0 5px var(--glow-color);
            }
        }

        /* アクティブ状態のスタイル */
        .active {
            filter: none !important;
            pointer-events: auto !important;
        }

        /* アクティブ状態での色の維持 */
        .active .cultosminer-color1 {
            color: #1aff1a !important;
            text-shadow: 0 0 5px #1aff1a !important;
        }

        .active .cultosminer-color2 {
            color: #118011 !important;
        }

        .active .cultosminer-color3 {
            color: #ff1a1a !important;
            text-shadow: 0 0 5px #ff1a1a !important;
        }

        .active .cultosminer-color4 {
            color: #ffff1a !important;
            text-shadow: 0 0 5px #ffff1a !important;
        }

        /* アクティブ状態の定義 */
        #cultosminer:not(.cultosminer-disabled) {
            filter: none;
            pointer-events: auto;
        }

        /* カルトスシンボルのレインボー効果の無効化 */
        .cultosminer-disabled .cultos-symbol {
            animation: none !important;
            background: none !important;
            color: #666666 !important;
            -webkit-text-fill-color: #666666 !important;
        }

        @keyframes cultosminer-flash {
            0% {
                color: #FFFFFF;
                text-shadow: 0 0 10px #FFFFFF;
            }

            100% {
                color: inherit;
                text-shadow: none;
            }
        }

        /* マイニング状態表示のスタイル */
        .mining-status {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            margin: 5px 0;
        }

        .mining-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #666;
            transition: all 0.3s ease;
        }

        .mining-indicator.active {
            background-color: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .cultosminer-color1 {
            color: #1aff1a;
            text-shadow: 0 0 5px #1aff1a;
        }

        .cultosminer-color2 {
            color: #118011;
        }

        .cultosminer-color3 {
            color: #ff1a1a;
            text-shadow: 0 0 5px #ff1a1a;
        }

        .cultosminer-color4 {
            color: #ffff1a;
            text-shadow: 0 0 5px #ffff1a;
        }

        .sidebar {
            grid-column: 1 / 2;
            grid-row: 3 / 5;
        }

        .main-content {
            grid-column: 2 / 3;
            grid-row: 3 / 4;
        }

        .upgrades {
            grid-column: 3 / 4;
            grid-row: 3 / 5;
        }

        .madness-table {
            grid-column: 2 / 3;
            grid-row: 4 / 5;
        }

        .stat-line {
            margin: 5px 0;
            text-align: left;
        }

        #monsterGridContainer {
            scroll-behavior: smooth;
            scroll-snap-type: y mandatory;
            overflow-y: auto;
            height: 730px;
            /* デバッグ用の背景色を追加 */
            background: rgba(0, 0, 0, 0.1);
        }

        /* Webkit（Chrome, Safari等）用のスクロールバースタイル */
        #monsterGridContainer::-webkit-scrollbar {
            width: 8px;
        }

        #monsterGridContainer::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }

        #monsterGridContainer::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 4px;
        }

        #monsterGridContainer::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }

        .monster-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            /* コンテナ内のスクロール動作を改善 */
            min-height: min-content;
            padding-bottom: 20px;
            /* 下部にパディングを追加 */
        }

        .monster-card {
            position: relative;
            background-color: #192320;
            padding: 15px;
            border-radius: 8px;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .monster-card-header {
            position: relative;
        }

        #toggleAllMonsterCards {
            margin-bottom: 10px;
            /* 必要に応じて他のスタイルを追加 */
        }

        .monster-card-details {
            display: none;
            margin-top: 10px;
        }

        .monster-card-details.expanded {
            display: block;
        }

        .summon-monster-btn {
            transition: background-color 0.3s, opacity 0.3s;
        }

        .toggle-details {
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            font-size: 1.5em;
        }

        #adventurers {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
        }

        .adventurer {
            flex: 0 1 calc(33.333% - 20px);
            margin: 10px;
            text-align: center;
        }

        .madness-btn {
            cursor: pointer;
            transition: background-color 0.3s, opacity 0.3s;
            min-width: 120px;
            /* 最小幅を設定 */
            height: 36px;
            /* 高さを固定 */
            line-height: 36px;
            /* テキストを垂直中央揃え */
            padding: 0 10px;
            /* 左右のパディングを追加 */
            white-space: nowrap;
            /* テキストを1行に */
            overflow: hidden;
            /* はみ出した部分を隠す */
            text-overflow: ellipsis;
            /* はみ出した部分を...で表示 */
        }

        .madness-btn:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        #log {
            height: 150px;
            overflow-y: auto;
            background-color: #222;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            margin-top: 20px;
        }

        #log p {
            margin: 5px 0;
            padding: 5px;
            background-color: #2a2a2a;
            border-radius: 3px;
        }

        .ascii-art {
            font-family: 'Courier New', monospace;
            line-height: 1.1;
            white-space: pre;
            text-align: center;
            font-size: 10px;
            font-weight: bold;
            margin: 0;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto auto auto 1fr;
            }

            .sidebar,
            .upgrades {
                grid-column: auto;
                grid-row: auto;
            }

            .main-content,
            .madness-table {
                grid-column: 1 / -1;
            }
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto auto auto auto;
            }

            .sidebar,
            .main-content,
            .upgrades,
            .madness-table {
                grid-column: 1 / -1;
                grid-row: auto;
            }
        }

        .tooltip-container .tooltip {
            visibility: hidden;
            width: 200px;
            background-color: rgba(0, 0, 0, 0.95);
            color: #fff;
            text-align: center;
            border-radius: 5px;
            padding: 8px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease;
            border: 1px solid #4CAF50;
            font-size: 12px;
            white-space: pre-wrap;
            pointer-events: none;
        }

        /* ツールチップの矢印 */
        .tooltip-container .tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #4CAF50 transparent transparent transparent;
        }

        /* ホバー時のツールチップ表示 */
        .tooltip-container:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        /* シンボルのスタイル */
        .upgrade-symbol span {
            font-size: 16px;
            padding: 2px 5px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        #game-header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background-color: var(--bg-color);
            padding: 5px 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            /* ヘッダー内の要素が確実に表示されるように */
            display: flex;
            flex-direction: column;
        }

        #top-buttons {
            position: sticky;
            /* stickyに変更 */
            top: 0;
            z-index: 1001;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            padding: 5px;
            flex-wrap: wrap;
            background-color: var(--bg-color);
            height: 40px;
        }

        #top-buttons button {
            font-size: 11px;
            padding: 4px 8px;
            background-color: transparent;
            color: #e0e0e0;
            border: 1px solid #4CAF50;
            border-radius: 3px;
            transition: all 0.3s ease;
            cursor: pointer;
            margin: 2px 0;
            /* すべてのボタンに上下のマージンを追加 */
        }

        #top-buttons button:hover {
            background-color: rgba(76, 175, 80, 0.2);
            color: #ffffff;
        }

        #top-buttons button:active {
            background-color: rgba(76, 175, 80, 0.4);
        }

        #top-buttons button#resetButton {
            border-color: #ff0000;
            color: #ff0000;
        }

        #top-buttons button#resetButton:hover {
            background-color: rgba(255, 0, 0, 0.2);
            color: #ffffff;
        }

        #top-buttons button#resetButton:active {
            background-color: rgba(255, 0, 0, 0.4);
        }

        /* 折りたたみボタンのスタイルを他のボタンと揃える */
        #toggleAllMonsterCards {
            margin: 2px 0;
        }

        .rate-display {
            font-size: 0.9em;
            color: rgba(26, 255, 26, 0.8);
            white-space: nowrap;
        }

        #resourceDisplay.simple {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 5px 20px;
            gap: 10px;
            height: auto;
        }

        #resourceDisplay.simple .resource-column {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
            width: auto;
        }

        #resourceDisplay.simple .resource-value-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #resourceDisplay.simple .cultos-symbol {
            font-size: 1em;
            margin-right: 10px;
            background: none;
            /* グラデーションを無効化 */
            -webkit-background-clip: initial;
            background-clip: initial;
            color: #42a5f5;
            animation: none;
            /* レインボーアニメーションを無効化 */
        }

        #resourceDisplay.simple .cultos-symbol.active {
            animation: rainbow-text 5s linear infinite;
        }

        #resourceDisplay.simple .cultos-symbol.inactive {
            animation: none;
            color: #353434;
        }

        #resourceDisplay.simple .cultos-count {
            font-size: 1em;
            margin-left: 10px;
            color: #42a5f5;
            text-shadow: none;
            /* 発光効果を無効化 */
        }

        #resourceDisplay.simple .rate-display {
            font-size: 0.8em;
            min-width: auto;
            margin-left: 5px;
        }

        /* シンプル表示時に非表示にする要素 */
        #resourceDisplay.simple .resource-column h2,
        #resourceDisplay.simple #cultosminer,
        #resourceDisplay.simple #upgradeSymbols {
            display: none;
        }


        #resourceDisplay.simple {
            padding: 5px 20px;
            gap: 10px;
        }

        #resourceDisplay.simple .resource-column {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            /* 要素間の間隔を追加 */
        }

        #resourceDisplay.simple #largeSourceCount,
        #resourceDisplay.simple #largeMiasmaCount,
        #resourceDisplay.simple #largeCultosCount {
            font-size: 1em;
            /* フォントサイズを小さく */
            margin: 0;
            display: block !important;
            text-shadow: none;
            /* エフェクトを削除 */
        }

        /* シンプル表示時のラベルスタイル */
        #resourceDisplay.simple .resource-column::before {
            content: attr(data-label);
            /* data-label属性から表示するテキストを取得 */
            font-size: 0.8em;
            color: #888;
            margin-right: 5px;
        }

        /* シンプルモード時のヘッダー */
        #resourceDisplay.simple .resource-column h2 {
            font-size: 0.9em;
            margin: 0;
            display: block;
            /* 明示的に表示を指定 */
        }

        .modal {
            position: fixed !important;
            /* 他のpositionスタイルを上書き */
            top: 0 !important;
            left: 0 !important;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 9999999 !important;
            /* より高い値に設定 */
            display: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
            display: block;
        }

        .modal-content {
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            background-color: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            color: #e0e0e0;
            border: 1px solid #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
            z-index: 10000 !important;
            /* overlayより更に上に */
        }

        .modal.active .modal-content {
            transform: translate(-50%, -50%) scale(1);
        }

        /* ScrollBar Styling */
        .modal-content::-webkit-scrollbar {
            width: 10px;
        }

        .modal-content::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 5px;
        }

        .modal-content::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 5px;
        }

        .modal-content::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }

        /* モーダルヘッダーを固定 */
        .modal-header {
            position: sticky;
            top: 0;
            background-color: #1a1a1a;
            padding: 10px 0;
            margin-bottom: 15px;
            border-bottom: 1px solid #4CAF50;
            z-index: 1;
        }

        /* コンテナにマージンを追加 */
        .container {
            margin-top: 20px;
            /* Adjust as needed */
        }

        .stats-section {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 4px;
        }

        .stats-section h3 {
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .stats-section p {
            margin: 5px 0;
        }

        .modal-content button {
            background-color: #4CAF50;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        .modal-content button:hover {
            background-color: #45a049;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #4CAF50;
            position: sticky;
            top: 0;
            background-color: #1a1a1a;
            z-index: 1;
        }

        .modal-title {
            font-size: 1.5em;
            color: #4CAF50;
            margin: 0;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
        }

        .close-button {
            background: none;
            border: none;
            color: #e0e0e0;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px 10px;
            margin: -5px -10px;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .close-button:hover {
            color: #4CAF50;
            background-color: rgba(76, 175, 80, 0.1);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            padding: 10px;
        }

        .stats-section {
            background-color: #222;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .stats-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.2);
        }

        .stats-section h3 {
            color: #4CAF50;
            margin-top: 0;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 4px 0;
        }

        .stat-label {
            color: #aaa;
        }

        .stat-value {
            color: #fff;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
        }

        /* ボタンのアクティブ状態のスタイル */
        #statisticsButton.active {
            background-color: rgba(76, 175, 80, 0.2);
            border-color: #4CAF50;
        }

        .buy-upgrade-btn {
            /* 基本スタイル */
            transition: all 0.2s ease;
        }

        .buy-upgrade-btn.affordable {
            opacity: 1;
            cursor: pointer;
            /* 利用可能な時の他のスタイル */
        }

        .buy-upgrade-btn.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            /* 無効時の他のスタイル */
        }

        /* ロック状態のカードのスタイル */
        .monster-card.locked {
            opacity: 0.7;
            filter: grayscale(100%);
            position: relative;
        }

        .locked::before {
            content: '🔒';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
            z-index: 1;
        }

        .unlock-requirement {
            background-color: rgba(0, 0, 0, 0.8);
            color: #ff6b6b;
            padding: 8px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            display: none;
        }

        .locked .unlock-requirement {
            display: block;
        }

        /* ホバー時のツールチップ表示 */
        .locked:hover .unlock-requirement {
            background-color: rgba(0, 0, 0, 0.9);
        }

        /* アンロック時のアニメーション */
        @keyframes unlock-flash {
            0% {
                filter: grayscale(100%);
            }

            50% {
                filter: grayscale(0%) brightness(1.5);
            }

            100% {
                filter: grayscale(0%);
            }
        }

        .unlocking {
            animation: unlock-flash 1s ease-out;
        }

        .follower-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 50000;
            pointer-events: none;
            /* マウスイベントを無視 */
            will-change: opacity;
            /* アニメーションの最適化 */
            transition: opacity 0.15s ease;
            white-space: nowrap;
            border: 1px solid #444;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* ツールチップの表示/非表示を制御 */
        .follower-tooltip.hidden {
            opacity: 0;
            visibility: hidden;
            /* display: noneの代わりにvisibilityを使用 */
        }

        .follower-tooltip.visible {
            opacity: 1;
            visibility: visible;
        }

        .upgrade-card {
            position: relative;
            /* ツールチップの位置決めのため */
        }

        /* ツールチップの矢印 */
        .upgrade-tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #4CAF50 transparent transparent transparent;
        }

        .upgrade-card {
            position: relative;
            background-color: #192320;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            z-index: 1;
            pointer-events: auto;
        }

        .buy-upgrade-btn {
            width: 100%;
            margin-top: 10px;
            padding: 4px 8px;
            background-color: transparent;
            color: #e0e0e0;
            border: 1px solid #4CAF50;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 2;
            pointer-events: auto;
        }

        .buy-upgrade-btn:not(:disabled) {
            cursor: pointer;
            pointer-events: auto;
        }

        .buy-upgrade-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .upgrade-card h3 {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            color: #4CAF50;
            font-size: 1em;
        }

        .upgrade-card.locked {
            opacity: 0.7;
            filter: grayscale(70%);
        }

        .upgrade-card.locked::before {
            content: '🔒';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
        }

        .upgrade-card .unlock-requirement {
            background-color: rgba(0, 0, 0, 0.8);
            color: #ff6b6b;
            padding: 8px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        /* アンロック時のアニメーション */
        @keyframes unlock-flash {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.05);
                filter: brightness(1.5);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        .upgrade-card.unlocking {
            animation: unlock-flash 0.5s ease-out;
        }

        .adventurer {
            position: relative;
            background-color: #192320;
            padding: 15px;
            border-radius: 8px;
            margin: 10px;
            transition: all 0.3s ease;
        }

        /* ヘッダー部分のスタイル */
        .adventurer h3 {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-right: 30px;
            /* 鍵マークのためのスペース */
        }

        /* ロック状態のカードスタイル */
        .adventurer.locked {
            opacity: 0.7;
            filter: grayscale(70%);
        }

        /* ロック状態の要件表示 */
        .unlock-requirement {
            background-color: rgba(0, 0, 0, 0.8);
            color: #ff6b6b;
            padding: 8px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            display: none;
        }

        .adventurer.locked .unlock-requirement {
            display: block;
        }

        /* ASCII アートのスタイル調整 */
        .adventurer .ascii-art {
            margin: 10px 0;
            opacity: 1;
            transition: all 0.3s ease;
        }

        .adventurer.locked .ascii-art {
            opacity: 0.5;
        }

        /* ボタンのスタイル調整 */
        .adventurer .madness-btn {
            width: 100%;
            margin-top: 10px;
            opacity: 1;
            transition: all 0.3s ease;
        }

        .adventurer.locked .madness-btn {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ホバー時の要件表示強調 */
        .adventurer.locked:hover .unlock-requirement {
            background-color: rgba(0, 0, 0, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(255, 107, 107, 0.2);
        }

        /* アンロック時のアニメーション */
        @keyframes unlock-flash {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.02);
                filter: brightness(1.5);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        .adventurer.unlocking {
            animation: unlock-flash 0.5s ease-out;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #1a1a1a;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #333;
            max-width: 500px;
            width: 90%;
        }

        /* Pact Modal Styles */
        .pact-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.5s ease;
        }

        .pact-content {
            background: #1a1a1a url('path/to/parchment-texture.jpg');
            border: 2px solid #998f6b;
            border-radius: 3px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            position: relative;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
            transform: translateY(0);
            transition: transform 0.5s ease;
        }

        /* accept-pactとdecline-pactクラスを削除し、標準のボタンスタイルに統一 */
        .pact-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .pact-content button {
            font-size: 11px;
            padding: 4px 8px;
            background-color: transparent;
            color: #e0e0e0;
            border: 1px solid #4CAF50;
            border-radius: 3px;
            transition: all 0.3s ease;
            cursor: pointer;
            margin: 2px 0;
            font-family: inherit;
        }

        /* 拒否ボタンのスタイル（resetButtonと完全に同じ） */
        .pact-content button.decline-btn {
            border-color: #ff0000;
            /* 赤い枠線 */
            color: #ff0000;
            /* 赤いテキスト */
        }

        .pact-content button:hover:not(:disabled) {
            background-color: rgba(76, 175, 80, 0.2);
            color: #ffffff;
        }

        /* 拒否ボタンのホバー時 */
        .pact-content button.decline-btn:hover:not(:disabled) {
            background-color: rgba(255, 0, 0, 0.2);
            /* 赤い背景 */
            color: #ffffff;
        }

        .pact-content button:active:not(:disabled) {
            background-color: rgba(76, 175, 80, 0.4);
        }

        /* 拒否ボタンのアクティブ時 */
        .pact-content button.decline-btn:active:not(:disabled) {
            background-color: rgba(255, 0, 0, 0.4);
            /* より濃い赤い背景 */
        }

        .pact-content button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pact-title {
            font-family: 'UnifrakturMaguntia', 'Cinzel Decorative', 'Luminari', serif;
            font-size: 3em;
            text-align: center;
            margin-bottom: 1em;
            color: #ba1206;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 2px;
        }

        .pact-scroll {
            max-height: 60vh;
            overflow-y: auto;
            padding: 20px;
            margin: 20px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .pact-description {
            color: #e0e0e0;
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .pact-flavor {
            color: #888;
            font-style: italic;
            margin-bottom: 20px;
            padding: 10px;
            border-left: 3px solid #ba1206;
        }

        .pact-effects {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }

        .pact-effect {
            color: #ff4444;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 0, 0, 0.1);
            border-radius: 5px;
        }

        .pact-warning {
            color: #ff4444;
            text-align: center;
            font-weight: bold;
            margin: 20px 0;
        }

        .pact-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .accept-pact,
        .decline-pact {
            padding: 4px 8px;
            font-size: 11px;
            border: 1px solid #4CAF50;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Press Start 2P', cursive;
            text-transform: uppercase;
        }

        .accept-pact {
            background-color: transparent;
            color: #4CAF50;
        }

        .accept-pact:hover {
            background-color: rgba(76, 175, 80, 0.2);
            color: #ffffff;
        }

        .decline-pact {
            background-color: transparent;
            color: #ff4444;
            border-color: #ff4444;
        }

        .decline-pact:hover {
            background-color: rgba(255, 68, 68, 0.2);
            color: #ffffff;
        }

        .pact-description,
        .pact-flavor,
        .pact-warning {
            font-style: italic;
        }

        /* スクロールバーのスタイル */
        .pact-scroll::-webkit-scrollbar {
            width: 8px;
        }

        .pact-scroll::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .pact-scroll::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 4px;
        }

        .pact-scroll::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }

        /* PACTツールチップのスタイル */
        .pact-tooltip-container {
            position: relative;
            display: inline-block;
            font-family: monospace;
            white-space: pre;
        }

        .pact-tooltip-container[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            background-color: rgba(0, 0, 0, 0.9);
            color: #fff;
            border-radius: 4px;
            font-size: 12px;
            font-family: inherit;
            /* ゲームの標準フォントを使用 */
            white-space: pre-line;
            /* 改行を維持 */
            z-index: 1000;
            pointer-events: none;
            text-align: left;
            min-width: 200px;
            border: 1px solid #4CAF50;
        }

        .pact-tooltip-container[data-tooltip]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
            pointer-events: none;
        }

        @keyframes unlock-flash {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.05);
                filter: brightness(1.5);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        .unlocking {
            animation: unlock-flash 0.5s ease-out;
        }

        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .unlock-notification {
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 15px;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideIn 0.5s ease-out, fadeOut 0.5s ease-in 4.5s;
            width: 300px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .notification-content {
            flex-grow: 1;
        }

        .notification-content h4 {
            margin: 0 0 5px 0;
            color: #4CAF50;
        }

        .notification-content p {
            margin: 0;
        }

        .unlock-notification .notification-icon {
            width: 32px;
            height: 32px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .unlock-notification .monsters-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%234CAF50" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>');
        }

        .unlock-notification .adventurers-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23FFC107" d="M12 2L4 7v10l8 5 8-5V7l-8-5zm6 14.18l-6 3.82-6-3.82V8.82l6-3.82 6 3.82v7.36z"/></svg>');
        }

        .unlock-notification .upgrades-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%239C27B0" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"/></svg>');
        }

        .unlock-notification .resources-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23F44336" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>');
        }

        .unlock-notification .special-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23FFD700" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>');
        }

        /* アンロック通知のアニメーション */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }

        /* ペナルティ状態の表示スタイル */
        .penalty {
            color: #ff4444 !important;
            text-shadow: 0 0 5px #ff0000 !important;
        }

        .warning {
            color: #ff8800;
            font-weight: bold;
        }

        .penalty-warning {
            color: #ff4444;
            font-size: 0.9em;
            font-style: italic;
        }

        .follower-info {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border-left: 3px solid #4CAF50;
        }

        .follower-info p {
            margin: 5px 0;
        }

        .follower-info .warning {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <div id="debugControls" style="position: fixed; top: 10px; left: 10px; z-index: 1000;"></div>
    <button id="toggleTimeAcceleration">Toggle Time Acceleration</button>
    <span id="timeAccelerationDisplay">x1</span>
    </div>
    <div id="ascii-title-container">
        <pre id="ascii-title">
██████╗██╗   ██╗██╗  ████████╗██╗███████╗████████╗███████╗
██╔════╝██║   ██║██║  ╚══██╔══╝██║██╔════╝╚══██╔══╝██╔════╝
██║     ██║   ██║██║     ██║   ██║███████╗   ██║   ███████╗
██║     ██║   ██║██║     ██║   ██║╚════██║   ██║   ╚════██║
╚██████╗╚██████╔╝███████╗██║   ██║███████║   ██║   ███████║
    ╚═════╝ ╚═════╝ ╚══════╝╚═╝   ╚═╝╚══════╝   ╚═╝   ╚══════╝
██████╗ ██████╗ ███╗   ███╗██████╗ ██╗     ███████╗██╗  ██╗
██╔════╝██╔═══██╗████╗ ████║██╔══██╗██║     ██╔════╝╚██╗██╔╝
██║     ██║   ██║██╔████╔██║██████╔╝██║     █████╗   ╚███╔╝ 
██║     ██║   ██║██║╚██╔╝██║██╔═══╝ ██║     ██╔══╝   ██╔██╗ 
╚██████╗╚██████╔╝██║ ╚═╝ ██║██║     ███████╗███████╗██╔╝ ██╗
    ╚═════╝ ╚═════╝ ╚═╝     ╚═╝╚═╝     ╚══════╝╚══════╝╚═╝  ╚═╝
░▒▓██╗██████╗ ██╗     ███████╗█▓▒░
░▒▓█╔╝██╔══██╗██║     ██╔════╝█▓▒░
░▒▓█║ ██║  ██║██║     █████╗  █▓▒░
░▒▓█║ ██║  ██║██║     ██╔══╝  █▓▒░
░▒▓╚██╗██████╔╝███████╗███████╗▓▒░
░▒▓ ╚═╝╚═════╝ ╚══════╝╚══════╝▓▒░
☽ ♆ ♄ Summon. Corrupt. Conquer. Idle. ♃ ♇ ☾
    </pre>
    </div>
    <h1 id="text-title" style="font-family: 'Audiowide', cursive; font-size: 1.5em;">CULTIST'S COMPLEX IDLE</h1>
    <div id="version-display">v0.1.2</div>
    <div id="upgradeSymbols" style="
    margin: 3px 0;
    padding: 5px;
    position: relative;
    overflow: visible;
"></div>
    <div id="game-header">
        <div style="text-align: center; margin: 5px 0;">
            <span style="margin-left: 15px;">Tick Speed: <span id="tickSpeedDisplay"
                    style="color: #4CAF50;"></span></span>
        </div>
        <p>
        <div id="top-buttons">
            <button id="toggleCrtEffect">CRT Effect: ON</button>
            <button id="toggleStatistics">Statistics</button>
            <button id="toggleAllMonsterCards">Collapse All Cards</button>
            <button id="jumpToSummonOldOne" title="Press 'S' to jump">Jump to Summon Old One</button>
            <button id="jumpToMadnessTable" title="Press 'A' to jump">Jump to Madness Table</button>
            <button id="backToTopBtn">Back to Top</button>
            <button id="pauseGameBtn">Pause Game</button>
            <button onclick="saveGame()">Save Game</button>
            <button onclick="loadGame()">Load Game</button>
            <button id="resetButton" onclick="resetGameAndClearSave()">Reset Game</button>
        </div>
        </p>
        <div id="resourceDisplay" class="panel">
            <!-- 左側: Source & Miasma -->
            <div class="resource-column">
                <h2>Source Collected</h2>
                <div class="resource-value-container">
                    <p id="largeSourceCount" class="resource-value">0</p>
                    <span class="rate-display">(+<span id="largeSourcePerSecond">0</span>/sec)</span>
                </div>
                <h2>Miasma Accumulated</h2>
                <div class="resource-value-container">
                    <p id="largeMiasmaCount" class="resource-value">0</p>
                    <span class="rate-display">(+<span id="largeMiasmaPerSecond">0</span>/sec)</span>
                </div>
            </div>

            <!-- 中央: ASCII アート -->
            <div id="cultosminer" class="ascii-container">
                <!-- ASCII アートがここに入ります -->
            </div>

            <!-- 右側: Cultos -->
            <div class="resource-column" id="cultosColumn">
                <h2>Cultos Mined</h2>
                <div class="resource-value-container">
                    <p id="largeCultosCount" class="resource-value">
                        <span class="cultos-symbol">©️</span>
                        <span class="cultos-count">0</span>
                        <span class="rate-display">(<span id="cultosHashRate">0</span> H/s)</span>
                    <div class="mining-status"></div>
                    <div class="mining-indicator" id="miningIndicator"></div>
                    <button id="toggleMining" class="small-button">Start Mining</button>
                </div>
                <div class="consumption-rates">
                    <div class="consumption-rate-container">
                        <p class="consumption-rate">Source:⚡︎ <span id="sourceConsumptionRate"
                                class="rate-value inactive">0/s</span></p>
                        <p class="consumption-rate">Miasma:⚡︎ <span id="miasmaConsumptionRate"
                                class="rate-value inactive">0/s</span></p>
                    </div>
                </div>
            </div>

        </div>
    </div>
    <div class="container">
        <div class="sidebar panel">
            <div id="followerSection">
                <h2>Followers</h2>
                <div class="ascii-art" id="followerAsciiArt">
                    ${asciiArt['Follower']}
                </div>
                <p>Count: <span id="followerCount">0</span></p>
                <p>Efficiency: <span id="followerEfficiency">0.1</span></p>
                <p>Production: <span id="followerPerSecond">0</span>/sec</p>
                <p>Next Recruit Cost: <span id="nextFollowerCost">10</span> source</p>
            </div>
            <h2>Resources</h2>
            <button onclick="collectSource()">Collect Source</button>
            <P><button id="recruitFollowerBtn">Recruit Follower</button></P>

            <div id="gameDetails">
                <h2>Game Details</h2>
                <p><strong>Follower Efficiency:</strong> <span id="followerEfficiencyDetail">0.1</span></p>
                <p><strong>Follower Boost:</strong> <span id="followerBoost">1.00</span>x</p>
                <p><strong>Monster Synergy Boost:</strong> <span id="monsterSynergyBoost">1.00</span>x</p>
                <p><strong>Active Upgrades:</strong> <span id="activeUpgrades">None</span></p>
                <h3>Monster Production:</h3>
                <div id="monsterProductionDetails">
                    <!-- Monster production details will be dynamically added here -->
                </div>
            </div>

            <div id="log">
                <h2>Actions Log</h2>
                <div id="logEntries">
                    <!-- Log entries will be dynamically added here -->
                </div>
            </div>
        </div>
        <div class="main-content panel">
            <div id="statisticsModal" class="modal">
                <div class="modal-content">
                    <h2>Game Statistics</h2>

                    <!-- 時間統計 -->
                    <div class="stats-section">
                        <h3>Time Statistics</h3>
                        <p>Total Time Played: <span id="timePlayed">0</span></p>
                        <p>Active Play Time: <span id="activePlayTime">0</span></p>
                    </div>

                    <!-- リソース統計 -->
                    <div class="stats-section">
                        <h3>Resource Statistics</h3>
                        <p>Total Source Generated: <span id="totalSourceGenerated">0</span></p>
                        <p>Source per Second: <span id="sourcePerSecond">0</span></p>
                        <p>Total Miasma Generated: <span id="totalMiasmaGenerated">0</span></p>
                        <p>Miasma per Second: <span id="miasmaPerSecond">0</span></p>
                        <p>Total Cultos Generated: <span id="totalCultosGenerated">0</span></p>
                        <p>Cultos per Second: <span id="cultosPerSecond">0</span></p>
                    </div>

                    <!-- フォロワー統計 -->
                    <div class="stats-section">
                        <h3>Follower Statistics</h3>
                        <p>Total Followers Recruited: <span id="totalFollowersRecruited">0</span></p>
                        <p>Peak Followers: <span id="peakFollowers">0</span></p>
                        <p>Current Followers: <span id="currentFollowers">0</span></p>
                        <p>Current Efficiency: <span id="currentFollowerEfficiency">0</span></p>
                        <p>Average Followers/Second: <span id="averageFollowersPerSecond">0</span></p>
                    </div>

                    <!-- モンスター統計 -->
                    <div class="stats-section">
                        <h3>Monster Statistics</h3>
                        <p>Total Monsters Summoned: <span id="totalMonstersSummoned">0</span></p>
                        <p>Unique Monster Types: <span id="uniqueMonsterTypes">0</span></p>
                        <p>Most Common Monster: <span id="mostCommonMonster">None</span></p>
                        <p>Total Monster Cost: <span id="totalMonsterCost">0</span></p>
                        <p>Monsters per Minute: <span id="averageMonstersPerMinute">0</span></p>
                    </div>

                    <!-- 狂気統計 -->
                    <div class="stats-section">
                        <h3>Madness Statistics</h3>
                        <p>Total Madness Attempts: <span id="totalMadnessAttempts">0</span></p>
                        <p>Successful Madness: <span id="successfulMadness">0</span></p>
                        <p>Success Rate: <span id="madnessSuccessRate">0%</span></p>
                        <p>Attempts per Hour: <span id="averageMadnessAttemptsPerHour">0</span></p>
                    </div>

                    <!-- 契約統計 -->
                    <div class="stats-section">
                        <h3>Pact Statistics</h3>
                        <p>Active Pacts: <span id="activePacts">0</span></p>
                        <p>Total Pacts Sealed: <span id="totalPactsSealed">0</span></p>
                        <p>Current Pact Multiplier: <span id="currentPactMultiplier">1</span></p>
                        <p>Tick Speed Multiplier: <span id="currentTickSpeedMultiplier">1</span></p>
                    </div>

                    <!-- アップグレード統計 -->
                    <div class="stats-section">
                        <h3>Upgrade Statistics</h3>
                        <p>Total Upgrades Purchased: <span id="totalUpgradesPurchased">0</span></p>
                        <p>Upgrade Efficiency: <span id="upgradeEfficiency">1</span></p>
                        <p>Total Upgrade Cost: <span id="totalUpgradeCost">0</span></p>
                    </div>

                    <!-- 効率性指標 -->
                    <div class="stats-section">
                        <h3>Efficiency Metrics</h3>
                        <p>Overall Efficiency: <span id="overallGameEfficiency">1</span></p>
                        <p>Resource Generation: <span id="resourceGenerationEfficiency">1</span></p>
                        <p>Follower Recruitment: <span id="followerRecruitmentEfficiency">1</span></p>
                    </div>

                    <button onclick="toggleStatisticsModal()">Close</button>
                </div>
            </div>
            <h2>Summon Old Ones</h2>
            <div id="monsterGridContainer">
                <div id="monsterGrid" class="monster-grid">

                </div>
            </div>
        </div>


        <div class="upgrades panel">
            <h2>Upgrades</h2>
            <div id="upgradeGrid" class="upgrade-grid">

                <!-- Additional upgrade cards will be dynamically added here -->
            </div>
        </div>

        <div class="madness-table panel" id="madnessTable">
            <h2>Madness Table</h2>
            <div id="adventurers">
            </div>
        </div>


        <script>
            const gameVersion = '0.1.2';
            // グローバルロックとアクション固有のロックを追加
            let globalLock = false;
            const actionLocks = {
                recruitFollower: false,
                summonMonster: {}
            };

            let gamePaused = false;

            // CRTフィルターの状態管理用のコード
            let isCrtFilterEnabled = true; // デフォルトはオン

            function toggleCrtFilter() {
                const crtButton = document.getElementById('toggleCrtEffect');
                if (!crtButton) {
                    console.warn('CRT toggle button not found');
                    return;
                }

                isCrtEnabled = !isCrtEnabled;

                // CRT効果の切り替え
                if (isCrtEnabled) {
                    document.body.classList.remove('crt-filter-disabled');
                } else {
                    document.body.classList.add('crt-filter-disabled');
                }

                // ボタンのテキスト更新
                crtButton.textContent = isCrtEnabled ? 'CRT Effect: ON' : 'CRT Effect: OFF';

                // 設定を保存
                localStorage.setItem('crtEnabled', isCrtEnabled);

                // デバッグ用のログ
                console.log('CRT Effect:', isCrtEnabled ? 'ON' : 'OFF');
                console.log('Body classes:', document.body.classList.toString());
            }

            // 初期化時のCRT効果の設定
            document.addEventListener('DOMContentLoaded', function () {
                const crtButton = document.getElementById('toggleCrtEffect');
                if (!crtButton) {
                    console.warn('CRT toggle button not found');
                    return;
                }

                // クリックイベントリスナーを追加
                crtButton.addEventListener('click', toggleCrtFilter);

                // 保存された設定を復元
                const savedCrtState = localStorage.getItem('crtEnabled');
                isCrtEnabled = savedCrtState === null ? true : savedCrtState === 'true';

                // 初期状態の設定
                if (!isCrtEnabled) {
                    document.body.classList.add('crt-filter-disabled');
                }

                crtButton.textContent = isCrtEnabled ? 'CRT Effect: ON' : 'CRT Effect: OFF';
            });

            // キーボードショートカットの追加
            document.addEventListener('keydown', function (event) {
                // Sキーが押された場合（小文字のsと大文字のSの両方に対応）
                if (event.key.toLowerCase() === 's' && !event.ctrlKey && !event.altKey &&
                    document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    event.preventDefault(); // デフォルトの動作を防止
                    document.getElementById('jumpToSummonOldOne').click();
                }
                if (event.key.toLowerCase() === 'a' && !event.ctrlKey && !event.altKey &&
                    document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    event.preventDefault(); // デフォルトの動作を防止
                    document.getElementById('jumpToMadnessTable').click();
                }
                if (event.code === 'Space' && !event.repeat) {
                    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                        return;
                    }

                    event.preventDefault();

                    const pauseButton = document.getElementById('pauseGameBtn');

                    // ゲームの一時停止状態を切り替え
                    if (gamePaused) {
                        resumeGame();
                        pauseButton.textContent = 'Pause Game';
                        pauseButton.style.borderColor = '#4CAF50';  // 緑色の枠
                        pauseButton.style.color = '#e0e0e0';        // 通常のテキスト色
                    } else {
                        pauseGame();
                        pauseButton.textContent = 'Resume Game';
                        pauseButton.style.borderColor = '#ff0000';  // 赤色の枠
                        pauseButton.style.color = '#ff0000';        // 赤色のテキスト
                    }
                }
                if (event.key === '[' || event.key === ']') {
                    // 購入可能なアイテムを取得
                    const allAvailableItems = getAvailableItems();
                    if (allAvailableItems.length === 0) return;

                    // 実際に購入できるアイテムのみをフィルタリング
                    const purchasableItems = allAvailableItems.filter(item => {
                        switch (item.type) {
                            case 'monster':
                                const monster = gameState.monsters[item.id];
                                const followerCost = Math.floor(monster.baseFollowerCost *
                                    Math.pow(monster.followerCostGrowth, monster.count));
                                return gameState.source >= item.cost && gameState.followers >= followerCost;

                            case 'upgrade':
                                return gameState.source >= item.cost;

                            case 'follower':
                                return gameState.source >= item.cost;

                            default:
                                return false;
                        }
                    });

                    if (purchasableItems.length === 0) return;

                    // コストでソート
                    purchasableItems.sort((a, b) => b.cost - a.cost); // 高い順

                    // フォロワー以外の購入可能なアイテム
                    const nonFollowerItems = purchasableItems.filter(item => item.type !== 'follower');

                    // '[' は最も高いコスト、']' は最も低いコストのアイテムを購入
                    const itemToBuy = event.key === '['
                        ? (nonFollowerItems.length > 0 ? nonFollowerItems[0] : purchasableItems[0])
                        : purchasableItems[purchasableItems.length - 1];

                    // アイテムの種類に応じて購入処理を実行
                    switch (itemToBuy.type) {
                        case 'monster':
                            summonMonster(itemToBuy.id);
                            break;
                        case 'upgrade':
                            buyUpgrade(itemToBuy.id);
                            break;
                        case 'follower':
                            recruitFollower();
                            break;
                    }
                }
            });

            // 購入可能なアイテムを取得する関数
            function getAvailableItems() {
                const items = [];
                const sourceCount = gameState.source;

                // フォロワーのチェック - 契約による封印をチェック
                const followerCost = getCost('follower');
                const isFollowerRecruitmentSealed = gameState.pacts?.active?.some(pact =>
                    PACTS[pact]?.effects?.some(effect => effect.type === 'sealManualRecruits')
                ) ?? false;

                // 最小フォロワー数の効果をチェック
                const minimumFollowersEffect = gameState.pacts?.active?.reduce((min, pact) => {
                    const effect = PACTS[pact]?.effects?.find(e => e.type === 'minimumFollowers');
                    return effect ? Math.max(min, effect.value) : min;
                }, 0) ?? 0;

                // フォロワー数が最小値以下の場合、コストを0に
                const actualFollowerCost = gameState.followers < minimumFollowersEffect ? 0 : followerCost;

                if ((sourceCount >= actualFollowerCost || actualFollowerCost === 0) && !isFollowerRecruitmentSealed) {
                    items.push({
                        type: 'follower',
                        id: 'follower',
                        cost: actualFollowerCost
                    });
                }

                // モンスターのチェック
                for (const [monsterType, monster] of Object.entries(gameState.monsters)) {
                    if (!checkUnlockCondition('monsters', monsterType)) continue;

                    const sourceCost = getCost(monsterType);
                    const followerCost = Math.floor(monster.baseFollowerCost *
                        Math.pow(monster.followerCostGrowth, monster.count));

                    if (sourceCount >= sourceCost && gameState.followers >= followerCost) {
                        items.push({
                            type: 'monster',
                            id: monsterType,
                            cost: sourceCost
                        });
                    }
                }

                // アップグレードのチェック
                for (const upgrade of upgradeOrder) {
                    if (gameState.upgrades.includes(upgrade)) continue;
                    if (!checkUnlockCondition('upgrades', upgrade)) continue;

                    const cost = Math.floor(baseCosts[upgrade] * (gameState.upgradeCostMultiplier || 1));
                    if (sourceCount >= cost) {
                        items.push({
                            type: 'upgrade',
                            id: upgrade,
                            cost: cost
                        });
                    }
                }

                return items;
            }

            // タイトルの切り替え機能
            let isAscii = true;
            const asciiContainer = document.getElementById('ascii-title-container');
            const textTitle = document.getElementById('text-title');

            asciiContainer.addEventListener('click', function () {
                if (isAscii) {
                    // ASCIIアートからテキストへ
                    asciiContainer.classList.add('fade-out');
                    setTimeout(() => {
                        asciiContainer.style.display = 'none';
                        textTitle.style.display = 'block';
                        setTimeout(() => {
                            textTitle.classList.add('fade-in');
                        }, 50);
                    }, 300);
                }
                isAscii = !isAscii;
            });

            textTitle.addEventListener('click', function () {
                if (!isAscii) {
                    // テキストからASCIIアートへ
                    textTitle.classList.remove('fade-in');
                    setTimeout(() => {
                        textTitle.style.display = 'none';
                        asciiContainer.style.display = 'block';
                        asciiContainer.classList.remove('fade-out');
                    }, 300);
                }
                isAscii = !isAscii;
            });

            document.addEventListener('DOMContentLoaded', function () {
                const resourceDisplay = document.getElementById('resourceDisplay');
                if (!resourceDisplay) return;

                // topボタンに新しいボタンを追加
                const topButtons = document.getElementById('top-buttons');
                if (topButtons) {
                    const toggleDisplayButton = document.createElement('button');
                    toggleDisplayButton.id = 'toggleResourceDisplay';
                    toggleDisplayButton.textContent = 'Simple View: OFF';

                    // デフォルトで normal モードに設定
                    resourceDisplay.classList.remove('simple');
                    localStorage.setItem('resourceDisplayMode', 'normal');

                    // 新しいボタンのクリックイベント
                    toggleDisplayButton.addEventListener('click', function () {
                        const isSimple = resourceDisplay.classList.toggle('simple');
                        toggleDisplayButton.textContent = `Simple View: ${isSimple ? 'ON' : 'OFF'}`;
                        localStorage.setItem('resourceDisplayMode', isSimple ? 'simple' : 'normal');
                    });

                    // CRT Effect ボタンの後に挿入
                    const crtButton = document.getElementById('toggleCrtEffect');
                    if (crtButton && crtButton.parentNode) {
                        crtButton.parentNode.insertBefore(toggleDisplayButton, crtButton.nextSibling);
                    } else {
                        topButtons.appendChild(toggleDisplayButton);
                    }
                }
            });

            let timeAcceleration = 1; // デフォルトは通常速度
            // Game state
            let gameState = {

                source: 0,
                miasma: 0,
                cultos: 0,
                cultosRate: 0,
                followers: 0,
                followerEfficiency: 0.1,
                followerAccumulator: 0,
                monsters: {
                    'Shoggoth': {
                        count: 0,
                        sourceEfficiency: 0.5,
                        miasmaEfficiency: 0.1,
                        baseFollowerCost: 1,
                        followerCostGrowth: 1.1,
                        synergy: { partner: 'Deep One', effect: 0.09 },
                        specialAbility: { trigger: 100, effect: { type: 'allMonsterEfficiency', value: 0.005 } }
                    },
                    'This Man': {
                        count: 0,
                        sourceEfficiency: 1.8,
                        miasmaEfficiency: 0.36,
                        baseFollowerCost: 2,
                        followerCostGrowth: 1.12,
                        synergy: { partner: 'Byakhee', effect: 0.135, type: 'miasma' },
                        specialAbility: { trigger: 10, effect: { type: 'madnessChance', value: 0.05 } }
                    },
                    'Deep One': {
                        count: 0,
                        sourceEfficiency: 3.0,
                        miasmaEfficiency: 0.5,
                        baseFollowerCost: 3,
                        followerCostGrowth: 1.15,
                        synergy: { partner: 'Shoggoth', effect: 0.09 },
                        specialAbility: {
                            trigger: 25,
                            effect: {
                                type: 'miasmaEfficiency',
                                value: 0.025
                            }
                        }
                    },
                    'Byakhee': {
                        count: 0,
                        sourceEfficiency: 6.5,
                        miasmaEfficiency: 1.1,
                        baseFollowerCost: 4,
                        followerCostGrowth: 1.17,
                        synergy: { partner: 'This Man', effect: 0.135, type: 'miasma' },
                        specialAbility: { trigger: 30, effect: { type: 'sourceProduction', value: 0.027 } }
                    },
                    'Elder Thing': {
                        count: 0,
                        sourceEfficiency: 10.0,
                        miasmaEfficiency: 2.0,
                        baseFollowerCost: 5,
                        followerCostGrowth: 1.2,
                        synergy: { partner: 'Mi-go', effect: 0.18, type: 'source' },
                        specialAbility: { trigger: 20, effect: { type: 'upgradeEffect', value: 0.009 } }
                    },
                    'Mossman': {
                        count: 0,
                        sourceEfficiency: 16.0,
                        miasmaEfficiency: 3.2,
                        baseFollowerCost: 7,
                        followerCostGrowth: 1.22,
                        synergy: { partner: 'Nightgaunt', effect: 0.225, type: 'miasma' },
                        specialAbility: { trigger: 15, effect: { type: 'followerProduction', value: 0.09 } }
                    },
                    'Star Spawn': {
                        count: 0,
                        sourceEfficiency: 25.0,
                        miasmaEfficiency: 5.0,
                        baseFollowerCost: 10,
                        followerCostGrowth: 1.25,
                        synergy: { partner: 'Uroboros', effect: 0.27 },
                        specialAbility: { trigger: 10, effect: { type: 'cosmicResonance', value: 0.01 } }
                    },
                    'Mi-go': {
                        count: 0,
                        sourceEfficiency: 75.0,
                        miasmaEfficiency: 15.0,
                        baseFollowerCost: 20,
                        followerCostGrowth: 1.3,
                        synergy: { partner: 'Elder Thing', effect: 0.18, type: 'source' },
                        specialAbility: {
                            trigger: 5,
                            effect: {
                                type: 'upgradeCost',
                                value: 0.0025,
                                maxDiscount: 0.4
                            }
                        }
                    },
                    'Nightgaunt': {
                        count: 0,
                        sourceEfficiency: 250.0,
                        miasmaEfficiency: 50.0,
                        baseFollowerCost: 50,
                        followerCostGrowth: 1.35,
                        synergy: {
                            partner: 'Mossman',
                            effect: 0.225,
                            type: 'miasma'
                        },
                        specialAbility: {
                            trigger: 10,
                            effect: {
                                type: 'adventurerResistanceRecoveryTime',
                                value: 1000  // 1秒（1000ミリ秒）のクールダウン削減
                            }
                        }
                    },
                    'Uroboros': {
                        count: 0,
                        sourceEfficiency: 900.0,
                        miasmaEfficiency: 180.0,
                        baseFollowerCost: 100,
                        followerCostGrowth: 1.4,
                        synergy: { partner: 'Star Spawn', effect: 0.27 },
                        specialAbility: { trigger: 10, effect: { type: 'allMonsterEfficiency', value: 0.0009 } }
                    }
                },
                upgrades: [],
                followerEfficiency: 0.1,
                adventurers: [
                    { name: "Novice Explorer", miasmaRequired: 100, followerReward: 1, followerProduction: 0.1, madnessChance: 0.7, level: 0, isMad: false, cooldownEndTime: 0, baseCooldown: 16000 },
                    { name: "Seasoned Investigator", miasmaRequired: 500, followerReward: 4, followerProduction: 0.5, madnessChance: 0.5, level: 0, isMad: false, cooldownEndTime: 0, baseCooldown: 33000 },
                    { name: "Arcane Scholar", miasmaRequired: 2000, followerReward: 18, followerProduction: 2.0, madnessChance: 0.3, level: 0, isMad: false, cooldownEndTime: 0, baseCooldown: 70000 },
                    { name: "Occult Detective", miasmaRequired: 5000, followerReward: 45, followerProduction: 5.0, madnessChance: 0.2, level: 0, isMad: false, cooldownEndTime: 0, baseCooldown: 12000 },
                    { name: "Eldritch Archaeologist", miasmaRequired: 10000, followerReward: 90, followerProduction: 10.0, madnessChance: 0.01, level: 0, isMad: false, cooldownEndTime: 0, baseCooldown: 210000 },
                    { name: "Cosmic Voyager", miasmaRequired: 20000, followerReward: 180, followerProduction: 20.0, madnessChance: 0.005, level: 0, isMad: false, cooldownEndTime: 0, baseCooldown: 330000 }
                ],

                // アンロック済みコンテンツの追跡用
                unlockedContent: {
                    monsters: new Set(['Shoggoth']),
                    adventurers: new Set(['Novice Explorer']),
                    upgrades: new Set(['Ritual Knowledge']),
                    resources: new Set()
                },
                pacts: {
                    active: [],              // 発動中の契約
                    commonMultiplier: 1,     // 共通の倍率効果 (1.125^契約数)
                    tickSpeedMultiplier: 1,  // Tick speed倍率 (1.125^契約数)
                    showingPactModal: false, // 契約モーダル表示状態
                },
            };

            const initialGameState = {
                source: 0,
                miasma: 0,
                cultos: 0,
                cultosRate: 0,
                followers: 0,
                monsters: {
                    'Shoggoth': {
                        count: 0,
                        sourceEfficiency: 0.5,
                        miasmaEfficiency: 0.1,
                        baseFollowerCost: 1,
                        followerCostGrowth: 1.15,
                        synergy: { partner: 'Deep One', effect: 0.09 },
                        specialAbility: { trigger: 100, effect: { type: 'allMonsterEfficiency', value: 0.005 } }
                    },
                    'This Man': {
                        count: 0,
                        sourceEfficiency: 2.0,
                        miasmaEfficiency: 0.4,
                        baseFollowerCost: 2,
                        followerCostGrowth: 1.18,
                        synergy: { partner: 'Byakhee', effect: 0.135, type: 'miasma' },
                        specialAbility: { trigger: 10, effect: { type: 'madnessChance', value: 0.05 } }
                    },
                    'Deep One': {
                        count: 0,
                        sourceEfficiency: 5.0,
                        miasmaEfficiency: 1.0,
                        baseFollowerCost: 3,
                        followerCostGrowth: 1.21,
                        synergy: { partner: 'Shoggoth', effect: 0.09 },
                        specialAbility: {
                            trigger: 25,
                            effect: { type: 'miasmaEfficiency', value: 0.025 }
                        }
                    },
                    'Byakhee': {
                        count: 0,
                        sourceEfficiency: 12.0,
                        miasmaEfficiency: 2.4,
                        baseFollowerCost: 4,
                        followerCostGrowth: 1.24,
                        synergy: { partner: 'This Man', effect: 0.135, type: 'miasma' },
                        specialAbility: { trigger: 30, effect: { type: 'sourceProduction', value: 0.027 } }
                    },
                    'Elder Thing': {
                        count: 0,
                        sourceEfficiency: 30.0,
                        miasmaEfficiency: 6.0,
                        baseFollowerCost: 5,
                        followerCostGrowth: 1.27,
                        synergy: { partner: 'Mi-go', effect: 0.18, type: 'source' },
                        specialAbility: { trigger: 20, effect: { type: 'upgradeEffect', value: 0.009 } }
                    },
                    'Mossman': {
                        count: 0,
                        sourceEfficiency: 75.0,
                        miasmaEfficiency: 15.0,
                        baseFollowerCost: 7,
                        followerCostGrowth: 1.30,
                        synergy: { partner: 'Nightgaunt', effect: 0.225, type: 'miasma' },
                        specialAbility: { trigger: 15, effect: { type: 'followerProduction', value: 0.09 } }
                    },
                    'Star Spawn': {
                        count: 0,
                        sourceEfficiency: 200.0,
                        miasmaEfficiency: 40.0,
                        baseFollowerCost: 10,
                        followerCostGrowth: 1.33,
                        synergy: { partner: 'Uroboros', effect: 0.27 },
                        specialAbility: { trigger: 10, effect: { type: 'cosmicResonance', value: 0.01 } }
                    },
                    'Mi-go': {
                        count: 0,
                        sourceEfficiency: 500.0,
                        miasmaEfficiency: 100.0,
                        baseFollowerCost: 20,
                        followerCostGrowth: 1.36,
                        synergy: { partner: 'Elder Thing', effect: 0.18, type: 'source' },
                        specialAbility: {
                            trigger: 5,
                            effect: {
                                type: 'upgradeCost',
                                value: 0.0025,
                                maxDiscount: 0.4
                            }
                        }
                    },
                    'Nightgaunt': {
                        count: 0,
                        sourceEfficiency: 1250.0,
                        miasmaEfficiency: 250.0,
                        baseFollowerCost: 50,
                        followerCostGrowth: 1.39,
                        synergy: {
                            partner: 'Mossman',
                            effect: 0.225,
                            type: 'miasma'
                        },
                        specialAbility: {
                            trigger: 10,
                            effect: {
                                type: 'adventurerResistanceRecoveryTime',
                                value: 1000
                            }
                        }
                    },
                    'Uroboros': {
                        count: 0,
                        sourceEfficiency: 3000.0,
                        miasmaEfficiency: 600.0,
                        baseFollowerCost: 100,
                        followerCostGrowth: 1.42,
                        synergy: { partner: 'Star Spawn', effect: 0.27 },
                        specialAbility: { trigger: 10, effect: { type: 'allMonsterEfficiency', value: 0.0009 } }
                    }
                },
                upgrades: [],
                followerEfficiency: 0.1,

                cosmicAlignmentBonus: 1,
                astralProjectionRate: 0,
                quantumEntanglementBonus: 0,
                temporalManipulationBonus: 1,
                eldritchEvolutionRate: 0,
                upgradeCostMultiplier: 1,

                adventurers: [
                    {
                        name: "Novice Explorer",
                        miasmaRequired: 100,
                        followerReward: 1,
                        followerProduction: 0.1,
                        madnessChance: 0.7,    // 明示的に初期値を設定
                        level: 0,
                        isMad: false,
                        cooldownEndTime: 0,
                        baseCooldown: 16000
                    },
                    {
                        name: "Seasoned Investigator",
                        miasmaRequired: 500,
                        followerReward: 4,
                        followerProduction: 0.5,
                        madnessChance: 0.5,
                        level: 0,
                        isMad: false,
                        cooldownEndTime: 0,
                        baseCooldown: 33000
                    },
                    {
                        name: "Arcane Scholar",
                        miasmaRequired: 2000,
                        followerReward: 18,
                        followerProduction: 2.0,
                        madnessChance: 0.3,
                        level: 0,
                        isMad: false,
                        cooldownEndTime: 0,
                        baseCooldown: 70000
                    },
                    {
                        name: "Occult Detective",
                        miasmaRequired: 5000,
                        followerReward: 45,
                        followerProduction: 5.0,
                        madnessChance: 0.2,
                        level: 0,
                        isMad: false,
                        cooldownEndTime: 0,
                        baseCooldown: 120000
                    },
                    {
                        name: "Eldritch Archaeologist",
                        miasmaRequired: 10000,
                        followerReward: 90,
                        followerProduction: 10.0,
                        madnessChance: 0.1,
                        level: 0,
                        isMad: false,
                        cooldownEndTime: 0,
                        baseCooldown: 210000
                    },
                    {
                        name: "Cosmic Voyager",
                        miasmaRequired: 20000,
                        followerReward: 180,
                        followerProduction: 20.0,
                        madnessChance: 0.05,
                        level: 0,
                        isMad: false,
                        cooldownEndTime: 0,
                        baseCooldown: 330000
                    }
                ],
                // アンロック状態の初期値
                unlockedContent: {
                    monsters: new Set(),
                    adventurers: new Set(),
                    upgrades: new Set(),
                    resources: new Set()
                },
                // アップグレード状態
                upgrades: [],

                // 契約システムの初期状態
                pacts: {
                    active: [],
                    commonMultiplier: 1,
                    tickSpeedMultiplier: 1,
                    showingPactModal: false
                },

                // 統計情報の初期状態
                statistics: {
                    startTime: Date.now(),
                    lastUpdate: Date.now(),
                    totalSourceGenerated: 0,
                    totalMiasmaGenerated: 0,
                    totalFollowersRecruited: 0,
                    peakFollowers: 0,
                    totalMonstersSummoned: 0,
                    totalMadnessAttempts: 0,
                    successfulMadness: 0
                },
            };

            const monsterOrder = [
                'Shoggoth',
                'This Man',
                'Deep One',
                'Byakhee',
                'Elder Thing',
                'Mossman',
                'Star Spawn',
                'Mi-go',
                'Nightgaunt',
                'Uroboros'
            ];

            const baseCosts = {
                follower: 10,
                'Shoggoth': 100,
                'This Man': 800,      // 8倍
                'Deep One': 4000,     // 5倍
                'Byakhee': 15000,     // 3.75倍
                'Elder Thing': 50000,  // 3.33倍
                'Mossman': 150000,    // 3倍
                'Star Spawn': 400000, // 2.67倍
                'Mi-go': 1000000,     // 2.5倍
                'Nightgaunt': 2500000, // 2.5倍
                'Uroboros': 6000000,  // 2.4倍

                // フォロワーコスト成長率も調整
                followerCostGrowth: {
                    'Shoggoth': 1.15,
                    'This Man': 1.18,
                    'Deep One': 1.21,
                    'Byakhee': 1.24,
                    'Elder Thing': 1.27,
                    'Mossman': 1.30,
                    'Star Spawn': 1.33,
                    'Mi-go': 1.36,
                    'Nightgaunt': 1.39,
                    'Uroboros': 1.42
                },
                // アップグレードの価格を調整
                follower: 10,
                'Ritual Knowledge': 150,        // 最初の基本的なアップグレード
                'Eldritch Tome': 500,          // 早期に取得可能な強化
                'Hiroshi Sakamoto`s Paper': 2000, // 特殊なアップグレード
                'Cosmic Alignment': 3000,      // 中盤の重要な強化
                'Forbidden Ritual': 8000,            // 中盤後半の強力な強化
                'Hermetic Teachings': 35000,   // 後半の重要なアップグレード
                'Cosmic Insight': 80000,      // エンドゲームの強力な強化
                'Astral Projection': 300000,   // 特殊な生産ボーナス
                'Dimensional Rift': 500000,    // 非常に強力な相乗効果
                'Necronomicon Fragment': 1200000, // 超後期の強化
                'Psychic Attunement': 2500000,    // 特殊な強化効果
                'Quantum Entanglement': 6000000,  // 最終段階の強化
                'Temporal Manipulation': 8000000, // 究極の時間操作
                'Eldritch Evolution': 30000000
            };

            const monsterEfficiencies = {
                'Shoggoth': {
                    sourceEfficiency: 0.5,
                    miasmaEfficiency: 0.1
                },
                'This Man': {
                    sourceEfficiency: 2.0,
                    miasmaEfficiency: 0.4
                },
                'Deep One': {
                    sourceEfficiency: 5.0,
                    miasmaEfficiency: 1.0
                },
                'Byakhee': {
                    sourceEfficiency: 12.0,
                    miasmaEfficiency: 2.4
                },
                'Elder Thing': {
                    sourceEfficiency: 30.0,
                    miasmaEfficiency: 6.0
                },
                'Mossman': {
                    sourceEfficiency: 75.0,
                    miasmaEfficiency: 15.0
                },
                'Star Spawn': {
                    sourceEfficiency: 200.0,
                    miasmaEfficiency: 40.0
                },
                'Mi-go': {
                    sourceEfficiency: 500.0,
                    miasmaEfficiency: 100.0
                },
                'Nightgaunt': {
                    sourceEfficiency: 1250.0,
                    miasmaEfficiency: 250.0
                },
                'Uroboros': {
                    sourceEfficiency: 3000.0,
                    miasmaEfficiency: 600.0
                }
            };

            // アップグレードの順序配列も更新
            const upgradeOrder = [
                'Ritual Knowledge',
                'Eldritch Tome',
                'Hiroshi Sakamoto`s Paper',
                'Cosmic Alignment',
                'Forbidden Ritual',
                'Hermetic Teachings',
                'Cosmic Insight',
                'Astral Projection',
                'Dimensional Rift',
                'Necronomicon Fragment',
                'Psychic Attunement',
                'Quantum Entanglement',
                'Temporal Manipulation',
                'Eldritch Evolution'
            ];

            const upgradeEffects = {
                'Ritual Knowledge': 'Increases follower efficiency by 25%',
                'Eldritch Tome': 'Increases all monster efficiencies by 25%',
                'Hiroshi Sakamoto`s Paper': 'Unlocks the ability to use Cultos Miner',
                'Cosmic Alignment': 'Improves overall production by 10% when followers and monsters are balanced',
                'Forbidden Ritual': 'Increases source production by 40%',
                'Hermetic Teachings': 'Increases follower efficiency by 30%',
                'Cosmic Insight': 'Increases follower and monster efficiencies by 35%',
                'Astral Projection': 'Adds 3% of your total source to production every second',
                'Necronomicon Fragment': 'Boosts monster production by 50%',
                'Psychic Attunement': 'Increases miasma production by 30%',
                'Quantum Entanglement': 'Each monster type boosts the efficiency of another by 5%',
                'Temporal Manipulation': 'Speeds up resource generation by 20%',
                'Eldritch Evolution': 'Monsters gain 1% efficiency for every 10 levels',
                'Dimensional Rift': 'Increases the effect of all other upgrades by 50%'
            };

            const upgradeSymbols = {
                'Ritual Knowledge': '📚',
                'Eldritch Tome': '📜',
                'Hiroshi Sakamoto`s Paper': '📄',
                'Cosmic Alignment': '🌌',
                'Forbidden Ritual': '🔮',
                'Hermetic Teachings': '🌿',
                'Cosmic Insight': '👁️',
                'Astral Projection': '🪐',
                'Necronomicon Fragment': '📖',
                'Psychic Attunement': '🧠',
                'Quantum Entanglement': '🔗',
                'Temporal Manipulation': '⏳',
                'Eldritch Evolution': '🧬',
                'Dimensional Rift': '🕳️'
            };

            const PACTS = {
                1: {
                    name: "The Awakening Pact",
                    condition: { source: 1e6 },
                    description: "The time of your awakening has come. Through this contract, you shall gain new powers, but at the cost of your current progress.",
                    flavorText: "As you sign the contract, ancient symbols begin to glow with an ethereal light...",
                    effects: [
                        {
                            type: "sealManualRecruits",
                            description: "Manual recruitment is sealed, granting access to automatic powers"
                        },
                        {
                            type: "minimumFollowers",
                            value: 1,
                            description: "Maintain a minimum of 1 followers"
                        },
                        {
                            type: "followerEfficiency",
                            value: 0.25,
                            description: "Follower efficiency increased by 25%"
                        },
                        {
                            type: "globalMultiplier",
                            value: 0.25,
                            description: "All resource gains increased by 25%"
                        },
                        {
                            type: "tickSpeed",
                            value: 0.25,
                            description: "Time flows 25% faster"
                        }
                    ],
                    warning: "* Accepting this contract will halt current progress and reset everything except permanent effects",
                    followerAsciiArt: `
<span style="color:#4B0082">      ▄▄█▀▀█▄▄      </span>
<span style="color:#4B0082">    ▄█▀</span><span style="color:#6A0DAD">░░░░░░</span><span style="color:#4B0082">▀█▄    </span>
<span style="color:#4B0082">   █▀░</span><span style="color:#8A2BE2">▄▄███▄▄</span><span style="color:#4B0082">░▀█   </span>
<span style="color:#4B0082">  █░</span><span style="color:#8A2BE2">█</span><span style="color:#4B0082">▒</span><span style="color:#9400D3">◈◈◈◈</span><span style="color:#4B0082">▒</span><span style="color:#8A2BE2">█</span><span style="color:#4B0082">░█  </span>
<span style="color:#4B0082"> █░</span><span style="color:#8A2BE2">█▀▄</span><span style="color:#4B0082">▒</span><span style="color:#9400D3">░░░</span><span style="color:#4B0082">▒</span><span style="color:#8A2BE2">▄▀█</span><span style="color:#4B0082">░█ </span>
<span style="color:#4B0082">█░</span><span style="color:#8A2BE2">▄█▀░</span><span style="color:#4B0082">▒</span><span style="color:#9400D3">∴∴∴</span><span style="color:#4B0082">▒</span><span style="color:#8A2BE2">░▀█▄</span><span style="color:#4B0082">░█</span>
<span style="color:#4B0082">█░</span><span style="color:#9932CC">█▄▄██████▄▄█</span><span style="color:#4B0082">░█</span>
<span style="color:#4B0082">█░</span><span style="color:#9932CC">███████████</span><span style="color:#4B0082">░█</span>
<span style="color:#4B0082">█░</span><span style="color:#BA55D3">███</span><span style="color:#DDA0DD">▒▒▒▒▒</span><span style="color:#BA55D3">███</span><span style="color:#4B0082">░█</span>
<span style="color:#4B0082">█░░</span><span style="color:#BA55D3">██</span><span style="color:#DDA0DD">▒</span><span style="color:#FF1493">✧</span><span style="color:#DDA0DD">▒</span><span style="color:#FF1493">✧</span><span style="color:#DDA0DD">▒</span><span style="color:#BA55D3">██</span><span style="color:#4B0082">░░█</span>
<span style="color:#4B0082">█▄░░</span><span style="color:#BA55D3">█</span><span style="color:#DDA0DD">▒▒▒▒▒▒▒</span><span style="color:#BA55D3">█</span><span style="color:#4B0082">░░▄█</span>
<span style="color:#4B0082"> █▀▄▄░</span><span style="color:#DDA0DD">▒▒▒▒▒</span><span style="color:#4B0082">░▄▄▀█ </span>
<span style="color:#4B0082"> ▀█░░▀</span><span style="color:#DDA0DD">▒▒▒▒▒</span><span style="color:#4B0082">▀░░█▀ </span>
<span style="color:#4B0082">  ▀█▄░░</span><span style="color:#DDA0DD">▒▒▒</span><span style="color:#4B0082">░░▄█▀  </span>
<span style="color:#4B0082">    ▀▀█▄▄▄█▀▀    </span>
    `,
                    tooltipText: "Awakened Follower - Bound by the First Contract"
                },
                2: {
                    name: "The Void Pact",
                    condition: {
                        source: 1e28 // 1000兆のsource
                    },
                    description: "A contract with the void itself. The darkness beckons, offering greater power at a steeper cost.",
                    flavorText: "As you sign the contract, shadows seem to dance at the edges of your vision...",
                    effects: [
                        {
                            type: "minimumFollowers",
                            value: 3,
                            description: "Maintain a minimum of 3 followers"
                        },
                        {
                            type: "followerEfficiency",
                            value: 0.5,
                            description: "Follower efficiency increased by 50%"
                        },
                        {
                            type: "globalMultiplier",
                            value: 0.5,
                            description: "All resource gains increased by 50%"
                        },
                        {
                            type: "tickSpeed",
                            value: 0.5,
                            description: "Time flows 50% faster"
                        }
                    ],
                    warning: "* Accepting this contract will reset your current progress but maintain permanent effects",
                    followerAsciiArt: `
<span style="color:#0a000a">       ▄∿█▀▀█∿▄       </span>
<span style="color:#0a000a">     ▄█▀</span><span style="color:#1a001a">░●  ●░</span><span style="color:#0a000a">▀█▄     </span>
<span style="color:#0a000a">   ▄█▀░</span><span style="color:#2a002a">▄░███░▄</span><span style="color:#0a000a">░▀█▄   </span>
<span style="color:#0a000a">  █▀░</span><span style="color:#2a002a">█▀</span><span style="color:#0a000a">▒</span><span style="color:#4d004d">◈◆◆◈</span><span style="color:#0a000a">▒</span><span style="color:#2a002a">▀█</span><span style="color:#0a000a">░▀█  </span>
<span style="color:#0a000a"> █∿</span><span style="color:#2a002a">█▀░▄</span><span style="color:#0a000a">▒</span><span style="color:#4d004d">∵∴∵</span><span style="color:#0a000a">▒</span><span style="color:#2a002a">▄░▀█</span><span style="color:#0a000a">∿█ </span>
<span style="color:#0a000a">█∿</span><span style="color:#2a002a">▄█▀░</span><span style="color:#0a000a">▒</span><span style="color:#4d004d">∷❈∷</span><span style="color:#0a000a">▒</span><span style="color:#2a002a">░▀█▄</span><span style="color:#0a000a">∿█</span>
<span style="color:#0a000a">█░</span><span style="color:#400040">█∿▄██████▄∿█</span><span style="color:#0a000a">░█</span>
<span style="color:#0a000a">█∿</span><span style="color:#400040">██∿█████∿██</span><span style="color:#0a000a">∿█</span>
<span style="color:#0a000a">█▄</span><span style="color:#600060">██▀</span><span style="color:#800080">▒▓▒▓▒</span><span style="color:#600060">▀██</span><span style="color:#0a000a">▄█</span>
<span style="color:#0a000a">█░∿</span><span style="color:#600060">██</span><span style="color:#800080">▒</span><span style="color:#cc00cc">✧</span><span style="color:#800080">▒</span><span style="color:#cc00cc">✧</span><span style="color:#800080">▒</span><span style="color:#600060">██</span><span style="color:#0a000a">∿░█</span>
<span style="color:#0a000a">█▄∿░</span><span style="color:#600060">█</span><span style="color:#800080">▓▒∿▒∿▓</span><span style="color:#600060">█</span><span style="color:#0a000a">░∿▄█</span>
<span style="color:#0a000a"> █▀▄∿░</span><span style="color:#800080">▓▒∿▒▓</span><span style="color:#0a000a">░∿▄▀█ </span>
<span style="color:#0a000a"> ▀█░∿▀</span><span style="color:#800080">▒▓∿▓▒</span><span style="color:#0a000a">▀∿░█▀ </span>
<span style="color:#0a000a">  ▀█▄∿░</span><span style="color:#800080">▒▓▒</span><span style="color:#0a000a">░∿▄█▀  </span>
<span style="color:#0a000a">    ▀▀█∿∿∿█▀▀    </span>`,

                    tooltipText: `Void Touched Follower - Transformed by the Second Contract`,
                }
            };

            const unlockConditions = {
                monsters: {
                    'Shoggoth': { // 最初から解放
                        isUnlocked: true
                    },
                    'This Man': {
                        requirement: {
                            monsters: { 'Shoggoth': 5 },
                        },
                        description: "Requires 5 Shoggoths"
                    },
                    'Deep One': {
                        requirement: {
                            monsters: { 'This Man': 4, 'Shoggoth': 8 },
                        },
                        description: "Requires 4 This Man, 8 Shoggoths"
                    },
                    'Byakhee': {
                        requirement: {
                            monsters: { 'Deep One': 4, 'This Man': 6 },
                        },
                        description: "Requires 4 Deep Ones, 6 This Man"
                    },
                    'Elder Thing': {
                        requirement: {
                            monsters: { 'Byakhee': 3, 'Deep One': 8 },
                            upgrades: ['Forbidden Ritual']
                        },
                        description: "Requires 3 Byakhee, 8 Deep Ones and Forbidden Ritual upgrade"
                    },
                    'Mossman': {
                        requirement: {
                            monsters: { 'Elder Thing': 3, 'Byakhee': 6, 'Deep One': 10 },
                            upgrades: ['Hermetic Teachings']
                        },
                        description: "Requires 3 Elder Things, 6 Byakhee, 10 Deep Ones and Hermetic Teachings upgrade"
                    },
                    'Star Spawn': {
                        requirement: {
                            monsters: { 'Mossman': 3, 'Elder Thing': 5 },
                            upgrades: ['Cosmic Insight']
                        },
                        description: "Requires 3 Mossman, 5 Elder Things and Cosmic Insight upgrade"
                    },
                    'Mi-go': {
                        requirement: {
                            monsters: { 'Star Spawn': 2, 'Mossman': 4, 'Elder Thing': 8 },
                            upgrades: ['Astral Projection']
                        },
                        description: "Requires 2 Star Spawns, 4 Mossman, 8 Elder Things and Astral Projection upgrade"
                    },
                    'Nightgaunt': {
                        requirement: {
                            monsters: { 'Mi-go': 2, 'Star Spawn': 4, 'Mossman': 6 },
                            upgrades: ['Forbidden Ritual', 'Dimensional Rift']
                        },
                        description: "Requires 2 Mi-go, 4 Star Spawns, 6 Mossman, Forbidden Ritual and Dimensional Rift upgrades"
                    },
                    'Uroboros': {
                        requirement: {
                            monsters: { 'Nightgaunt': 2, 'Mi-go': 4, 'Star Spawn': 6 },
                            upgrades: ['Dimensional Rift', 'Necronomicon Fragment']
                        },
                        description: "Requires 2 Nightgaunts, 4 Mi-go, 6 Star Spawns, Dimensional Rift and Necronomicon Fragment upgrades"
                    }
                },

                adventurers: {
                    'Novice Explorer': { // 最初から解放
                        isUnlocked: true
                    },
                    'Seasoned Investigator': {
                        requirement: {
                            adventurers: {
                                'Novice Explorer': { level: 3 }  // Novice Explorerがレベル3必要
                            }
                        },
                        description: "Requires Level 3 Novice Explorer"
                    },
                    'Arcane Scholar': {
                        requirement: {
                            adventurers: {
                                'Seasoned Investigator': { level: 3 }
                            },
                            monsters: { 'Deep One': 2 }
                        },
                        description: "Requires Level 3 Seasoned Investigator and 2 Deep Ones"
                    },
                    'Occult Detective': {
                        requirement: {
                            adventurers: {
                                'Arcane Scholar': { level: 2 }
                            },
                            monsters: { 'Elder Thing': 1 },
                            upgrades: ['Forbidden Ritual']
                        },
                        description: "Requires Level 2 Arcane Scholar, 1 Elder Thing and Forbidden Ritual upgrade"
                    },
                    'Eldritch Archaeologist': {
                        requirement: {
                            adventurers: {
                                'Occult Detective': { level: 2 }
                            },
                            monsters: {
                                'Star Spawn': 1,
                                'Mi-go': 1
                            }
                        },
                        description: "Requires Level 2 Occult Detective, 1 Star Spawn and 1 Mi-go"
                    },
                    'Cosmic Voyager': {
                        requirement: {
                            adventurers: {
                                'Eldritch Archaeologist': { level: 2 }
                            },
                            monsters: {
                                'Nightgaunt': 1
                            },
                            upgrades: ['Cosmic Insight', 'Astral Projection']
                        },
                        description: "Requires Level 2 Eldritch Archaeologist, 1 Nightgaunt, Cosmic Insight and Astral Projection upgrades"
                    }
                },

                upgrades: {
                    'Ritual Knowledge': {
                        isUnlocked: true,
                        requirement: null,
                        description: 'Always available'
                    },

                    'Eldritch Tome': {
                        requirement: {
                            monsters: { 'Shoggoth': 3 }
                        },
                        description: 'Requires 3 Shoggoths'
                    },

                    'Hiroshi Sakamoto`s Paper': {
                        requirement: {
                            monsters: { 'Shoggoth': 10, 'This Man': 5 }
                        },
                        description: 'Requires 10 Shoggoths and 5 This Man'
                    },

                    'Cosmic Alignment': {
                        requirement: {
                            monsters: { 'Shoggoth': 15, 'This Man': 8 }
                        },
                        description: 'Requires 15 Shoggoths and 8 This Man'
                    },

                    'Forbidden Ritual': {
                        requirement: {
                            monsters: { 'Deep One': 3, 'This Man': 10 },
                            upgrades: ['Cosmic Alignment']
                        },
                        description: 'Requires 3 Deep Ones, 10 This Man and Cosmic Alignment upgrade'
                    },

                    'Hermetic Teachings': {
                        requirement: {
                            monsters: { 'Deep One': 6, 'Byakhee': 3 },
                            upgrades: ['Forbidden Ritual']
                        },
                        description: 'Requires 6 Deep Ones, 3 Byakhee and Forbidden Ritual upgrade'
                    },

                    'Cosmic Insight': {
                        requirement: {
                            monsters: { 'Elder Thing': 2, 'Byakhee': 5 },
                            upgrades: ['Hermetic Teachings']
                        },
                        description: 'Requires 2 Elder Things, 5 Byakhee and Hermetic Teachings upgrade'
                    },

                    'Astral Projection': {
                        requirement: {
                            monsters: { 'Elder Thing': 3, 'Mossman': 2 },
                            upgrades: ['Cosmic Insight'],
                        },
                        description: 'Requires 3 Elder Things, 2 Mossman, Cosmic Insight upgrade'
                    },

                    'Dimensional Rift': {
                        requirement: {
                            monsters: { 'Star Spawn': 1, 'Mossman': 4 },
                            upgrades: ['Astral Projection'],
                        },
                        description: 'Requires 1 Star Spawn, 4 Mossman, Astral Projection upgrade'
                    },

                    'Necronomicon Fragment': {
                        requirement: {
                            monsters: { 'Mi-go': 1, 'Star Spawn': 2 },
                            upgrades: ['Dimensional Rift'],
                        },
                        description: 'Requires 1 Mi-go, 2 Star Spawn, Dimensional Rift upgrade'
                    },

                    'Psychic Attunement': {
                        requirement: {
                            monsters: { 'Nightgaunt': 1, 'Mi-go': 2 },
                            upgrades: ['Necronomicon Fragment'],
                        },
                        description: 'Requires 1 Nightgaunt, 2 Mi-go, Necronomicon Fragment upgrade'
                    },

                    'Quantum Entanglement': {
                        requirement: {
                            monsters: { 'Uroboros': 1, 'Nightgaunt': 2 },
                            upgrades: ['Psychic Attunement'],
                        },
                        description: 'Requires 1 Uroboros, 2 Nightgaunts, Psychic Attunement upgrade'
                    },

                    'Temporal Manipulation': {
                        requirement: {
                            monsters: { 'Uroboros': 2 },
                            upgrades: ['Quantum Entanglement'],
                            monsterTypes: 8 // 8種類以上のモンスターを所持
                        },
                        description: 'Requires 2 Uroboros, 8 different monster types and Quantum Entanglement upgrade'
                    },

                    'Eldritch Evolution': {
                        requirement: {
                            monsters: { 'Uroboros': 3 },
                            upgrades: ['Temporal Manipulation'],
                            monsterTypes: 10, // すべての種類のモンスター
                            monsterLevel: 10 // いずれかのモンスターがレベル10以上
                        },
                        description: 'Requires 3 Uroboros, Level 8 Cosmic Voyager, all monster types and any monster at level 10'
                    }
                },
                resources: {
                    'cultos': {
                        requirement: {
                            upgrades: ['Hiroshi Sakamoto`s Paper'],
                            monsters: {
                                'Shoggoth': 10,
                                'This Man': 5
                            }
                        },
                        description: "Requires Hiroshi Sakamoto's Paper upgrade, 10 Shoggoths and 5 This Man"
                    }
                }
            };

            const config = {
                cardPrefix: 'card-',
                conditions: {
                    monsters: unlockConditions.monsters,
                    adventurers: unlockConditions.adventurers,
                    upgrades: unlockConditions.upgrades
                }
            };

            const upgradeDefinitions = {
                'Ritual Knowledge': {
                    cost: 150,
                    type: 'sourceEfficiency',
                    effect: 0.1,
                    description: 'Basic ritual knowledge increases source production'
                },
                'Eldritch Tome': {
                    cost: 500,
                    type: 'miasmaEfficiency',
                    effect: 0.2,
                    description: 'Ancient tome increases miasma production'
                },
                'Hiroshi Sakamoto`s Paper': {
                    cost: 2000,
                    type: 'cultosMining',
                    effect: 1,
                    description: 'A mysterious paper describing the principles of Cultos mining'
                },

                'Cosmic Alignment': {
                    cost: 3000,
                    type: 'cosmicAlignment',
                    effect: 0.5,
                    description: 'Align with cosmic forces for enhanced production'
                },
                'Forbidden Ritual': {
                    cost: 8000,
                    type: 'followerEfficiency',
                    effect: 0.3,
                    description: 'Increase follower efficiency through dark rituals'
                },
                'Hermetic Teachings': {
                    cost: 35000,
                    type: 'monsterEfficiency',
                    effect: 0.25,
                    description: 'Ancient hermetic wisdom enhances monster efficiency'
                },
                'Cosmic Insight': {
                    cost: 80000,
                    type: 'productionMultiplier',
                    effect: 0.4,
                    description: 'Gain deeper understanding of cosmic forces'
                },
                'Astral Projection': {
                    cost: 300000,
                    type: 'astralProjection',
                    effect: 0.01,
                    description: 'Project into astral plane for bonus source'
                },
                'Dimensional Rift': {
                    cost: 500000,
                    type: 'dimensionalRift',
                    effect: 0.75,
                    description: 'Open rifts to other dimensions for massive bonuses'
                },
                'Necronomicon Fragment': {
                    cost: 1200000,
                    type: 'madnessResistance',
                    effect: 0.2,
                    description: 'Reduce madness chance for all entities'
                },
                'Psychic Attunement': {
                    cost: 3000000,
                    type: 'followerGain',
                    effect: 0.3,
                    description: 'Increase follower gain from all sources'
                },
                'Quantum Entanglement': {
                    cost: 6000000,
                    type: 'quantumEntanglement',
                    effect: 0.5,
                    description: 'Link monsters for enhanced efficiency'
                },
                'Temporal Manipulation': {
                    cost: 8000000,
                    type: 'temporalManipulation',
                    effect: 2.0,
                    description: 'Bend time to multiply all production'
                },
                'Eldritch Evolution': {
                    cost: 30000000,
                    type: 'eldritchEvolution',
                    effect: 0.01,
                    description: 'Monsters slowly gain efficiency over time'
                }
            };

            const asciiArt = {
                'Follower': `
<span style="color:#2E1A47">      ▄▄█▀▀█▄▄      </span>
<span style="color:#2E1A47">    ▄█▀</span><span style="color:#3D2A56">░░░░░░</span><span style="color:#2E1A47">▀█▄    </span>
<span style="color:#2E1A47">   █▀░</span><span style="color:#4B0082">▄▄███▄▄</span><span style="color:#2E1A47">░▀█   </span>
<span style="color:#2E1A47">  █░</span><span style="color:#4B0082">█</span><span style="color:#2E1A47">▒</span><span style="color:#1E1E1E">░░░░</span><span style="color:#2E1A47">▒</span><span style="color:#4B0082">█</span><span style="color:#2E1A47">░█  </span>
<span style="color:#2E1A47"> █░</span><span style="color:#4B0082">█▀▄</span><span style="color:#2E1A47">▒</span><span style="color:#1E1E1E">░░░</span><span style="color:#2E1A47">▒</span><span style="color:#4B0082">▄▀█</span><span style="color:#2E1A47">░█ </span>
<span style="color:#2E1A47">█░</span><span style="color:#4B0082">▄█▀░</span><span style="color:#2E1A47">▒</span><span style="color:#1E1E1E">░░░</span><span style="color:#2E1A47">▒</span><span style="color:#4B0082">░▀█▄</span><span style="color:#2E1A47">░█</span>
<span style="color:#2E1A47">█░</span><span style="color:#4B0082">█▄▄██████▄▄█</span><span style="color:#2E1A47">░█</span>
<span style="color:#2E1A47">█░</span><span style="color:#4B0082">███████████</span><span style="color:#2E1A47">░█</span>
<span style="color:#2E1A47">█░</span><span style="color:#6A0DAD">███</span><span style="color:#D2691E">▒▒▒▒▒</span><span style="color:#6A0DAD">███</span><span style="color:#2E1A47">░█</span>
<span style="color:#2E1A47">█░░</span><span style="color:#6A0DAD">██</span><span style="color:#D2691E">▒</span><span style="color:#FF1493">(@)</span><span style="color:#D2691E">▒</span><span style="color:#FF1493">(@)</span><span style="color:#D2691E">▒</span><span style="color:#6A0DAD">██</span><span style="color:#2E1A47">░░█</span>
<span style="color:#2E1A47">█▄░░</span><span style="color:#6A0DAD">█</span><span style="color:#D2691E">▒▒▒▒▒▒▒</span><span style="color:#6A0DAD">█</span><span style="color:#2E1A47">░░▄█</span>
<span style="color:#2E1A47"> █▀▄▄░</span><span style="color:#D2691E">▒▒▒▒▒</span><span style="color:#2E1A47">░▄▄▀█ </span>
<span style="color:#2E1A47"> ▀█░░▀</span><span style="color:#D2691E">▒▒▒▒▒</span><span style="color:#2E1A47">▀░░█▀ </span>
<span style="color:#2E1A47">  ▀█▄░░</span><span style="color:#D2691E">▒▒▒</span><span style="color:#2E1A47">░░▄█▀  </span>
<span style="color:#2E1A47">    ▀▀█▄▄▄█▀▀    </span>
    `,
                'Shoggoth': `
<span style="color:#004000">▄▄▄──────▄▄▄</span>
    <span style="color:#004000">▄██▀░</span><span style="color:#006000">▒▒▒</span><span style="color:#004000">░░░</span><span style="color:#006000">▒▒▒</span><span style="color:#004000">░▀██▄</span>
  <span style="color:#004000">██▀░</span><span style="color:#006000">▒</span><span style="color:#008000">▄▄</span><span style="color:#006000">▒▒▒▒▒▒▒▒</span><span style="color:#008000">▄▄</span><span style="color:#006000">▒</span><span style="color:#004000">░▀██</span>
 <span style="color:#004000">█▀░</span><span style="color:#006000">▒</span><span style="color:#00A000">▄█▀▀█ <span style="color:#FF0000"> + </span>  █▀▀█▄</span><span style="color:#006000">▒</span><span style="color:#004000">░▀█</span>
<span style="color:#004000">█▀░</span><span style="color:#006000">▒</span><span style="color:#00C000">▄█▀</span><span style="color:#FF0000"> + </span><span style="color:#00C000">░░</span><span style="color:#FF0000"> + </span><span style="color:#00C000">▀█▄</span><span style="color:#006000">▒</span><span style="color:#004000">░▀█</span>
<span style="color:#004000">█░</span><span style="color:#006000">▒</span><span style="color:#00E000">█▀</span><span style="color:#FF0000"> + </span><span style="color:#00E000">░░░░░░</span><span style="color:#FF0000"> ÷ </span><span style="color:#00E000">▀█</span><span style="color:#006000">▒</span><span style="color:#004000">░█</span>
<span style="color:#004000">█░</span><span style="color:#006000">▒</span><span style="color:#00FF00">█░▄▀▀</span><span style="color:#FF0000">\\--/</span><span style="color:#00FF00">▀▀▄░░█</span><span style="color:#006000">▒</span><span style="color:#004000">░█</span>
<span style="color:#004000">█░</span><span style="color:#006000">▒</span><span style="color:#00E000">█░█░░</span><span style="color:#FF0000">_\\/_</span><span style="color:#00E000">░░█░█</span><span style="color:#006000">▒</span><span style="color:#004000">░█</span>
<span style="color:#004000">█░</span><span style="color:#006000">▒</span><span style="color:#00C000">▀█▄▀</span><span style="color:#FF0000">/,\\,\\</span><span style="color:#00C000">▀▄█▀</span><span style="color:#006000">▒</span><span style="color:#004000">░█</span>
<span style="color:#004000">█▄░</span><span style="color:#006000">▒▒</span><span style="color:#00A000">▀▄</span><span style="color:#FF0000">'-'</span><span style="color:#00A000">▄▀</span><span style="color:#006000">▒▒</span><span style="color:#004000">░▄█</span>
 <span style="color:#004000">██▄░░</span><span style="color:#006000">▒▒▒▒▒▒</span><span style="color:#004000">░░▄██</span>
  <span style="color:#004000">▀██▄▄░░░░░░▄▄██▀</span>
    <span style="color:#004000">▀▀████████▀▀</span>
  <span style="color:#004000">▄█▀</span><span style="color:#006000">▒</span><span style="color:#00A000">█▒▒▒▒▒▒▒▒█</span><span style="color:#006000">▒</span><span style="color:#004000">▀█▄</span>
 <span style="color:#004000">█▀</span><span style="color:#006000">▒</span><span style="color:#00C000">█▒█▒▒▒▒▒▒█▒█</span><span style="color:#006000">▒</span><span style="color:#004000">▀█</span>
<span style="color:#004000">█</span><span style="color:#00FF00">▄█▒█▒█▒█▒█▒█▒█▒█▄</span><span style="color:#004000">█</span>
<span style="color:#004000">▀█▄</span><span style="color:#00E000">█▒█▒▒█▒█▒▒█▒█</span><span style="color:#004000">▄█▀</span>
    `,

                'This Man': `
<span style="color:#FFFFFF">       ▄███████████████▄       </span>
<span style="color:#FFFFFF">     ▄█▀</span><span style="color:#F0F0F0">░░░░░░░░░░░</span><span style="color:#FFFFFF">▀█▄     </span>
<span style="color:#FFFFFF">   ▄█▀   </span><span style="color:#E0E0E0">▄▄▄▄     ▄▄▄▄</span><span style="color:#FFFFFF">   ▀█▄   </span>
<span style="color:#FFFFFF">  █▀  </span><span style="color:#D0D0D0">▄█▀▀▀▀▀█   █▀▀▀▀▀█▄</span><span style="color:#FFFFFF">  ▀█  </span>
<span style="color:#FFFFFF"> █▀  </span><span style="color:#C0C0C0">█▀       ▀ ▀       ▀█</span><span style="color:#FFFFFF">  ▀█ </span>
<span style="color:#FFFFFF">█▀ </span><span style="color:#B0B0B0">▄▀                     ▀▄</span><span style="color:#FFFFFF"> ▀█</span>
<span style="color:#FFFFFF">█  </span><span style="color:#A0A0A0">  ▐▐▓▓▌▐        ▐▐▓▓▌▐   </span><span style="color:#FFFFFF"> █</span>
<span style="color:#FFFFFF">█  </span><span style="color:#909090">   ▐▓▓▌          ▐▓▓▌    </span><span style="color:#FFFFFF">█</span>
<span style="color:#FFFFFF">█  </span><span style="color:#808080">    ▀▀    ▐▓▓▌    ▀▀     </span><span style="color:#FFFFFF">█</span>
<span style="color:#FFFFFF">█  </span><span style="color:#707070">          ▐  ▌           </span><span style="color:#FFFFFF">█</span>
<span style="color:#FFFFFF">█  </span><span style="color:#606060">                          </span><span style="color:#FFFFFF">█</span>
<span style="color:#FFFFFF">█▄ </span><span style="color:#505050">                        </span><span style="color:#FFFFFF">▄█</span>
<span style="color:#FFFFFF">▀█  </span><span style="color:#404040"> ▐▓▓              ▓▓▌ </span><span style="color:#FFFFFF"> █▀</span>
<span style="color:#FFFFFF"> ▀█  </span><span style="color:#303030">  ▀▓▓▓▀▀▀▀▀▀▀▀▓▓▓▀  </span><span style="color:#FFFFFF"> █▀ </span>
<span style="color:#FFFFFF">  ▀█▄ </span><span style="color:#202020">                  </span><span style="color:#FFFFFF">▄█▀  </span>
<span style="color:#FFFFFF">    ▀█▄ </span><span style="color:#101010">              </span><span style="color:#FFFFFF">▄█▀    </span>
<span style="color:#FFFFFF">      ▀▀██████████████▀▀      </span>
    `,
                'Deep One': `
<span style="color:#005959">        ▄▄▄▄▄▄        </span>
<span style="color:#005959">      ▄█▀▀▀▀▀▀█▄      </span>
<span style="color:#005959">    ▄█▀░░</span><span style="color:#008080">▒▒▒▒</span><span style="color:#005959">░░▀█▄    </span>
<span style="color:#005959">  ▄█▀░</span><span style="color:#008080">▒▒</span><span style="color:#00A0A0">▄▄▄▄▄▄</span><span style="color:#008080">▒▒</span><span style="color:#005959">░▀█▄  </span>
</span><span style="color:#008080">▒</span><span style="color:#00A0A0">▄</span><span style="color:#FF0000">(@@)</span><span style="color:#00A0A0">░░░░░░░░</span><span style="color:#FF0000">(@@)</span><span style="color:#00A0A0">▄</span><span style="color:#008080">▒</span></span>
<span style="color:#005959">█▀░</span><span style="color:#008080">▒</span><span style="color:#00BFBF">█▀░░░░░░░░▀█</span><span style="color:#008080">▒</span><span style="color:#005959">░▀█</span>
<span style="color:#005959">█░</span><span style="color:#008080">▒</span><span style="color:#00DFDF">█░▄▀▀▀▀▀▀▄░█</span><span style="color:#008080">▒</span><span style="color:#005959">░█</span>
<span style="color:#005959">█░</span><span style="color:#008080">▒</span><span style="color:#00FFFF">█░█░</span><span style="color:#40E0D0">_\\/_</span><span style="color:#00FFFF">░█░█</span><span style="color:#008080">▒</span><span style="color:#005959">░█</span>
<span style="color:#005959">█░</span><span style="color:#008080">▒</span><span style="color:#00DFDF">▀█▄▀</span><span style="color:#40E0D0">/,\\,\\</span><span style="color:#00DFDF">▀▄█▀</span><span style="color:#008080">▒</span><span style="color:#005959">░█</span>
<span style="color:#005959">█▄░</span><span style="color:#008080">▒▒</span><span style="color:#00BFBF">▀▄</span><span style="color:#40E0D0">'-'</span><span style="color:#00BFBF">▄▀</span><span style="color:#008080">▒▒</span><span style="color:#005959">░▄█</span>
<span style="color:#005959"> ██▄░░</span><span style="color:#008080">▒▒▒▒▒▒</span><span style="color:#005959">░░▄██ </span>
<span style="color:#005959">  ▀██▄▄░░░░░░▄▄██▀  </span>
<span style="color:#005959">    ▀▀████████▀▀    </span>
<span style="color:#008080">  ▄█▀▀▄</span><span style="color:#00A0A0">▓▓▓▓▓▓▓▓</span><span style="color:#008080">▄▀▀█▄  </span>
<span style="color:#008080"> █▀ </span><span style="color:#00BFBF">▄▓▓▓▀▀▀▀▓▓▓▄</span><span style="color:#008080"> ▀█ </span>
<span style="color:#008080">█  </span><span style="color:#00DFDF">▓▓▓▀▄▄▄▄▀▓▓▓</span><span style="color:#008080">  █</span>
    `,
                'Byakhee': `
<span style="color:#8B4513">               ▄█▀▀░░░░▀▀█▄           </span>
<span style="color:#8B4513">           ▄█▀░▒▒</span><span style="color:#FF0000">◉</span><span style="color:#8B4513">▒▒▄▄░░░░▀█         </span>
<span style="color:#8B4513">         ▄█▀░▒▒▒▄█▀▀█ ▒▒░░▀▄   </span>
<span style="color:#8B4513">       ▄█▀░▒▒▒▄█▀░░░▄ ░░░░░ ▄   </span>
<span style="color:#8B4513">     ▄█▀░▒▒▒▄█▀░░░▒ ▄▀░▄▄░░▀  </span>
<span style="color:#A0522D">   ▄█▀░▄▄▄██▀░░▒▒  ▀▄▀░▀▀░░▀ </span>
<span style="color:#A0522D"> ▄█▀▄█▀▀▀░░░▒▒▒░   ▀▄░░░░░▄▀  </span>
<span style="color:#A0522D">█▀▄█▀░░▒▒▒▒▒▒▒░░░   ▀▄░░▄▀    </span>
<span style="color:#CD853F"> █▀█░▒▒▒▒▒▒░░░       ▀▀      </span>
<span style="color:#CD853F"> ██░▒▒▒▒▒░░░                    </span>
<span style="color:#CD853F"> █▄░▒▒▒▒                     </span>
<span style="color:#CD853F">  █▄░░▒▒▒▄▄░                      </span>
<span style="color:#DEB887">   █▄░░▄█▀▒                       </span>
<span style="color:#DEB887">    █▄█▀░▒                        </span>
<span style="color:#DEB887">     █▄░                         </span>
<span style="color:#DEB887">      ▀█▄▄▄▄█▀                        </span>
    `,
                'Elder Thing': `
<span style="color:#8B4513">     </span><span style="color:#FF4500">(@)</span><span style="color:#A0522D">╚═╗</span><span style="color:#FF4500">(@)</span><span style="color:#A0522D">╔═╝</span><span style="color:#FF4500">(@)</span><span style="color:#8B4513">     </span>
<span style="color:#8B4513">      </span><span style="color:#A0522D">╚  ║  ╝</span><span style="color:#8B4513">      </span>
<span style="color:#8B4513">       </span><span style="color:#A0522D">╚ ║ ╝</span><span style="color:#8B4513">       </span>
<span style="color:#8B4513">    </span><span style="color:#FF4500">(@)</span><span style="color:#CD853F">╗╚ ║ ╝╔</span><span style="color:#FF4500">(@)</span><span style="color:#8B4513">    </span>
<span style="color:#8B4513">      </span><span style="color:#CD853F">╔ ╚╦╝ ╗</span><span style="color:#8B4513">      </span>
<span style="color:#704214">     ▄▄</span><span style="color:#8B4513">█████</span><span style="color:#704214">▄▄     </span>
<span style="color:#704214">    ██</span><span style="color:#8B4513">▒█</span><span style="color:#FF4500">(@)</span><span style="color:#8B4513">█▒</span><span style="color:#704214">██    </span>
<span style="color:#704214">   ██</span><span style="color:#8B4513">▒███████▒</span><span style="color:#704214">██   </span>
<span style="color:#36648B"> ▄█</span><span style="color:#704214">█</span><span style="color:#8B4513">▒███████▒</span><span style="color:#704214">█</span><span style="color:#36648B">█▄ </span>
<span style="color:#36648B">█▀</span><span style="color:#704214">██</span><span style="color:#8B4513">▒█████▒</span><span style="color:#704214">██</span><span style="color:#36648B">▀█</span>
<span style="color:#36648B">▀█▄</span><span style="color:#704214">██</span><span style="color:#8B4513">▒███▒</span><span style="color:#704214">██</span><span style="color:#36648B">▄█▀</span>
<span style="color:#36648B">  ▀█▄██████████▄█▀  </span>
<span style="color:#36648B">    ▀▀█▄▄▄▄▄█▀▀    </span>
<span style="color:#4682B4">  ▄▄██▀     ▀██▄▄  </span>
<span style="color:#4682B4"> ██▀           ▀██ </span>
<span style="color:#4682B4">█▀               ▀█</span>
<span style="color:#4682B4"> ▀██▀ ▀     ▀ ▀██▀ </span>
    `,
                'Star Spawn': `
<span style="color:#2A0A29">    ▄█▀</span><span style="color:#FF1493">◉</span><span style="color:#2A0A29">▀██▀</span><span style="color:#FF1493">◉</span><span style="color:#2A0A29">▀█▄    </span>
<span style="color:#2A0A29">   █▀ </span><span style="color:#4B0082">▄▄██▄▄</span><span style="color:#2A0A29"> ▀█   </span>
<span style="color:#2A0A29">  █▀ </span><span style="color:#4B0082">█</span><span style="color:#FF1493">◉</span><span style="color:#4B0082">█</span><span style="color:#2A0A29">▀▀</span><span style="color:#4B0082">█</span><span style="color:#FF1493">◉</span><span style="color:#4B0082">█</span><span style="color:#2A0A29"> ▀█  </span>
<span style="color:#2A0A29"> █▀ </span><span style="color:#6A0DAD">█▄▀▀▀▀▄█</span><span style="color:#2A0A29"> ▀█ </span>
<span style="color:#2A0A29">█▀ </span><span style="color:#8A2BE2">█▀▄</span><span style="color:#FF1493">◉</span><span style="color:#8A2BE2">▄</span><span style="color:#FF1493">◉</span><span style="color:#8A2BE2">▄▀█</span><span style="color:#2A0A29"> ▀█</span>
<span style="color:#2A0A29">█ </span><span style="color:#9370DB">▄█████████▄</span><span style="color:#2A0A29"> █</span>
<span style="color:#2A0A29">█ </span><span style="color:#BA55D3">███▀▀▀▀▀███</span><span style="color:#2A0A29"> █</span>
<span style="color:#2A0A29">█ </span><span style="color:#DA70D6">██▀  ▄  ▀██</span><span style="color:#2A0A29"> █</span>
<span style="color:#2A0A29">█ </span><span style="color:#EE82EE">██  </span><span style="color:#FF1493"> ◉</span><span style="color:#EE82EE">   ██</span><span style="color:#2A0A29"> █</span>
<span style="color:#2A0A29">█▄ </span><span style="color:#DA70D6">██▄   ▄██</span><span style="color:#2A0A29"> ▄█</span>
<span style="color:#2A0A29">▀█▄ </span><span style="color:#BA55D3">▀██▄▄▄██▀</span><span style="color:#2A0A29"> ▄█▀</span>
<span style="color:#2A0A29"> ▀█▄▄ </span><span style="color:#9370DB">▀▀▀▀▀</span><span style="color:#2A0A29"> ▄▄█▀ </span>
<span style="color:#2A0A29">   ▀▀█▄▄▄▄▄█▀▀   </span>
<span style="color:#4B0082"> ▄▄██▀▀▀▀▀▀▀██▄▄ </span>
<span style="color:#8A2BE2">█ ▄▀       ▀▄ █</span>
<span style="color:#9370DB">▀█▀         ▀█▀</span>
    `,
                'Mossman': `
    <span style="color:#004400">      ▄▄████████▄▄      </span>
<span style="color:#006600">    ▄█▀▀░░░░░░░░▀▀█▄    </span>
<span style="color:#008800">   █▀ ▄</span><span style="color:#FF0000">▓▓</span><span style="color:#008800">▄░░░░▄</span><span style="color:#FF0000">▓▓</span><span style="color:#008800">▄ ▀█   </span>
<span style="color:#00AA00">  █░ █▀▀▀▀░░░░▀▀▀▀█ ░█  </span>
<span style="color:#00CC00">  █░ █░░</span><span style="color:#008800">▄▄██▄▄</span><span style="color:#00CC00">░░█ ░█  </span>
<span style="color:#00EE00"> ▄▀░ █░</span><span style="color:#008800">█▄▄██▄▄█</span><span style="color:#00EE00">░█ ░▀▄ </span>
<span style="color:#00FF00"> █░░ █░█ ░░▀░░ █░█ ░░█ </span>
<span style="color:#22FF22"> █░░ █░███▄░░▄███░█ ░░█ </span>
<span style="color:#44FF44"> █░░ ▀░██▀▀░░▀▀██░▀ ░░█ </span>
<span style="color:#66FF66"> █░░░ ░███▄▄▄▄███░ ░░░█ </span>
<span style="color:#88FF88"> ▀▄░░░░▀▀███████▀▀░░░▄▀ </span>
<span style="color:#AAFFAA">  ▀▄░░░░░░░░░░░░░░░░▄▀  </span>
<span style="color:#CCFFCC">   ▀▄░░░░░░░░░░░░░░▄▀   </span>
<span style="color:#EEFFEE">    ▀█▄░░░░░░░░░░▄█▀    </span>
<span style="color:#FFFFFF">      ▀█▄▄░░░░▄▄█▀      </span>
<span style="color:#EEFFEE">     ▄█▀   ▀▀▀▀    ▀█▄     </span>
<span style="color:#CCFFCC">   █▀   ▄█▀▀▀▀▀▀█▄  ▀█    </span>
    `,
                'Mi-go': `
<span style="color:#8B0000">        ▄▄████▄▄        </span>
<span style="color:#8B0000">      ▄█▀</span><span style="color:#00FF00">◉</span><span style="color:#8B0000">▀▀▀▀▀</span><span style="color:#00FF00">◉</span><span style="color:#8B0000">▀█▄      </span>
<span style="color:#8B0000">    ▄█▀▀█▄▄▄▄▄▄▄█▀▀█▄    </span>
<span style="color:#8B0000">  ▄█▀  ▄████████████▄ ▀█▄  </span>
<span style="color:#8B0000">▄█▀ ▄███▀▀▀▀▀▀▀▀▀███▄ ▀█▄</span>
<span style="color:#A52A2A">█▄▄███▀  </span><span style="color:#228B22">▄▄▄▄▄▄</span><span style="color:#A52A2A">  ▀███▄▄█</span>
<span style="color:#A52A2A">█▀██▀   </span><span style="color:#32CD32">▄▀</span><span style="color:#B22222">█</span><span style="color:#32CD32">░░░▀▄</span><span style="color:#A52A2A">   ▀██▀█</span>
<span style="color:#B22222">█ ▀█   </span><span style="color:#3CB371">█ ▄▄█▄▄ █</span><span style="color:#B22222">   █▀ █</span>
<span style="color:#CD5C5C">█  ▀   </span><span style="color:#66CDAA">▀▄▀██▀▄▀</span><span style="color:#CD5C5C">   ▀  █</span>
<span style="color:#FF6347">█▄   ▄▄▄▀▀▄▄▄▄▀▀▄▄▄   ▄█</span>
<span style="color:#FF6347">▀█▄▄█▀▀█▄▄  ▄▄█▀▀█▄▄█▀</span>
<span style="color:#FF7F50"> ▀█▄  ▀▀▀▀▀▀▀▀▀▀  ▄█▀ </span>
<span style="color:#FF7F50">   ▀█▄▄ ▀▀▀▀▀▀ ▄▄█▀   </span>
<span style="color:#FFA07A">     ▀█ █ ▄▄ █ █▀     </span>
<span style="color:#FFB6C1">      ▀▄▀    ▀▄▀      </span>
<span style="color:#FFC0CB">       ▀      ▀       </span>
    `,
                'Nightgaunt': `
<span style="color:#000080">  ▄▄</span><span style="color:#0000CD">▀▀</span><span style="color:#000080">▄▄    ▄▄</span><span style="color:#0000CD">▀▀</span><span style="color:#000080">▄▄  </span>
<span style="color:#000080"> ▄</span><span style="color:#0000CD">▀</span><span style="color:#000080">█ </span><span style="color:#0000CD">▄▄▄▄</span><span style="color:#000080"> █</span><span style="color:#0000CD">▀</span><span style="color:#000080">▄ </span>
<span style="color:#000080">█▀ </span><span style="color:#0000CD">█▀▀▀▀▀▀█</span><span style="color:#000080"> ▀█</span>
<span style="color:#000080">█  </span><span style="color:#4169E1">█ ▄▄▄▄ █</span><span style="color:#000080">  █</span>
<span style="color:#000080">█ </span><span style="color:#4169E1">█▀▄▀▀▀▄▀█</span><span style="color:#000080"> █</span>
<span style="color:#000080">█ </span><span style="color:#6495ED">█ ▀▄▄▄▀ █</span><span style="color:#000080"> █</span>
<span style="color:#000080">█ </span><span style="color:#6495ED">▀█▄▄▄▄▄█▀</span><span style="color:#000080"> █</span>
<span style="color:#000080">█ </span><span style="color:#87CEFA">███▀▀▀███</span><span style="color:#000080"> █</span>
<span style="color:#000080">█ </span><span style="color:#87CEFA">██▀   ▀██</span><span style="color:#000080"> █</span>
<span style="color:#000080">█ </span><span style="color:#ADD8E6">██  ▄  ██</span><span style="color:#000080"> █</span>
<span style="color:#000080">▀█▄ </span><span style="color:#E6E6FA">▀█▄▄▄█▀</span><span style="color:#000080"> ▄█▀</span>
<span style="color:#000080"> ▀█▄▄ </span><span style="color:#E6E6FA">▀▀▀</span><span style="color:#000080"> ▄▄█▀ </span>
<span style="color:#000080">   ▀█▄▄   ▄▄█▀   </span>
<span style="color:#191970">     ▀█   █▀     </span>
<span style="color:#191970">      █▄ ▄█      </span>
<span style="color:#191970">       ▀▀▀       </span>
<span style="color:#191970">       ▀▀▀       </span>
    `,
                'Uroboros': `
<span style="color:#004000">     ▄▄█▀</span><span style="color:#008000">▀▀▀▀▀</span><span style="color:#004000">▀▀█▄▄     </span>
<span style="color:#004000">   ▄█▀</span><span style="color:#008000">░░░░░░░░░░░░░░░░</span><span style="color:#004000">▀█▄   </span>
<span style="color:#004000"> ▄█</span><span style="color:#008000">░░░░░░░▄▄▄▄▄▄▄▄▄▄░░░░░░░░</span><span style="color:#004000">█▄ </span>
<span style="color:#004000">█▀</span><span style="color:#008000">░░░░▄▄█▀▀</span><span style="color:#00FF00">░░░░░░░░░</span><span style="color:#008000">▀▀█▄▄░░░░</span><span style="color:#004000">▀█</span>
<span style="color:#004000">█</span><span style="color:#008000">░░▄█▀░</span><span style="color:#00FF00">░░░░░░░░░░░░░░░░░</span><span style="color:#008000">▀█▄░░</span><span style="color:#004000">█</span>
<span style="color:#004000">█</span><span style="color:#008000">░█▀</span><span style="color:#00FF00">░░░░░░░░</span><span style="color:#FFD700">▄▄▄▄▄▄▄</span><span style="color:#00FF00">░░░░░░░░</span><span style="color:#008000">▀█░</span><span style="color:#004000">█</span>
<span style="color:#004000">█</span><span style="color:#008000">█░</span><span style="color:#00FF00">░░░░░░░</span><span style="color:#FFD700">▄█████████▄</span><span style="color:#00FF00">░░░░░░░</span><span style="color:#008000">░█</span><span style="color:#004000">█</span>
<span style="color:#004000">█</span><span style="color:#00FF00">░░░░░░░░</span><span style="color:#FFD700">██▀░</span><span style="color:#FFD700">　░▀██</span><span style="color:#00FF00">░░░░░░░░</span><span style="color:#004000">█</span>
<span style="color:#004000">█</span><span style="color:#00FF00">░░░░░░░░</span><span style="color:#FFD700">██░░░░　　　░░░░██</span><span style="color:#00FF00">░░░░░░░░</span><span style="color:#004000">█</span>
<span style="color:#004000">█</span><span style="color:#00FF00">░░░░░░░░░</span><span style="color:#FFD700">██▄░░░　░░░▄██</span><span style="color:#00FF00">░░░░░░░░░</span><span style="color:#004000">█</span>
<span style="color:#004000">█</span><span style="color:#008000">█</span><span style="color:#00FF00">░░░░░░░░</span><span style="color:#FFD700">▀███████▀</span><span style="color:#00FF00">░░░░░░░░</span><span style="color:#008000">█</span><span style="color:#004000">█</span>
<span style="color:#004000">█</span><span style="color:#008000">░█▄</span><span style="color:#00FF00">░░░░░░░░░░░░░░░░░░░░░░</span><span style="color:#008000">▄█░</span><span style="color:#004000">█</span>
<span style="color:#004000">█</span><span style="color:#008000">░░░▀█▄░░░░░░░░░░░░░░░░░░░▄█▀░░</span><span style="color:#004000">█</span>
<span style="color:#004000">▄</span><span style="color:#008000">░░░░░▀▀█▄▄░░░░░░░░░░▄▄█▀▀░░░░</span><span style="color:#004000">▄█</span>
<span style="color:#004000"> ▀█▄</span><span style="color:#008000">░░░░░░░░▀▀▀██████▀▀▀░░░░░░░</span><span style="color:#004000">▄█▀ </span>
<span style="color:#004000">   ▀█▄▄</span><span style="color:#008000">░░░░░░░░░░░░░░░</span><span style="color:#004000">▄▄█▀   </span>
<span style="color:#004000">     ▀▀█▄▄▄▄▄▄▄▄▄▄▄█▀▀     </span>
    `,

                'Novice Explorer': `


<span style="color:#8B4513">     ▄████████▄     </span>
<span style="color:#8B4513">   ▄█▀</span><span style="color:#A0522D">░░░░░░░░</span><span style="color:#8B4513">▀█▄   </span>
<span style="color:#8B4513">  █▀</span><span style="color:#CD853F">░░</span><span style="color:#FFD700">▄▄▄▄▄▄▄▄</span><span style="color:#CD853F">░░</span><span style="color:#8B4513">▀█  </span>
<span style="color:#8B4513"> █</span><span style="color:#CD853F">░░</span><span style="color:#FFD700">▄█</span><span style="color:#000000">●</span><span style="color:#FFD700">█░░█</span><span style="color:#000000">●</span><span style="color:#FFD700">█▄</span><span style="color:#CD853F">░░</span><span style="color:#8B4513">█ </span>
<span style="color:#8B4513"> █</span><span style="color:#CD853F">░</span><span style="color:#FFD700">█░</span><span style="color:#DEB887">░░░░░░░░</span><span style="color:#FFD700">░█</span><span style="color:#CD853F">░</span><span style="color:#8B4513">█ </span>
<span style="color:#8B4513"> █</span><span style="color:#CD853F">░</span><span style="color:#FFD700">█░░░</span><span style="color:#B8860B">\___/</span><span style="color:#FFD700">░░░█</span><span style="color:#CD853F">░</span><span style="color:#8B4513">█ </span>
<span style="color:#8B4513"> █</span><span style="color:#CD853F">░░</span><span style="color:#FFD700">▀█░░░░░░░█▀</span><span style="color:#CD853F">░░</span><span style="color:#8B4513">█ </span>
<span style="color:#8B4513"> █▄░░</span><span style="color:#FFD700">▀▀█▄▄▄█▀▀</span><span style="color:#CD853F">░░▄█ </span>
<span style="color:#8B4513">  ▀█▄░░</span><span style="color:#DAA520">▀▀▀▀▀</span><span style="color:#CD853F">░░▄█▀  </span>
<span style="color:#8B4513">    ▀█▄▄░░░░░▄▄█▀    </span>


    `,
                'Seasoned Investigator': `
<span style="color:#8B4513">     ▄▄▄▄▄▄▄▄     </span>
<span style="color:#8B4513">   ▄█▀</span><span style="color:#A0522D">░░░░░░</span><span style="color:#8B4513">▀█▄   </span>
<span style="color:#8B4513">  █▀ </span><span style="color:#B8860B">▄▄▄▄▄▄▄▄</span><span style="color:#8B4513"> ▀█  </span>
<span style="color:#8B4513"> █▀ </span><span style="color:#B8860B">█</span><span style="color:#000000">●</span><span style="color:#B8860B">▀▀▀▀</span><span style="color:#000000">●</span><span style="color:#B8860B">█</span><span style="color:#8B4513"> ▀█ </span>
<span style="color:#8B4513">█▀ </span><span style="color:#B8860B">█  ▄██▄  █</span><span style="color:#8B4513"> ▀█</span>
<span style="color:#8B4513">█ </span><span style="color:#B8860B">▄█████████▄</span><span style="color:#8B4513"> █</span>
<span style="color:#8B4513">█ </span><span style="color:#DAA520">███▀▀▀▀▀███</span><span style="color:#8B4513"> █</span>
<span style="color:#8B4513">█ </span><span style="color:#DAA520">██▀ </span><span style="color:#CD853F">╱╲</span><span style="color:#DAA520"> ▀██</span><span style="color:#8B4513"> █</span>
<span style="color:#8B4513">█ </span><span style="color:#DAA520">██  </span><span style="color:#CD853F">││</span><span style="color:#DAA520">  ██</span><span style="color:#8B4513"> █</span>
<span style="color:#8B4513">█▄ </span><span style="color:#DAA520">██▄ </span><span style="color:#CD853F">╲╱</span><span style="color:#DAA520"> ▄██</span><span style="color:#8B4513"> ▄█</span>
<span style="color:#8B4513">▀█▄ </span><span style="color:#B8860B">▀██▄▄▄██▀</span><span style="color:#8B4513"> ▄█▀</span>
<span style="color:#8B4513"> ▀█▄▄ </span><span style="color:#B8860B">▀▀▀▀▀</span><span style="color:#8B4513"> ▄▄█▀ </span>
<span style="color:#8B4513">   ▀▀█████████▀▀   </span>

    `,
                'Arcane Scholar': `
<span style="color:#4B0082">      ▄▄▄▄▄▄      </span>
<span style="color:#4B0082">    ▄█▀</span><span style="color:#6A5ACD">░░░░</span><span style="color:#4B0082">▀█▄    </span>
<span style="color:#4B0082">   █▀</span><span style="color:#8A2BE2">▄</span><span style="color:#000000">◙</span><span style="color:#8A2BE2">▀▀▀▀</span><span style="color:#000000">◙</span><span style="color:#8A2BE2">▄</span><span style="color:#4B0082">▀█   </span>
<span style="color:#4B0082">  █▀</span><span style="color:#8A2BE2">█ ▄▄▄▄▄▄ █</span><span style="color:#4B0082">▀█  </span>
<span style="color:#4B0082"> █▀</span><span style="color:#8A2BE2">▄█▀▀▀▀▀▀▀█▄</span><span style="color:#4B0082">▀█ </span>
<span style="color:#4B0082">█▀</span><span style="color:#8A2BE2">█▀  ▄▄▄▄  ▀█</span><span style="color:#4B0082">▀█</span>
<span style="color:#4B0082">█</span><span style="color:#8A2BE2">█   █▄▄█   █</span><span style="color:#4B0082">█</span>
<span style="color:#4B0082">█</span><span style="color:#9370DB">█▄  ▀▀▀▀  ▄█</span><span style="color:#4B0082">█</span>
<span style="color:#4B0082">█</span><span style="color:#9370DB">██▄  ▀▀  ▄██</span><span style="color:#4B0082">█</span>
<span style="color:#4B0082">█</span><span style="color:#9370DB">███▄    ▄███</span><span style="color:#4B0082">█</span>
<span style="color:#4B0082">█▄</span><span style="color:#9370DB">████████████</span><span style="color:#4B0082">▄█</span>
<span style="color:#4B0082">▀█▄</span><span style="color:#9370DB">██████████</span><span style="color:#4B0082">▄█▀</span>
<span style="color:#4B0082"> ▀██▄▄▄▄▄▄▄▄▄██▀ </span>
<span style="color:#4B0082">   ▀▀█████████▀▀   </span>
    `,
                'Occult Detective': `
<span style="color:#2F4F4F">     ▄▄▄▄▄▄▄▄     </span>
<span style="color:#2F4F4F">   ▄█▀</span><span style="color:#708090">░░░░░░</span><span style="color:#2F4F4F">▀█▄   </span>
<span style="color:#2F4F4F">  █▀ </span><span style="color:#778899">▄▄▄▄▄▄▄▄</span><span style="color:#2F4F4F"> ▀█  </span>
<span style="color:#2F4F4F"> █▀ </span><span style="color:#778899">█</span><span style="color:#A9A9A9">▒▒▒▒▒▒</span><span style="color:#778899">█</span><span style="color:#2F4F4F"> ▀█ </span>
<span style="color:#2F4F4F">█▀ </span><span style="color:#778899">█</span><span style="color:#A9A9A9">▒</span><span style="color:#000000">○   ○</span><span style="color:#A9A9A9">▒</span><span style="color:#778899">█</span><span style="color:#2F4F4F"> ▀█</span>
<span style="color:#2F4F4F">█ </span><span style="color:#778899">▄█</span><span style="color:#A9A9A9">▒</span><span style="color:#000000">  ‿</span><span style="color:#A9A9A9">▒▒</span><span style="color:#778899">█▄</span><span style="color:#2F4F4F"> █</span>
<span style="color:#2F4F4F">█ </span><span style="color:#4B0082">███▀▀▀▀▀███</span><span style="color:#2F4F4F"> █</span>
<span style="color:#2F4F4F">█ </span><span style="color:#4B0082">██▀ </span><span style="color:#6A5ACD">▄▄</span><span style="color:#4B0082"> ▀██</span><span style="color:#2F4F4F"> █</span>
<span style="color:#2F4F4F">█ </span><span style="color:#4B0082">██  </span><span style="color:#6A5ACD">▀▀</span><span style="color:#4B0082">  ██</span><span style="color:#2F4F4F"> █</span>
<span style="color:#2F4F4F">█ </span><span style="color:#4B0082">██▄ </span><span style="color:#6A5ACD">╱╲</span><span style="color:#4B0082"> ▄██</span><span style="color:#2F4F4F"> █</span>
<span style="color:#2F4F4F">█▄</span><span style="color:#4B0082">███████████</span><span style="color:#2F4F4F">▄█</span>
<span style="color:#2F4F4F">▀█▄</span><span style="color:#4B0082">█████████</span><span style="color:#2F4F4F">▄█▀</span>
<span style="color:#2F4F4F"> ▀██▄▄▄▄▄▄▄▄▄██▀ </span>
<span style="color:#2F4F4F">   ▀▀█████████▀▀   </span>
    `,
                'Eldritch Archaeologist': `
<span style="color:#556B2F">      ▄▄▄▄▄▄      </span>
<span style="color:#556B2F">    ▄█▀</span><span style="color:#6B8E23">░░░░</span><span style="color:#556B2F">▀█▄    </span>
<span style="color:#556B2F">   █▀</span><span style="color:#9ACD32">▄</span><span style="color:#000000">◙</span><span style="color:#9ACD32">▀▀▀▀</span><span style="color:#000000">◙</span><span style="color:#9ACD32">▄</span><span style="color:#556B2F">▀█   </span>
<span style="color:#556B2F">  █▀</span><span style="color:#9ACD32">█ ▄▄▄▄▄▄ █</span><span style="color:#556B2F">▀█  </span>
<span style="color:#556B2F"> █▀</span><span style="color:#9ACD32">▄█▀▀▀▀▀▀▀█▄</span><span style="color:#556B2F">▀█ </span>
<span style="color:#556B2F">█▀</span><span style="color:#9ACD32">█▀  </span><span style="color:#000000">◉   ◉</span><span style="color:#9ACD32">  ▀█</span><span style="color:#556B2F">▀█</span>
<span style="color:#556B2F">█</span><span style="color:#9ACD32">█    </span><span style="color:#000000">  ◡</span><span style="color:#9ACD32">    █</span><span style="color:#556B2F">█</span>
<span style="color:#556B2F">█</span><span style="color:#8FBC8F">█▄  ▀▀▀▀  ▄█</span><span style="color:#556B2F">█</span>
<span style="color:#556B2F">█</span><span style="color:#8FBC8F">██▄  ▀▀  ▄██</span><span style="color:#556B2F">█</span>
<span style="color:#556B2F">█</span><span style="color:#8FBC8F">███▄    ▄███</span><span style="color:#556B2F">█</span>
<span style="color:#556B2F">█▄</span><span style="color:#8FBC8F">████████████</span><span style="color:#556B2F">▄█</span>
<span style="color:#556B2F">▀█▄</span><span style="color:#8FBC8F">██████████</span><span style="color:#556B2F">▄█▀</span>
<span style="color:#556B2F"> ▀██▄▄▄▄▄▄▄▄▄██▀ </span>
<span style="color:#556B2F">   ▀▀█████████▀▀   </span>
    `,
                'Cosmic Voyager': `
<span style="color:#191970">      ▄▄█▀▀█▄▄      </span>
<span style="color:#191970">    ▄█▀</span><span style="color:#000080">░░░░░░</span><span style="color:#191970">▀█▄    </span>
<span style="color:#191970">   █▀░</span><span style="color:#4169E1">▄▄███▄▄</span><span style="color:#191970">░▀█   </span>
<span style="color:#191970">  █░</span><span style="color:#4169E1">█</span><span style="color:#191970">▒</span><span style="color:#FF4500">(@)</span><span style="color:#191970">▒</span><span style="color:#4169E1">█</span><span style="color:#191970">▒</span><span style="color:#FF4500">(@)</span><span style="color:#191970">▒</span><span style="color:#4169E1">█</span><span style="color:#191970">░█  </span>
<span style="color:#191970"> █░</span><span style="color:#4169E1">█▀▄</span><span style="color:#191970">▒▒▒</span><span style="color:#4169E1">▄▀█</span><span style="color:#191970">░█ </span>
<span style="color:#191970">█░</span><span style="color:#4169E1">▄█▀░</span><span style="color:#191970">▒▒▒</span><span style="color:#4169E1">░▀█▄</span><span style="color:#191970">░█</span>
<span style="color:#191970">█░</span><span style="color:#6495ED">█▄▄██████▄▄█</span><span style="color:#191970">░█</span>
<span style="color:#191970">█░</span><span style="color:#6495ED">███████████</span><span style="color:#191970">░█</span>
<span style="color:#191970">█░░</span><span style="color:#6495ED">█████████</span><span style="color:#191970">░░█</span>
<span style="color:#191970">█▄░░</span><span style="color:#6495ED">███████</span><span style="color:#191970">░░▄█</span>
<span style="color:#191970"> █▀▄▄░░░░░░░▄▄▀█ </span>
<span style="color:#191970"> ▀█░░▀▀▀▀▀▀░░█▀ </span>
<span style="color:#191970">  ▀█▄░░░░░░▄█▀  </span>
<span style="color:#191970">    ▀▀█▄▄▄█▀▀    </span>
    `
            };

            const dialogues = {
                adventurers: {
                    'Novice Explorer': {
                        normal: [
                            "What's this feeling...?",
                            "I must go deeper...",
                            "I need to know the truth...",
                            "No regrets choosing this path...",
                            "These ruins feel ancient...",
                            "Something calls to me...",
                            "Just a little further...",
                            "What secrets lie ahead?",
                            "The darkness feels... different here",
                            "My torch won't last forever..."
                        ],
                        mad: [
                            "The walls... they're breathing!",
                            "Can't sleep... they're watching...",
                            "The symbols... they speak to me...",
                            "Must... keep... exploring...",
                            "The shadows are dancing!",
                            "I hear whispers in the dark!",
                            "The path changes behind me!",
                            "My reflection... it blinked!",
                            "The air tastes like colors!",
                            "They're under my skin!"
                        ],
                        resist: [
                            "I... I won't give in!",
                            "My mind is my own!",
                            "Stay focused... stay sane...",
                            "The darkness won't take me!",
                            "I must... resist..."
                        ]
                    },
                    'Seasoned Investigator': {
                        normal: [
                            "These patterns seem familiar...",
                            "There must be a logical explanation...",
                            "I've seen this before somewhere...",
                            "The evidence is adding up...",
                            "Following the trail of clues...",
                            "This case is unlike any other...",
                            "The details matter...",
                            "Need to document everything...",
                            "Strange markings here...",
                            "Time to analyze the findings..."
                        ],
                        mad: [
                            "The angles... they're all wrong!",
                            "They're in my dreams now...",
                            "The truth... it burns!",
                            "Everything is connected!",
                            "The evidence defies physics!",
                            "My notes are writing themselves!",
                            "Time flows backwards here!",
                            "The case files are alive!",
                            "Reality is unraveling!",
                            "The truth was a lie all along!"
                        ],
                        resist: [
                            "Logic prevails!",
                            "Years of training pay off...",
                            "Mind over madness!",
                            "Experience guides me through...",
                            "Not today, cosmic horror..."
                        ]
                    },
                    'Arcane Scholar': {
                        normal: [
                            "These texts are fascinating...",
                            "Such ancient knowledge...",
                            "The symbols hold the key...",
                            "I'm close to a breakthrough...",
                            "This translation is challenging...",
                            "The manuscripts reveal more...",
                            "These runes are unique...",
                            "The patterns are complex...",
                            "Such forbidden knowledge...",
                            "The research continues..."
                        ],
                        mad: [
                            "The words... they move on their own!",
                            "The ancient ones speak through me!",
                            "Knowledge... too much knowledge!",
                            "I understand everything now!",
                            "The books are bleeding!",
                            "The letters crawl like insects!",
                            "The pages whisper secrets!",
                            "Reality is but a dream!",
                            "Time is an illusion!",
                            "The truth drives me mad!"
                        ],
                        resist: [
                            "Knowledge is my shield!",
                            "The wards hold strong!",
                            "My studies protect me!",
                            "Understanding brings clarity!",
                            "The sigils defend my mind!"
                        ]
                    },
                    'Occult Detective': {
                        normal: [
                            "Following the trail...",
                            "Something's not right here...",
                            "The pieces don't fit...",
                            "Getting closer to the truth...",
                            "These symbols are recurring...",
                            "The witnesses are hiding something...",
                            "This evidence is unusual...",
                            "The pattern is emerging...",
                            "Need more information...",
                            "The case grows stranger..."
                        ],
                        mad: [
                            "They're always watching!",
                            "The case... it's alive!",
                            "Can't trust my own shadow...",
                            "The evidence is impossible!",
                            "The walls have eyes!",
                            "My badge is melting!",
                            "The city is breathing!",
                            "Time is flowing backwards!",
                            "The streets are changing!",
                            "Reality is breaking down!"
                        ],
                        resist: [
                            "Not my first paranormal rodeo!",
                            "My mind stays sharp!",
                            "Can't cloud these eyes!",
                            "The truth shields me!",
                            "Seen worse in my line of work..."
                        ]
                    },
                    'Eldritch Archaeologist': {
                        normal: [
                            "These artifacts are unique...",
                            "Such strange architecture...",
                            "This predates known history...",
                            "Remarkable preservation...",
                            "The dating makes no sense...",
                            "These carvings are elaborate...",
                            "The site feels alive...",
                            "Such precise stonework...",
                            "The excavation continues...",
                            "These findings are unprecedented..."
                        ],
                        mad: [
                            "The ruins... they're changing!",
                            "Time is an illusion here!",
                            "The past is alive!",
                            "History was a lie!",
                            "The stones are pulsing!",
                            "The artifacts speak to me!",
                            "The dig site is moving!",
                            "The timeline is wrong!",
                            "The walls are breathing!",
                            "Ancient eyes are watching!"
                        ],
                        resist: [
                            "Ancient wisdom protects me!",
                            "These ruins won't break me!",
                            "History stands with me!",
                            "My research shields my mind!",
                            "The past strengthens my resolve!"
                        ]
                    },
                    'Cosmic Voyager': {
                        normal: [
                            "The stars align...",
                            "Space holds many secrets...",
                            "Beyond our dimension...",
                            "The void calls...",
                            "The cosmos beckons...",
                            "Such vast emptiness...",
                            "The patterns in space...",
                            "Strange constellations...",
                            "The universe whispers...",
                            "Time bends here..."
                        ],
                        mad: [
                            "The stars... they sing to me!",
                            "Space is alive!",
                            "Reality is breaking apart!",
                            "I see beyond the veil!",
                            "The void speaks my name!",
                            "The cosmos dances!",
                            "Dimensions are merging!",
                            "The stars are eyes!",
                            "Space-time is folding!",
                            "The universe screams!"
                        ],
                        resist: [
                            "The void cannot claim me!",
                            "My mind spans dimensions!",
                            "Reality bends, but I stand firm!",
                            "The stars align in my favor!",
                            "Cosmic forces flow through me!"
                        ]
                    }
                }
            };

            function formatNumber(num, decimalPlaces = 1) {
                if (!isFinite(num)) {
                    return "∞";
                }
                if (typeof num !== 'number' || isNaN(num)) {
                    console.warn(`Invalid number passed to formatNumber: ${num}`);
                    return '0';
                }

                if (num === 0) return '0';

                const absNum = Math.abs(num);

                // 1未満の数値の処理
                if (absNum < 1) {
                    // 非常に小さな数値の場合（0.0001未満）は科学的記法を使用
                    if (absNum < 0.0001) {
                        const exponent = Math.floor(Math.log10(absNum));
                        const mantissa = absNum / Math.pow(10, exponent);
                        return `${mantissa.toFixed(2)}e${exponent}`;
                    }
                    // それ以外の1未満の数値は、指定された小数点以下の桁数で表示
                    return absNum.toFixed(Math.max(decimalPlaces, 4));
                }

                // 1以上1000未満の数値
                if (absNum < 1e3) {
                    return num.toFixed(decimalPlaces);
                }

                // 大きな数値の処理（既存のコード）
                const abbreviations = ['', 'K', 'M', 'B', 'T'];
                const maxAbbreviationIndex = abbreviations.length - 1;

                let tier = Math.floor(Math.log10(absNum) / 3);
                if (tier > maxAbbreviationIndex) {
                    const exponent = Math.floor(Math.log10(absNum));
                    const mantissa = absNum / Math.pow(10, exponent);
                    return `${mantissa.toFixed(2)}e${exponent}`;
                } else {
                    const scaled = num / Math.pow(10, tier * 3);
                    const formatted = scaled.toFixed(decimalPlaces);
                    return `${formatted}${abbreviations[tier]}`;
                }
            }

            function safeFormatNumber(value, decimalPlaces = 1) {
                if (typeof value !== 'number' || !isFinite(value)) {
                    console.warn(`Invalid value encountered: ${value}`);
                    return '0';
                }
                return formatNumber(value, decimalPlaces);
            }

            function formatBigNumber(num) {
                if (typeof num === 'bigint') {
                    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
                }
                return formatNumber(num);
            }

            function sanitizeGameState() {
                const numericProps = ['source', 'miasma', 'followers', 'followerAccumulator', 'followerEfficiency'];

                numericProps.forEach(prop => {
                    // 未定義または無効な値の場合は0に初期化
                    if (!isFinite(gameState[prop]) || isNaN(gameState[prop])) {
                        gameState[prop] = 0;
                    }

                    // 負の値を防止
                    if (gameState[prop] < 0) {
                        gameState[prop] = 0;
                    }

                    // 極端に大きな値を防止
                    if (gameState[prop] > Number.MAX_SAFE_INTEGER) {
                        gameState[prop] = Number.MAX_SAFE_INTEGER;
                    }
                });
            }

            // calculateResourceProduction関数の戻り値の検証を追加
            const originalCalculateResourceProduction = calculateResourceProduction;
            calculateResourceProduction = function () {
                const result = originalCalculateResourceProduction();

                // 結果の検証
                const validated = {
                    sourceProduction: Number(result.sourceProduction) || 0,
                    miasmaProduction: Number(result.miasmaProduction) || 0,
                    followerProduction: Number(result.followerProduction) || 0
                };

                // 極端な値の防止
                Object.keys(validated).forEach(key => {
                    if (!isFinite(validated[key]) || validated[key] < 0) {
                        validated[key] = 0;
                    }
                    if (validated[key] > Number.MAX_SAFE_INTEGER) {
                        validated[key] = Number.MAX_SAFE_INTEGER;
                    }
                });

                return validated;
            };

            // 最初にUPDATE_INTERVALSとlastUpdateTimesを定義
            const UPDATE_INTERVALS = {
                monsterGrid: 100,
                followerSection: 100,
                madnessTable: 100,
                upgradeGrid: 100,
                gameDetails: 100
            };

            let lastUpdateTimes = {
                monsterGrid: 0,
                followerSection: 0,
                madnessTable: 0,
                upgradeGrid: 0,
                gameDetails: 0
            };

            // グローバル変数の追加
            let currentTooltip = null;
            let currentAsciiArt = null;
            let tooltipVisible = false;

            // フォロワーセクションの更新関数も修正
            function updateFollowerSection() {
                const followerSection = document.getElementById('followerSection');
                if (!followerSection) return;

                const production = calculateResourceProduction();
                const cultosBonus = calculateCultosBonus();
                const baseFollowerProduction = production.followerProduction; // Cultosボーナス適用前
                const finalFollowerProduction = production.followerProduction / cultosBonus; // 全ボーナス適用後

                const tooltipText = 'Basic Followers:\n• Generate 0.1 source per second\n• Can be recruited using source\n• Production increases with upgrades' +
                    (cultosBonus > 1 ? `\n• Current Cultos bonus: +${((cultosBonus - 1) * 100).toFixed(1)}%` : '');

                const tooltipContent = `
        <div class="follower-tooltip">
            <h3>Basic Followers</h3>
            <ul>
                <li>Generate 0.1 source per second</li>
                <li>Can be recruited using source</li>
                <li>Production increases with upgrades</li>
                ${cultosBonus > 1 ? `<li>Current Cultos bonus: +${((cultosBonus - 1) * 100).toFixed(1)}%</li>` : ''}
            </ul>
        </div>
    `;

                followerSection.innerHTML = `
        <h2>Followers</h2>
        <div class="follower-container" style="position: relative;">
            <div id="followerAsciiArt" class="ascii-art follower-ascii-art tooltip-trigger" 
                style="cursor: pointer; user-select: none;">
                ${asciiArt['Follower']}
                ${tooltipContent}
            </div>
        </div>
        <div class="follower-stats">
            <p>Count: <span id="followerCount">${formatNumber(gameState.followers, 0)}</span></p>
            <p>Efficiency: <span id="followerEfficiency">${formatNumber(gameState.followerEfficiency * cultosBonus, 2)}</span></p>
            <p>Source Production: <span id="followerPerSecond">${formatNumber(production.sourceProduction, 1)}</span>/sec</p>
            <p>Next Recruit Cost: <span id="nextFollowerCost">${formatNumber(getCost('follower'), 0)}</span> source</p>
        </div>
    `;

                // スタイルの追加
                const style = document.createElement('style');
                style.textContent = `
        .follower-tooltip {
            display: none;
            position: absolute;
            color: #fff;
            padding: 8px;
            z-index: 10000;
            top: 5%;
            left: 50%;
            font-size: 10px;
            transform: translateX(-50%);
            width: max-content;
            font-family: 'Roboto', sans-serif;
        }   

        .follower-tooltip h3 {
            margin: 0 0 8px 0;
            color: #4CAF50;
        }

        .follower-tooltip ul {
            margin: 0;
            padding-left: 20px;
        }

        .follower-tooltip li {
            margin: 4px 0;
        }

            .cultos-bonus {
                margin-top: 10px;
                padding: 8px;
                background: rgba(66, 135, 245, 0.1);
                border-left: 3px solid #4287f5;
                border-radius: 4px;
            }
            .bonus-details {
                font-size: 0.9em;
                color: #888;
                margin-left: 10px;
                margin-top: 5px;
            }
            .production-details,.efficiency-details {
                margin-top: 15px;
                padding: 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 4px;
            }
        `;
                document.head.appendChild(style);

                // イベントリスナーの追加
                const followerArt = document.getElementById('followerAsciiArt');
                if (followerArt) {
                    followerArt.addEventListener('mouseenter', () => {
                        const tooltip = followerArt.querySelector('.follower-tooltip');
                        if (tooltip) {
                            tooltip.style.display = 'block';
                        }
                    });

                    followerArt.addEventListener('mouseleave', () => {
                        const tooltip = followerArt.querySelector('.follower-tooltip');
                        if (tooltip) {
                            tooltip.style.display = 'none';
                        }
                    });
                }
            }

            // ツールチップの表示/非表示を切り替える関数
            function toggleFollowerTooltip(event) {
                const tooltip = event.currentTarget.querySelector('.follower-tooltip');
                if (tooltip) {
                    console.log('Toggling tooltip');
                    tooltip.classList.toggle('active');
                } else {
                    console.warn('Tooltip element not found');
                }
            }

            function updateButtonStates() {
                // モンスターカードのボタン状態を更新
                const monsterCards = document.querySelectorAll('.monster-card');
                monsterCards.forEach(card => {
                    const summonButton = card.querySelector('.summon-monster-btn');
                    if (summonButton) {
                        const monsterType = summonButton.dataset.monster;
                        const monster = gameState.monsters[monsterType];
                        if (monster) {
                            const canSummon = gameState.followers >= monster.baseFollowerCost;
                            summonButton.disabled = !canSummon;
                        }
                    }
                });

                // アップグレードボタンの状態を更新
                const upgradeButtons = document.querySelectorAll('.buy-upgrade-btn');
                upgradeButtons.forEach(button => {
                    const upgradeType = button.dataset.upgrade;
                    if (upgradeType && baseCosts[upgradeType]) {
                        // アップグレードコストを baseCosts から直接取得
                        const upgradeCost = Math.floor(baseCosts[upgradeType] * (gameState.upgradeCostMultiplier || 1));
                        const canAfford = gameState.source >= upgradeCost;
                        button.disabled = !canAfford;
                        button.classList.toggle('button-affordable', canAfford);
                        button.classList.toggle('button-disabled', !canAfford);
                    }
                });

                const recruitButton = document.getElementById('recruitFollowerBtn');
                if (recruitButton) {
                    const isSealed = gameState.pacts?.active?.includes('1');
                    recruitButton.style.display = isSealed ? 'none' : 'block';
                    recruitButton.disabled = isSealed;
                    recruitButton.classList.toggle('sealed-by-pact', isSealed);
                }

                // 狂気ボタンの状態更新
                const madnessButtons = document.querySelectorAll('.madness-btn');
                madnessButtons.forEach(button => {
                    const index = parseInt(button.dataset.index);
                    if (!isNaN(index) && gameState.adventurers[index]) {
                        const adventurer = gameState.adventurers[index];
                        const canAttempt = !adventurer.isMad &&
                            !adventurer.isOnCooldown &&
                            gameState.miasma >= adventurer.madnessCost;
                        button.disabled = !canAttempt;
                    }
                });

                // 契約による封印状態の確認と適用
                if (gameState.pacts?.active?.includes('1')) {
                    hideManualRecruitButtons();
                }
            }

            function updateUpgradeSymbols() {
                const symbolsContainer = document.getElementById('upgradeSymbols');
                if (!symbolsContainer) return;

                // コンテナをクリア
                symbolsContainer.innerHTML = '';

                // 購入済みのアップグレードのシンボルを表示
                for (const upgrade of gameState.upgrades) {
                    if (upgradeSymbols[upgrade]) {
                        const symbolSpan = document.createElement('span');
                        symbolSpan.className = 'upgrade-symbol';
                        symbolSpan.textContent = upgradeSymbols[upgrade];

                        // tooltipを設定
                        const tooltipText = upgradeEffects[upgrade];
                        tippy(symbolSpan, {
                            content: tooltipText,
                            placement: 'bottom'
                        });

                        symbolsContainer.appendChild(symbolSpan);
                    }
                }
            }

            // 吹き出しを表示する関数
            let activeSpeechBubble = false;

            // スピーチバブルの状態管理
            const speechBubbleState = {
                activeSpeechBubble: false,
                currentTimeout: null
            };

            // セリフ管理のための状態オブジェクト
            const bubbleState = {
                activeBubbles: new Set(),
                currentTimeout: null
            };

            // セリフバブルを表示する関数
            function showSpeechBubble(adventurerElement, text, duration = 3000, type = 'normal') {
                // 既存のバブルをすべて削除
                removePreviousBubbles();

                // バブルの作成
                const bubble = document.createElement('div');
                bubble.className = `speech-bubble ${type}`;
                bubble.innerHTML = `
    <div class="bubble-content">
      <p>${text}</p>
      ${type === 'mad' ? '<div class="madness-effect"></div>' : ''}
    </div>
  `;

                // バブルをDOMに追加
                document.body.appendChild(bubble);

                // 位置の更新関数
                const updateBubblePosition = () => {
                    const rect = adventurerElement.getBoundingClientRect();
                    const windowHeight = window.innerHeight;
                    const verticalMargin = -65; // 元の仕様の上方向マージン

                    // デフォルトで上に表示（元の仕様通り）
                    bubble.style.bottom = `${windowHeight - rect.top + verticalMargin}px`;
                    bubble.style.left = `${rect.left + rect.width / 1.5}px`; // 元の水平位置を維持
                    bubble.className = `speech-bubble ${type} show top-arrow`; // デフォルトで上向き矢印
                };

                // 初期位置設定とアニメーション
                requestAnimationFrame(() => {
                    updateBubblePosition();
                    bubble.classList.add('show');
                });

                // スクロールとリサイズ時の位置更新（デバウンス処理付き）
                const scrollHandler = debounce(() => {
                    if (bubble && bubble.parentElement) {
                        updateBubblePosition();
                    }
                }, 50);

                window.addEventListener('scroll', scrollHandler);
                window.addEventListener('resize', scrollHandler);

                // バブルの状態を管理
                bubbleState.activeBubbles.add(bubble);

                // 一定時間後に削除
                bubbleState.currentTimeout = setTimeout(() => {
                    removeBubble(bubble);
                }, duration);

                // クリーンアップ用の関数を保存
                const cleanup = () => {
                    window.removeEventListener('scroll', scrollHandler);
                    window.removeEventListener('resize', scrollHandler);
                };

                return { bubble, cleanup };
            }

            // 既存のバブルを削除
            function removePreviousBubbles() {
                bubbleState.activeBubbles.forEach(bubble => {
                    removeBubble(bubble);
                });
                if (bubbleState.currentTimeout) {
                    clearTimeout(bubbleState.currentTimeout);
                    bubbleState.currentTimeout = null;
                }
            }

            // 単一のバブルを削除
            function removeBubble(bubble) {
                if (!bubble) return;

                bubble.classList.remove('show');
                bubble.addEventListener('transitionend', () => {
                    bubble.remove();
                    bubbleState.activeBubbles.delete(bubble);
                }, { once: true });
            }

            // デバウンス関数
            function debounce(func, wait) {
                let timeout;
                return function (...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            }

            // 固定表示用のヘルパー関数
            function showFixedBubble(bubble) {
                if (bubble.parentElement) {
                    bubble.remove();
                }
                bubble.style.position = 'fixed';
                bubble.style.bottom = '20px';
                bubble.style.left = '50%';
                bubble.style.transform = 'translateX(-50%)';
                bubble.classList.add('no-arrow');
                document.body.appendChild(bubble);
            }

            // 吹き出しを削除する関数
            function removeSpeechBubble() {
                const bubble = document.querySelector('.speech-bubble');
                if (bubble) {
                    bubble.classList.remove('show');
                    bubble.addEventListener('transitionend', () => {
                        bubble.remove();
                        speechBubbleState.activeSpeechBubble = false;
                    }, { once: true });
                }

                if (speechBubbleState.currentTimeout) {
                    clearTimeout(speechBubbleState.currentTimeout);
                    speechBubbleState.currentTimeout = null;
                }

                if (speechBubbleState.cleanup) {
                    speechBubbleState.cleanup();
                    speechBubbleState.cleanup = null;
                }
            }

            let existingStyle = document.querySelector('style');
            if (existingStyle) {
                existingStyle.textContent += `
/* スピーチバブルのベーススタイル */
.speech-bubble {
    background: #1a1a1a;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 12px 16px;
    max-width: 800px;
    min-width: 180px;
    font-size: 10px;
    color: #ccc;
    position: fixed; /* 固定位置に変更 */
    z-index: 100000;
    opacity: 0;
    pointer-events: none;
    text-align: center;
    transform: translateX(-50%);
    letter-spacing: 3px;
    white-space: normal;
    word-wrap: break-word;
    transition: all 0.3s ease;
    font-family: 'Press Start 2P', cursive;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    margin: 10px 0; /* 上下のマージンを追加 */
}

/* 表示状態 */
.speech-bubble.show {
    opacity: 1;
}

/* 上向き矢印のスタイル */
.speech-bubble.top-arrow::after {
    content: '';
    position: absolute;
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    border-width: 10px 10px 0;
    border-style: solid;
    border-color: #444 transparent transparent;
}

/* 下向き矢印のスタイル */
.speech-bubble.bottom-arrow::after {
    content: '';
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    border-width: 0 10px 10px;
    border-style: solid;
    border-color: transparent transparent #444;
}

/* 狂気状態のスタイル */
.speech-bubble.mad {
    background: rgba(40, 0, 0, 0.95);
    border: 2px solid #8a4a4a;
    color: #ff8a8a;
    font-weight: bold;
    font-style: italic;
    animation: madPulse 3s ease-in-out infinite;
    text-shadow: 0 0 5px #ff0000;
}

/* レジスト状態のスタイル */
.speech-bubble.resist {
    background: rgba(0, 0, 40, 0.95);
    border: 2px solid #4a4a8a;
    color: #8a8aff;
    font-weight: bold;
    animation: resistGlow 2s ease-in-out infinite;
}

/* バブルの位置調整用のクラス */
.speech-bubble.top-position {
    bottom: calc(100% + 20px); /* カードの上端から20px上に配置 */
}

.speech-bubble.bottom-position {
    top: calc(100% + 20px); /* カードの下端から20px下に配置 */
}

/* アニメーション定義 */
@keyframes madPulse {
    0% { box-shadow: 0 0 5px #ff0000; }
    50% { box-shadow: 0 0 15px #ff0000; }
    100% { box-shadow: 0 0 5px #ff0000; }
}

@keyframes resistGlow {
    0% { box-shadow: 0 0 5px #4169e1; }
    50% { box-shadow: 0 0 15px #4169e1; }
    100% { box-shadow: 0 0 5px #4169e1; }
}
`;
            }

            // ランダムな台詞を選択して表示する関数
            function triggerRandomDialogue() {
                const adventurers = gameState.adventurers.filter(a =>
                    gameState.unlockedContent.adventurers.has(a.name)
                );

                if (adventurers.length === 0) return;

                const selectedAdventurer = adventurers[Math.floor(Math.random() * adventurers.length)];
                const isMad = selectedAdventurer.isMad;

                const dialoguePool = isMad ? DIALOGUE[selectedAdventurer.name].mad : DIALOGUE[selectedAdventurer.name].normal;
                const selectedText = dialoguePool[Math.floor(Math.random() * dialoguePool.length)];

                showSpeechBubble({
                    text: selectedText,
                    type: isMad ? 'mad' : 'normal',
                    duration: isMad ? 3000 : 3000
                });
            }

            let lastDialogueTime = 0;
            const DIALOGUE_COOLDOWN = 3000; // 6秒のクールダウン
            // ランダムにセリフを表示する関数
            function randomDialogue() {
                const currentTime = Date.now();

                // クールダウン中なら処理をスキップ
                if (currentTime - lastDialogueTime < DIALOGUE_COOLDOWN) {
                    return;
                }

                if (speechBubbleState.activeSpeechBubble) {
                    return;
                }

                // 確率を0.02%から2%に増加
                if (Math.random() < 0.02) {
                    console.log('Random dialogue triggered');
                    const activeAdventurers = gameState.adventurers.filter(adv =>
                        gameState.unlockedContent.adventurers.has(adv.name)
                    );

                    if (activeAdventurers.length > 0) {
                        const adventurer = activeAdventurers[Math.floor(Math.random() * activeAdventurers.length)];
                        const adventurerElement = document.querySelector(`#adventurer-${gameState.adventurers.indexOf(adventurer)}`);
                        console.log('Selected adventurer:', adventurer.name);

                        if (adventurerElement) {
                            const dialogueList = dialogues.adventurers[adventurer.name];
                            if (dialogueList) {
                                const state = adventurer.isMad ? 'mad' : 'normal';
                                const possibleDialogues = dialogueList[state];

                                if (possibleDialogues && possibleDialogues.length > 0) {
                                    const randomText = possibleDialogues[Math.floor(Math.random() * possibleDialogues.length)];
                                    showSpeechBubble(adventurerElement, randomText, 5000, state);
                                    lastDialogueTime = currentTime; // 最後のセリフ表示時刻を更新
                                }
                            }
                        }
                    }
                }
            }

            function checkMadness(adventurer) {
                const madnessChance = calculateMadnessChance(adventurer);
                //console.log('Madness check for:', adventurer.name, 'chance:', madnessChance);

                const adventurerElement = document.querySelector(`#adventurer-${gameState.adventurers.indexOf(adventurer)}`);
                if (!adventurerElement) {
                    console.warn('Adventurer element not found');
                    return false;
                }

                if (Math.random() < madnessChance) {
                    // console.log('Madness check succeeded');
                    if (!adventurer.isMad) {
                        adventurer.isMad = true;
                        // 狂気に陥った時のセリフを必ず表示
                        const dialogueList = dialogues.adventurers[adventurer.name];
                        if (dialogueList && dialogueList.mad && dialogueList.mad.length > 0) {
                            const madDialogues = dialogueList.mad;
                            const randomText = madDialogues[Math.floor(Math.random() * madDialogues.length)];
                            //       console.log('Selected mad dialogue:', randomText);
                            showSpeechBubble(adventurerElement, randomText, 5000, 'mad');
                        }
                    }
                    return true;
                } else {
                    // レジスト時のセリフを必ず表示
                    const dialogueList = dialogues.adventurers[adventurer.name];
                    if (dialogueList && dialogueList.resist && dialogueList.resist.length > 0) {
                        const resistDialogues = dialogueList.resist;
                        const randomText = resistDialogues[Math.floor(Math.random() * resistDialogues.length)];
                        showSpeechBubble(adventurerElement, randomText, 3000, 'resist');
                        // console.log('Selected resist dialogue:', randomText);
                    }
                    return false;
                }
            }

            function showResistDialogue(adventurer, adventurerElement) {
                console.log('Showing resist dialogue for:', adventurer.name);

                // dialoguesオブジェクトからresistセリフを取得して必ず表示
                const dialogueList = dialogues.adventurers[adventurer.name];
                if (dialogueList && dialogueList.resist && dialogueList.resist.length > 0) {
                    const resistDialogues = dialogueList.resist;
                    const randomText = resistDialogues[Math.floor(Math.random() * resistDialogues.length)];
                    console.log('Selected resist dialogue:', randomText);
                    showSpeechBubble(adventurerElement, randomText, 3000, 'resist');
                } else {
                    console.warn(`No resist dialogues found for ${adventurer.name}`);
                }
            }

            // フォロワーの台詞データ
            const followerDialogues = {
                normal: [
                    "We serve the ancient ones...",
                    "The ritual must continue...",
                    "Our numbers grow stronger...",
                    "The Source flows through us...",
                    "We hear the whispers...",
                    "Our faith is unwavering...",
                    "The stars align...",
                    "We await the great awakening...",
                    "Our devotion deepens...",
                    "The old ones guide us..."
                ],
                transformed: {  // 契約後の台詞
                    1: [  // 第1の契約
                        "We are reborn...",
                        "Our flesh transcends...",
                        "The pact binds us...",
                        "We see clearer now...",
                        "Our forms shift and change..."
                    ],
                    2: [  // 第2の契約
                        "Reality bends to our will...",
                        "We exist between worlds...",
                        "Time flows differently...",
                        "The void embraces us...",
                        "We become one with darkness..."
                    ]
                }
            };

            // フォロワーのセリフを表示する関数
            function showFollowerDialogue() {
                const currentTime = Date.now();
                if (currentTime - lastDialogueTime < DIALOGUE_COOLDOWN) return;

                // 確率で台詞を表示（2%の確率）
                if (Math.random() < 0.02) {
                    const followerSection = document.getElementById('followerSection');
                    if (!followerSection) return;

                    let dialoguePool;
                    // 契約状態に応じて台詞プールを選択
                    if (gameState.pacts.active.includes('2')) {
                        dialoguePool = followerDialogues.transformed[2];
                    } else if (gameState.pacts.active.includes('1')) {
                        dialoguePool = followerDialogues.transformed[1];
                    } else {
                        dialoguePool = followerDialogues.normal;
                    }

                    const randomText = dialoguePool[Math.floor(Math.random() * dialoguePool.length)];
                    showSpeechBubble(followerSection, randomText, 3000, 'follower');
                    lastDialogueTime = currentTime;
                }
            }

            // ゲーム情報とショートカットの説明を追加
            const gameInfo = {
                title: "Cultist's Complex Idle",
                description: `
Welcome to Cultist's Complex Idle, where you manage a growing cult dedicated to the ancient ones.
Collect Source, generate Miasma, and recruit followers to summon cosmic horrors!
    `,
                shortcuts: [
                    { key: "S", description: "Jump to Summon Old One section" },
                    { key: "A", description: "Jump to Madness Table section" },
                    { key: "Space", description: "Pause/Resume game" },
                    { key: "[", description: "Buy most expensive available item" },
                    { key: "]", description: "Buy least expensive available item" }
                ],
                gameplay: {
                    resources: [
                        { name: "Source", description: "Primary resource, used for most actions" },
                        { name: "Miasma", description: "Secondary resource, used for corrupting investigators" },
                        { name: "Followers", description: "Your loyal cultists who generate resources" }
                    ],
                    features: [
                        { name: "Monsters", description: "Ancient beings that boost your production" },
                        { name: "Madness", description: "Convert investigators to your cause" },
                        { name: "Pacts", description: "Powerful contracts that reset but provide permanent bonuses" }
                    ]
                }
            };

            // ゲーム情報モーダルを表示する関数
            function showGameInfoModal() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay active';
                modal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">${gameInfo.title}</h2>
                <button class="close-button" onclick="this.closest('.modal-overlay').remove()">×</button>
            </div>
            <div class="modal-body">
                <h3>Game Description</h3>
                <p>${gameInfo.description}</p>
                
                <h3>Keyboard Shortcuts</h3>
                <ul>
                    ${gameInfo.shortcuts.map(s => `<li><kbd>${s.key}</kbd> - ${s.description}</li>`).join('')}
                </ul>
                
                <h3>Resources</h3>
                <ul>
                    ${gameInfo.gameplay.resources.map(r => `<li><strong>${r.name}</strong>: ${r.description}</li>`).join('')}
                </ul>
                
                <h3>Features</h3>
                <ul>
                    ${gameInfo.gameplay.features.map(f => `<li><strong>${f.name}</strong>: ${f.description}</li>`).join('')}
                </ul>
            </div>
        </div>
    `;
                document.body.appendChild(modal);
            }

            function toggleStatisticsModal() {
                const modal = document.getElementById('statisticsModal');
                const statsButton = document.getElementById('statisticsButton');

                if (modal.classList.contains('active')) {
                    // モーダルを閉じる
                    modal.classList.remove('active');
                    statsButton.classList.remove('active');
                    setTimeout(() => {
                        modal.style.display = 'none';
                    }, 300); // トランジション時間後に非表示
                } else {
                    // モーダルを開く
                    modal.style.display = 'block';
                    updateStatistics(); // 統計を更新
                    requestAnimationFrame(() => {
                        modal.classList.add('active');
                        statsButton.classList.add('active');
                    });
                }
            }

            // 既存のshowStatisticsModal関数を置き換え
            function showStatisticsModal() {
                toggleStatisticsModal();
            }

            // 既存のcloseStatisticsModal関数を置き換え
            function closeStatisticsModal() {
                toggleStatisticsModal();
            }

            // モーダル外クリックでの閉じる処理を改善
            document.getElementById('statisticsModal').addEventListener('click', function (e) {
                if (e.target === this) {
                    toggleStatisticsModal();
                }
            });

            // ESCキーでモーダルを閉じる
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape' && document.getElementById('statisticsModal').classList.contains('active')) {
                    toggleStatisticsModal();
                }
            });

            // 初期状態で非表示に設定
            document.addEventListener('DOMContentLoaded', function () {
                const modal = document.getElementById('statisticsModal');
                modal.style.display = 'none';
                modal.classList.remove('active');
            });

            // スクロールに応じてボタンの表示/非表示を切り替える関数
            function scrollFunction() {
                const backToTopBtn = document.getElementById("backToTopBtn");
                if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                    backToTopBtn.style.display = "block";
                } else {
                    backToTopBtn.style.display = "none";
                }
            }

            // ページトップへスクロールする関数
            function backToTop() {
                document.body.scrollTop = 0; // For Safari
                document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
            }

            // イベントリスナーの設定
            window.onscroll = function () { scrollFunction() };

            function setCultosMiner() {
                const cultosminer = document.getElementById('cultosminer');
                cultosminer.innerHTML = `
<span class="cultosminer-color2">   ╔═════════════════════════════════════════════╗   </span>
<span class="cultosminer-color2"> ╔═╝</span><span class="cultosminer-color1">  ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄  </span><span class="cultosminer-color2">╚═╗ </span>
<span class="cultosminer-color2">╔╝</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">╚╗</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">┌─────────────────────────────────────┐</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">│</span><span class="cultosminer-color2"> ▓▓▒▒░░ ＣＵＬＴＯＳ ＭＩＮＥＲ ░░▒▒▓▓ </span><span class="cultosminer-color1">│</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">│</span><span class="cultosminer-color2"> ▓▒░ </span><span class="cultosminer-color4">╔═══╦═══╦═══╗ ╔═══╦═══╦═══╗</span><span class="cultosminer-color2"> ░▒▓ </span><span class="cultosminer-color1">│</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">│</span><span class="cultosminer-color2"> ▒░  </span><span class="cultosminer-color4">║███║███║███║ ║▓▓▓║▓▓▓║▓▓▓║</span><span class="cultosminer-color2">  ░▒ </span><span class="cultosminer-color1">│</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">│</span><span class="cultosminer-color2"> ░   </span><span class="cultosminer-color4">╚═══╩═══╩═══╝ ╚═══╩═══╩═══╝</span><span class="cultosminer-color2">   ░ </span><span class="cultosminer-color1">│</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">└─────────────────────────────────────┘</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">╚═══</span><span class="cultosminer-color1">╔═════════════════╗</span><span class="cultosminer-color2">░░░</span><span class="cultosminer-color1">╔═════════════════╗</span><span class="cultosminer-color2">═══╝</span>
<span class="cultosminer-color2">  ╔═╝</span><span class="cultosminer-color1">▒▒▒▒▒ ▒▒▒▒▒ ▒▒▒▒▒</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">█</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">▒▒▒▒▒ ▒▒▒▒▒ ▒▒▒▒▒</span><span class="cultosminer-color2">╚═╗</span>
<span class="cultosminer-color2"> ╔╝</span><span class="cultosminer-color1">┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐</span><span class="cultosminer-color2">╚╗</span>
<span class="cultosminer-color2">╔╝</span><span class="cultosminer-color1">│ </span><span class="cultosminer-color2">▓▓ </span><span class="cultosminer-color1">││ </span><span class="cultosminer-color2">▓▓ </span><span class="cultosminer-color1">││ </span><span class="cultosminer-color2">▓▓ </span><span class="cultosminer-color1">││ </span><span class="cultosminer-color2">▓▓ </span><span class="cultosminer-color1">││ </span><span class="cultosminer-color2">▓▓ </span><span class="cultosminer-color1">││ </span><span class="cultosminer-color2">▓▓ </span><span class="cultosminer-color1">││ </span><span class="cultosminer-color2">▓▓ </span><span class="cultosminer-color1">││ </span><span class="cultosminer-color2">▓▓ </span><span class="cultosminer-color1">│</span><span class="cultosminer-color2">╚╗</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1">└───┘└───┘└───┘└───┘└───┘└───┘└───┘└───┘</span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1">┌─────┐┌─────┐┌─────┐┌─────┐┌─────┐┌─────┐</span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1">│ </span><span class="cultosminer-color2">░▒▓█ </span><span class="cultosminer-color1">││ </span><span class="cultosminer-color2">░▒▓█ </span><span class="cultosminer-color1">││ </span><span class="cultosminer-color2">░▒▓█ </span><span class="cultosminer-color1">││ </span><span class="cultosminer-color2">░▒▓█ </span><span class="cultosminer-color1">││ </span><span class="cultosminer-color2">░▒▓█ </span><span class="cultosminer-color1">││ </span><span class="cultosminer-color2">░▒▓█ </span><span class="cultosminer-color1">│</span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1">└─────┘└─────┘└─────┘└─────┘└─────┘└─────┘</span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">╚════</span><span class="cultosminer-color1">▒▓█▓▒░</span><span class="cultosminer-color2">══════════════════════</span><span class="cultosminer-color1">░▒▓█▓▒</span><span class="cultosminer-color2">════╝</span>
<span class="cultosminer-color2">     ╚══╝ </span><span class="cultosminer-color1">▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ </span><span class="cultosminer-color2">╚══╝     </span>
`;
            }

            function adjustFontSize(element, maxSize, minSize) {
                let fontSize = maxSize;
                element.style.fontSize = fontSize + 'px';
                while (element.scrollWidth > element.offsetWidth && fontSize > minSize) {
                    fontSize--;
                    element.style.fontSize = fontSize + 'px';
                }
            }

            function generateCultosMiner() {
                const miningStatus = canUseCultosMiner();
                const isActive = isMiningActive && miningStatus.canMine;

                // アニメーションフレームの決定（時間ベース）
                const frame = Math.floor(Date.now() / 200) % 4;

                // 動的なパーツの生成
                const dynamicParts = getDynamicParts(frame, isActive);

                return `
<div class="cultosminer ${isActive ? 'active' : 'inactive'}">
    ${getCultosMinerArt(dynamicParts, isActive)} 
</div>`;
            }

            function getDynamicParts(frame, isActive) {
                if (!isActive) {
                    return {
                        topBorder: '▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄',
                        centerDisplay: '║███║███║███║ ║▓▓▓║▓▓▓║▓▓▓║',
                        bottomBorder: '╚═══╩═══╩═══╝ ╚═══╩═══╩═══╝',
                        colors: {
                            top: '#666',
                            center: '#444',
                            bottom: '#333'
                        }
                    };
                }

                const animations = {
                    topBorder: [
                        { text: '▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄', color: '#ff6b6b' },
                        { text: '▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀▄▀', color: '#4ecdc4' },
                        { text: '█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█', color: '#ffe66d' },
                        { text: '▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀█▀', color: '#95e1d3' }
                    ],
                    centerDisplay: [
                        { text: '║▓▒░║▓▒░║▓▒░║ ║░▒▓║░▒▓║░▒▓║', color: '#a8e6cf' },
                        { text: '║░▒▓║░▒▓║░▒▓║ ║▓▒░║▓▒░║▓▒░║', color: '#dcedc1' },
                        { text: '║▒▓░║▒▓░║▒▓░║ ║░▓▒║░▓▒║░▓▒║', color: '#ffd3b6' },
                        { text: '║▓░▒║▓░▒║▓░▒║ ║▒░▓║▒░▓║▒░▓║', color: '#ffaaa5' }
                    ],
                    bottomBorder: [
                        { text: '╚═▒═╩═▒═╩═▒═╝ ╚═▒═╩═▒═╩═▒═╝', color: '#48dbfb' },
                        { text: '╚▒═▒╩▒═▒╩▒═▒╝ ╚▒═▒╩▒═▒╩▒═▒╝', color: '#ff9ff3' },
                        { text: '╚═▓═╩═▓═╩═▓═╝ ╚═▓═╩═▓═╩═▓═╝', color: '#00d2d3' },
                        { text: '╚▓═▓╩▓═▓╩▓═▓╝ ╚▓═▓╩▓═▓╩▓═▓╝', color: '#54a0ff' }
                    ],
                    // 追加のエフェクト用の色
                    glowColors: [
                        '#ff6b6b88',
                        '#4ecdc488',
                        '#ffe66d88',
                        '#95e1d388'
                    ]
                };

                const currentFrame = animations.topBorder[frame];
                const centerFrame = animations.centerDisplay[frame];
                const bottomFrame = animations.bottomBorder[frame];
                const glowColor = animations.glowColors[frame];

                return {
                    topBorder: currentFrame.text,
                    centerDisplay: centerFrame.text,
                    bottomBorder: bottomFrame.text,
                    colors: {
                        top: currentFrame.color,
                        center: centerFrame.color,
                        bottom: bottomFrame.color,
                        glow: glowColor
                    }
                };
            }
            function getCultosMinerArt(parts, isActive) {
                const titleColor = isActive ? '#00ffff' : '#ff0000';
                // 下部ボタン用の色を定義
                const buttonColors = isActive ? {
                    border: '#00ff66',      // サイバーグリーン（アクティブ時）
                    fill: '#00994d',        // 暗めのサイバーグリーン（アクティブ時）
                    glow: '#00ff6633'       // グローエフェクト（アクティブ時）
                } : {
                    border: '#333333',      // 暗いグレー（非アクティブ時）
                    fill: '#1a1a1a',        // より暗いグレー（非アクティブ時）
                    glow: 'transparent'     // グローなし（非アクティブ時）
                };
                return `<div class="cultosminer-frame" style="--glow-color: ${parts.colors.glow}">
<span class="cultosminer-color2">   ╔═════════════════════════════════════════════╗   </span>
<span class="cultosminer-color2"> ╔═╝</span><span style="color: ${parts.colors.top}">${parts.topBorder}</span><span class="cultosminer-color2">╚═╗ </span>
<span class="cultosminer-color2">╔╝</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">╚╗</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">┌─────────────────────────────────────┐</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">│</span><span style="color: ${titleColor}"> ▓▓▒▒░░ ＣＵＬＴＯＳ ＭＩＮＥＲ ░░▒▒▓▓ </span><span class="cultosminer-color1">│</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">│</span><span class="cultosminer-color2"> ▓▒░ </span><span style="color: ${parts.colors.center}">${parts.centerDisplay}</span><span class="cultosminer-color2"> ░▒▓ </span><span class="cultosminer-color1">│</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">│</span><span class="cultosminer-color2"> ░   </span><span style="color: ${parts.colors.bottom}">${parts.bottomBorder}</span><span class="cultosminer-color2">   ░ </span><span class="cultosminer-color1">│</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">└─────────────────────────────────────┘</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█</span><span class="cultosminer-color2">░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░</span><span class="cultosminer-color1">█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span class="cultosminer-color1"> ▐█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█▌ </span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">╚═══</span><span class="cultosminer-color1">╔═════════════════╗</span><span class="cultosminer-color2">░░░</span><span class="cultosminer-color1">╔═════════════════╗</span><span class="cultosminer-color2">═══╝</span>
<span class="cultosminer-color2">  ╔═╝</span><span style="color: ${buttonColors.border}">▒▒▒▒▒ ▒▒▒▒▒ ▒▒▒▒▒</span><span class="cultosminer-color2">░</span><span class="cultosminer-color1">█</span><span class="cultosminer-color2">░</span><span style="color: ${buttonColors.border}">▒▒▒▒▒ ▒▒▒▒▒ ▒▒▒▒▒</span><span class="cultosminer-color2">╚═╗</span>
<span class="cultosminer-color2"> ╔╝</span><span style="color: ${buttonColors.border}">┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐</span><span class="cultosminer-color2">╚╗</span>
<span class="cultosminer-color2">╔╝</span><span style="color: ${buttonColors.border}">│ </span><span style="color: ${buttonColors.fill}">▓▓ </span><span style="color: ${buttonColors.border}">││ </span><span style="color: ${buttonColors.fill}">▓▓ </span><span style="color: ${buttonColors.border}">││ </span><span style="color: ${buttonColors.fill}">▓▓ </span><span style="color: ${buttonColors.border}">││ </span><span style="color: ${buttonColors.fill}">▓▓ </span><span style="color: ${buttonColors.border}">││ </span><span style="color: ${buttonColors.fill}">▓▓ </span><span style="color: ${buttonColors.border}">││ </span><span style="color: ${buttonColors.fill}">▓▓ </span><span style="color: ${buttonColors.border}">││ </span><span style="color: ${buttonColors.fill}">▓▓ </span><span style="color: ${buttonColors.border}">││ </span><span style="color: ${buttonColors.fill}">▓▓ </span><span style="color: ${buttonColors.border}">│</span><span class="cultosminer-color2">╚╗</span>
<span class="cultosminer-color2">║</span><span style="color: ${buttonColors.border}">└───┘└───┘└───┘└───┘└───┘└───┘└───┘└───┘</span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span style="color: ${buttonColors.border}">┌─────┐┌─────┐┌─────┐┌─────┐┌─────┐┌─────┐</span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span style="color: ${buttonColors.border}">│ </span><span style="color: ${buttonColors.fill}">░▒▓█ </span><span style="color: ${buttonColors.border}">││ </span><span style="color: ${buttonColors.fill}">░▒▓█ </span><span style="color: ${buttonColors.border}">││ </span><span style="color: ${buttonColors.fill}">░▒▓█ </span><span style="color: ${buttonColors.border}">││ </span><span style="color: ${buttonColors.fill}">░▒▓█ </span><span style="color: ${buttonColors.border}">││ </span><span style="color: ${buttonColors.fill}">░▒▓█ </span><span style="color: ${buttonColors.border}">││ </span><span style="color: ${buttonColors.fill}">░▒▓█ </span><span style="color: ${buttonColors.border}">│</span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">║</span><span style="color: ${buttonColors.border}">└─────┘└─────┘└─────┘└─────┘└─────┘└─────┘</span><span class="cultosminer-color2">║</span>
<span class="cultosminer-color2">╚════</span><span style="color: ${buttonColors.fill}">▒▓█▓▒░</span><span class="cultosminer-color2">══════════════════════</span><span style="color: ${buttonColors.fill}">░▒▓█▓▒</span><span class="cultosminer-color2">════╝</span>
<span class="cultosminer-color2">     ╚══╝ </span><span style="color: ${buttonColors.border}">▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ </span><span class="cultosminer-color2">╚══╝     </span></div>`;
            }

            function getBaseColor1() {
                const totalMonsters = Object.values(gameState.monsters).reduce((sum, monster) => sum + monster.count, 0);
                if (totalMonsters > 1000) return '#ff3300';  // 深い橙色
                if (totalMonsters > 500) return '#cc2900';   // 暗めの赤橙
                if (totalMonsters > 100) return '#991f00';   // さらに暗い赤橙
                return '#2b2b2b';                            // ダークグレー
            }

            function getBaseColor2() {
                const totalUpgrades = gameState.upgrades.length;
                if (totalUpgrades > 15) return '#00ff66';    // サイバーグリーン
                if (totalUpgrades > 10) return '#00cc52';    // 暗めのサイバーグリーン
                if (totalUpgrades > 5) return '#00994d';     // さらに暗いサイバーグリーン
                return '#1a1a1a';                            // より暗いグレー
            }

            function getAccentColor1() {
                const cultosRate = gameState.cultosRate || 0;
                if (cultosRate > 0.1) return '#66ffff';      // 明るい真空管ブルー
                if (cultosRate > 0.05) return '#33ffff';     // 中間の真空管ブルー
                if (cultosRate > 0.01) return '#00ffff';     // 標準の真空管ブルー
                return '#404040';                            // ミディアムグレー
            }

            function getAccentColor2() {
                const miasmaRate = gameState.miasmaRate || 0;
                if (miasmaRate > 1000) return '#ff9933';     // 真空管オレンジ
                if (miasmaRate > 500) return '#ff8000';      // 暗めの真空管オレンジ
                if (miasmaRate > 100) return '#cc6600';      // さらに暗い真空管オレンジ
                return '#333333';                            // ダークグレー
            }
            function canUseCultosMiner() {
                // 必要なアップグレードの確認
                const hasRequiredUpgrade = gameState.upgrades.includes('Hiroshi Sakamoto`s Paper');

                // モンスターの要件確認
                const hasRequiredMonsters =
                    (gameState.monsters['Shoggoth']?.count >= 10);

                // すべての条件を満たしているか確認
                const isUnlocked = hasRequiredUpgrade && hasRequiredMonsters;

                // リソースのチェック（source と miasma が必要）
                const canAffordPower = gameState.source >= 1 && gameState.miasma >= 1;

                // アンロック状態とリソース状態を返す
                return {
                    isUnlocked,
                    canAffordPower,
                    canMine: isUnlocked && canAffordPower
                };
            }

            function updateCultosMiner() {
                const cultosminer = document.getElementById('cultosminer');
                const cultosColumn = document.getElementById('cultosColumn');
                if (!cultosminer || !cultosColumn) return;

                // マイニング状態の確認
                const miningStatus = canUseCultosMiner();

                // CultosMinerの表示状態を更新
                if (!miningStatus.isUnlocked) {
                    cultosminer.classList.add('cultosminer-disabled');
                    cultosColumn.classList.add('cultos-hidden');
                } else {
                    cultosminer.classList.remove('cultosminer-disabled');
                    cultosColumn.classList.remove('cultos-hidden');
                }

                // マイニング可能な場合の処理
                if (miningStatus.canMine) {
                    if (!cultosminer.classList.contains('active')) {
                        cultosminer.classList.add('active');
                        logAction("Cultos Miner activated");
                    }
                    // マイニングレートの更新
                    updateCultosRate();
                } else {
                    cultosminer.classList.remove('active');
                }

                // エンブレムの更新
                const newCultosMinerContent = generateCultosMiner();
                if (cultosminer.innerHTML !== newCultosMinerContent) {
                    cultosminer.innerHTML = newCultosMinerContent;
                }
                updateMiningIndicator();
            }

            function updateCultosRate() {
                if (!gameState.hasOwnProperty('cultosRate')) {
                    gameState.cultosRate = 0;
                }

                const miningStatus = canUseCultosMiner();
                if (miningStatus.canMine) {
                    // マイニングレートの計算（既存のロジックを使用）
                    const totalMonsters = Object.values(gameState.monsters)
                        .reduce((sum, monster) => sum + monster.count, 0);
                    const baseRate = 1 / (totalMonsters + 10);
                    const miasmaBoost = 1 + gameState.miasma / 10000;
                    const randomFactor = 0.9 + Math.random() * 0.2;

                    gameState.cultosRate = baseRate * miasmaBoost * randomFactor;
                } else {
                    gameState.cultosRate = 0;
                }

                // 表示の更新
                document.getElementById('cultosHashRate').textContent =
                    formatNumber(gameState.cultosRate, 3);
            }

            function updateCultosVisibility() {
                const cultosColumn = document.getElementById('cultosColumn');
                if (!cultosColumn) return;

                const isCultosUnlocked = checkUnlockCondition('resources', 'cultos');
                cultosColumn.classList.toggle('cultos-hidden', !isCultosUnlocked);
            }


            // マイニングの状態を管理する変数を追加
            let isMiningActive = false;

            // CultosMinerのクリックイベントを追加
            document.getElementById('cultosminer').addEventListener('click', toggleMining);

            // toggleMining関数を修正
            function toggleMining() {
                isMiningActive = !isMiningActive;

                // インジケーターと UI の状態を更新
                updateMiningIndicator();
                updateMiningUI(isMiningActive);

                // マイニング状態を保存
                localStorage.setItem('miningState', isMiningActive);
            }

            // 新しい関数: マイニングUIの更新を一元管理
            function updateMiningUI(isActive) {
                const button = document.getElementById('toggleMining');
                const cultosSymbol = document.querySelector('.cultos-symbol');
                const sourceConsumptionRate = document.getElementById('sourceConsumptionRate');
                const miasmaConsumptionRate = document.getElementById('miasmaConsumptionRate');

                if (button) {
                    button.textContent = isActive ? 'Stop Mining' : 'Start Mining';
                }

                if (cultosSymbol) {
                    cultosSymbol.classList.toggle('active', isActive);
                    cultosSymbol.classList.toggle('inactive', !isActive);
                }

                if (sourceConsumptionRate) {
                    sourceConsumptionRate.classList.toggle('inactive', !isActive);
                }

                if (miasmaConsumptionRate) {
                    miasmaConsumptionRate.classList.toggle('inactive', !isActive);
                }
            }

            function updateMiningIndicator() {
                const indicator = document.getElementById('miningIndicator');
                if (!indicator) return;

                const miningStatus = canUseCultosMiner();

                if (isMiningActive && miningStatus.canMine) {
                    indicator.classList.add('active');
                    indicator.classList.remove('inactive');
                } else {
                    indicator.classList.remove('active');
                    indicator.classList.add('inactive');
                }
            }

            // 既存の初期化処理を拡張
            document.addEventListener('DOMContentLoaded', function () {
                const savedMiningState = localStorage.getItem('miningState');
                if (savedMiningState === 'true') {
                    toggleMining();
                } else {
                    // 初期状態でもインジケーターを更新
                    updateMiningIndicator();
                }

                document.getElementById('toggleMining').addEventListener('click', toggleMining);
            });

            function calculateCultosRate(deltaTime) {
                const miningStatus = canUseCultosMiner();

                if (!isMiningActive || !miningStatus.canMine) {
                    resetMiningRates();
                    updateConsumptionRates(0, 0, false);

                    // マイニングが停止した際にボタンとUIの状態を更新
                    if (isMiningActive) {
                        isMiningActive = false;
                        updateMiningUI(false);
                        updateMiningIndicator();  // インジケーターも更新
                        localStorage.setItem('miningState', 'false');
                        logAction('Cultos mining stopped: Conditions not met');
                    }

                    return 0;
                }

                // 基本レートとコストの計算
                const baseHashRate = 0.000001;
                const totalMonsters = Object.values(gameState.monsters).reduce((sum, monster) => sum + monster.count, 0);
                const monsterBoost = 1 + (totalMonsters * 0.001);
                const miasmaBoost = 1 + (Math.log10(gameState.miasma + 1) * 0.01);
                const upgradeBoost = gameState.upgrades.includes('Hiroshi Sakamoto`s Paper') ? 1.5 : 1;

                // 時間ベースの変動を追加（1時間周期）
                const hourInSeconds = 3600;
                const currentTime = Date.now() / 1000; // 秒単位に変換
                const timePhase = (currentTime % hourInSeconds) / hourInSeconds; // 0-1の値

                // サイン波による緩やかな変動（振幅20%）
                const fluctuation = 1 + (0.2 * Math.sin(2 * Math.PI * timePhase));

                // ノイズを追加（最大5%の微細な変動）
                const noise = 1 + (Math.random() * 0.05 - 0.025);

                // 最終的なハッシュレート計算
                const hashRate = baseHashRate * monsterBoost * upgradeBoost * fluctuation * noise;

                // リソースコストの計算と消費
                const currentCost = {
                    source: hashRate * deltaTime * 100000000,
                    miasma: hashRate * deltaTime * 50000000
                };

                if (gameState.source < currentCost.source || gameState.miasma < currentCost.miasma) {
                    // リソース不足時のマイニング停止処理
                    isMiningActive = false;
                    resetMiningRates();
                    updateConsumptionRates(0, 0, false);
                    updateMiningUI(false);
                    updateMiningIndicator();
                    localStorage.setItem('miningState', 'false');
                    logAction('Cultos mining stopped: Insufficient resources');
                    return 0;
                }

                // リソース消費
                gameState.source -= currentCost.source;
                gameState.miasma -= currentCost.miasma;

                // レート表示の更新
                const sourceRate = currentCost.source / deltaTime;
                const miasmaRate = currentCost.miasma / deltaTime;
                updateConsumptionRates(sourceRate, miasmaRate, true);

                return hashRate;
            }

            // Cultosボーナスの計算関数
            function calculateCultosBonus() {
                if (!gameState.cultos || !gameState.unlockedContent.resources.has('cultos')) {
                    return 1;
                }

                // 基本: 1 + (1 Cultos につき0.1%のボーナス（上限50%）)
                const baseBonus = Math.min(gameState.cultos * 0.001, 0.5);

                // Cultosの桁数によるボーナス
                // 10, 100, 1000... Cultosごとに追加5%（上限30%）
                const magnitude = gameState.cultos > 0 ? Math.floor(Math.log10(gameState.cultos)) : 0;
                const magnitudeBonus = Math.min(magnitude * 0.05, 0.3);

                // Follower効率ボーナス
                // 1000 Cultosごとに1%のボーナス（上限20%）
                const followerBonus = Math.min(Math.floor(gameState.cultos / 1000) * 0.01, 0.2);

                // 合計ボーナス（1 + ボーナス値）
                return 1 + baseBonus + magnitudeBonus + followerBonus;
            }

            // ハッシュレート表示のフォーマット関数も更新
            function formatHashRate(hashRate) {
                if (hashRate === 0) return "0 H/s";

                const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s'];
                const base = 1000;
                let unitIndex = 0;
                let scaledRate = hashRate;

                while (scaledRate >= base && unitIndex < units.length - 1) {
                    scaledRate /= base;
                    unitIndex++;
                }

                // 変動の激しさに応じて小数点以下の桁数を調整
                const precision = scaledRate < 10 ? 3 : scaledRate < 100 ? 2 : 1;
                return `${scaledRate.toFixed(precision)} ${units[unitIndex]}`;
            }

            function resetMiningRates() {
                const cultosminer = document.getElementById('cultosminer');
                const cultosSymbol = document.querySelector('.cultos-symbol');

                if (cultosminer) {
                    cultosminer.classList.remove('active');
                    cultosminer.classList.add('inactive');
                }

                if (cultosSymbol) {
                    cultosSymbol.classList.remove('active');
                    cultosSymbol.classList.add('inactive');
                }
            }

            // 消費レート表示を更新する関数
            function updateConsumptionRates(sourceRate, miasmaRate, isActive) {
                const sourceRateDisplay = document.getElementById('sourceConsumptionRate');
                const miasmaRateDisplay = document.getElementById('miasmaConsumptionRate');

                if (sourceRateDisplay) {
                    sourceRateDisplay.textContent = `${formatNumber(sourceRate, 3)}/s`;
                    sourceRateDisplay.className = `rate-value ${isActive ? 'active' : 'inactive'}`;
                }

                if (miasmaRateDisplay) {
                    miasmaRateDisplay.textContent = `${formatNumber(miasmaRate, 3)}/s`;
                    miasmaRateDisplay.className = `rate-value ${isActive ? 'active' : 'inactive'}`;
                }
            }

            function updateCultosMinerAppearance() {
                const cultosSymbol = document.querySelector('.cultos-symbol');
                const cultosminer = document.getElementById('cultosminer');
                const miningStatus = canUseCultosMiner();

                // マイニング状態とリソース状態に基づいて表示を更新
                const isDisabled = !miningStatus.canMine || !isMiningActive;

                if (cultosSymbol) {
                    cultosSymbol.classList.remove('active', 'inactive');
                    cultosSymbol.classList.add(isDisabled ? 'inactive' : 'active');
                }

                if (cultosminer) {
                    if (isDisabled) {
                        cultosminer.classList.add('cultosminer-disabled');
                        cultosminer.classList.remove('active');
                    } else {
                        cultosminer.classList.remove('cultosminer-disabled');
                        cultosminer.classList.add('active');
                    }
                }

                // マイニング状態の表示を更新
                const sourceRateDisplay = document.getElementById('sourceConsumptionRate');
                const miasmaRateDisplay = document.getElementById('miasmaConsumptionRate');
                const cultosHashRate = document.getElementById('cultosHashRate');

                if (sourceRateDisplay) sourceRateDisplay.className = `rate-value ${isDisabled ? 'inactive' : 'active'}`;
                if (miasmaRateDisplay) miasmaRateDisplay.className = `rate-value ${isDisabled ? 'inactive' : 'active'}`;
                if (cultosHashRate) cultosHashRate.className = `hash-rate ${isDisabled ? 'inactive' : 'active'}`;
            }

            function hasEnoughResources(cost) {
                return gameState.source >= cost.source && gameState.miasma >= cost.miasma;
            }

            function consumeResources(cost) {
                gameState.source -= cost.source;
                gameState.miasma -= cost.miasma;
            }

            function updateRates(hashRate, cost) {
                gameState.cultosRate = hashRate;
                gameState.sourceRate = -cost.source;
                gameState.miasmaRate = -cost.miasma;
            }

            function resetMiningRates() {
                gameState.cultosRate = 0;
                gameState.sourceRate = 0;
                gameState.miasmaRate = 0;
            }

            // ハッシュレートの表示を整形する関数
            function formatHashRate(hashRate) {
                if (hashRate === 0) return "0";

                const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s'];
                const base = 1000;
                let unitIndex = 0;
                let scaledRate = hashRate;

                while (scaledRate >= base && unitIndex < units.length - 1) {
                    scaledRate /= base;
                    unitIndex++;
                }

                // 小数点以下3桁まで表示（不要な0は削除）
                return scaledRate.toPrecision(5).replace(/\.?0+$/, '') + ' ' + units[unitIndex];
            }


            const additionalStyles = `
.simple #cultosminer {
    font-size: 0.9em;
    display: inline-flex;
    align-items: center;
    gap: 5px;
    padding: 2px 5px;
}

.simple #eldritchDrum {
    font-size: 0.9em;
    display: inline-flex;
    align-items: center;
    gap: 5px;
    padding: 2px 5px;
}

#resourceDisplay.simple .cultos-symbol,
#resourceDisplay.simple #eldritchDrum {
    margin-left: 10px;
}

#resourceDisplay.simple .consumption-rate-container {
    font-size: 0.8em;
}

.simple .cultosminer-color1,
.simple .cultosminer-color2,
.simple .cultosminer-color3,
.simple .cultosminer-color4 {
    display: inline-block;
    vertical-align: middle;
}
`;

            const drumStyles = `
.drum-container {
    display: flex;
    align-items: flex-start;
    gap: 20px;
}

#eldritchDrum {
    font-family: 'Courier New', monospace;
    white-space: pre;
    display: inline-block;
    margin-left: 20px;
    color: #e0e0e0;
    line-height: 1.2;
}

#eldritchDrum.simple {
    font-size: 0.9em;
    line-height: 1;
}

#eldritchDrum.simple .drum-display {
    display: inline-flex;
    align-items: center;
    gap: 10px;
}

#eldritchDrum.simple .drum-frame {
    display: none;
}

#drumControls {
    margin-top: 5px;
    display: flex;
    gap: 10px;
}

#drumControls button {
    background-color: transparent;
    color: #e0e0e0;
    border: 1px solid #4CAF50;
    padding: 4px 8px;
    cursor: pointer;
    border-radius: 3px;
    font-size: 11px;
    transition: all 0.3s ease;
}

#drumControls button:hover:not(:disabled) {
    background-color: rgba(76, 175, 80, 0.2);
}
`;


            function addDrumStyles() {
                const styleSheet = document.createElement('style');
                styleSheet.textContent = drumStyles;
                document.head.appendChild(styleSheet);
            }

            // ゲーム状態の管理
            let drumState = {
                symbols: [
                    { id: 'NORMAL', char: '◊', probability: 0.3, payoutMultiplier: 1.5 },
                    { id: 'MINOR', char: '✧', probability: 0.25, payoutMultiplier: 2 },
                    { id: 'MEDIUM', char: '۞', probability: 0.2, payoutMultiplier: 3 },
                    { id: 'MAJOR', char: '☆', probability: 0.15, payoutMultiplier: 5 },
                    { id: 'SPECIAL', char: '✴', probability: 0.07, payoutMultiplier: 8 },
                    { id: 'JACKPOT', char: '☯', probability: 0.03, payoutMultiplier: 20 }
                ],
                reels: [
                    ['◊', '✧', '۞'],  // 現在のリール状態
                    ['☆', '✴', '☯'],
                    ['۞', '◊', '✧']
                ],
                phase: 'NORMAL',
                lampStates: [false, false, false],
                currentBet: 50,
                lastWin: 0,
                autoSpinEnabled: false,
                resonanceGauge: 0,
                setting: 1,
                lastChangeTime: Date.now(),
                spinning: false
            };

            // フレームの描画パターン
            const framePatterns = {
                NORMAL: {
                    top: "╭━━━━━━━━━━━╮",
                    middle: "│           │",
                    bottom: "╰━━━━━━━━━━━╯"
                },
                RESONATING: {
                    top: "╭≋≋≋≋≋≋≋≋≋≋≋╮",
                    middle: "│           │",
                    bottom: "╰≋≋≋≋≋≋≋≋≋≋≋╯"
                }
            };

            function renderDrum() {
                const isSimple = document.getElementById('resourceDisplay').classList.contains('simple');
                const frame = framePatterns[drumState.phase];
                const lamps = drumState.lampStates.map(s => s ? '[●]' : '[○]').join('');

                if (isSimple) {
                    // テキストのみを返す
                    return `[DRUM] BET: ${drumState.currentBet}©️ ${drumState.spinning ? 'SPINNING' : `LAST: ${drumState.lastWin}©️`}`;
                }

                // 通常表示
                return `
${lamps} PHASE: [${drumState.phase}]
${frame.top}  BET: ${drumState.currentBet} ©️
│ ${drumState.reels[0].join('  ')} │  WIN: ${drumState.lastWin} ©️
│ ${drumState.reels[1].join('  ')} │
│ ${drumState.reels[2].join('  ')} │
${frame.bottom}
[AUTO: ${drumState.autoSpinEnabled ? 'ON' : 'OFF'}] [MAX: 1000]`;
            }

            // リールのスピン処理
            function spinReels() {
                if (drumState.spinning) return;
                if (gameState.cultos < drumState.currentBet) return;

                drumState.spinning = true;
                gameState.cultos -= drumState.currentBet;

                // スピン中のアニメーション
                let spinFrames = 0;
                const spinInterval = setInterval(() => {
                    // ランダムなシンボルでリールを更新
                    drumState.reels = drumState.reels.map(() =>
                        drumState.symbols.map(() =>
                            drumState.symbols[Math.floor(Math.random() * drumState.symbols.length)].char
                        )
                    );

                    spinFrames++;
                    if (spinFrames >= 20) {  // 20フレームでスピン終了
                        clearInterval(spinInterval);
                        determineResults();
                    }
                }, 50);
            }

            // 結果判定
            function determineResults() {
                drumState.spinning = false;
                let win = 0;

                // 結果の決定（設定値を考慮）
                const results = calculateSpinResults();
                drumState.reels = results;

                // 当選判定
                win = calculateWin(results);
                drumState.lastWin = win;
                gameState.cultos += win;

                // 示唆演出の更新
                updateHints();
            }

            // 初期化の実行
            document.addEventListener('DOMContentLoaded', initializeElditchDrum);

            // ボタンの追加とイベントリスナー
            function addDrumControls() {
                const controlsContainer = document.createElement('div');
                controlsContainer.id = 'drumControls';
                controlsContainer.style.marginLeft = '10px';  // Cultos Minerとの間隔

                controlsContainer.innerHTML = `
        <button id="spinButton">SPIN (50 ©️)</button>
        <button id="autoSpinToggle">AUTO: OFF</button>
        <button id="betButton">BET: 50 ©️</button>
    `;

                // Cultos Minerの横にコントロールを配置
                const cultosMiner = document.getElementById('cultosminer');
                if (cultosMiner && cultosMiner.parentNode) {
                    cultosMiner.parentNode.insertBefore(controlsContainer, cultosMiner.nextSibling);
                }

                // イベントリスナーの設定
                document.getElementById('spinButton').addEventListener('click', () => {
                    if (gameState.cultos >= drumState.currentBet) {
                        spinReels();
                    }
                });

                document.getElementById('autoSpinToggle').addEventListener('click', () => {
                    drumState.autoSpinEnabled = !drumState.autoSpinEnabled;
                    document.getElementById('autoSpinToggle').textContent =
                        `AUTO: ${drumState.autoSpinEnabled ? 'ON' : 'OFF'}`;
                });

                document.getElementById('betButton').addEventListener('click', () => {
                    const betValues = [50, 100, 250, 500, 1000];
                    const currentIndex = betValues.indexOf(drumState.currentBet);
                    drumState.currentBet = betValues[(currentIndex + 1) % betValues.length];
                    document.getElementById('betButton').textContent = `BET: ${drumState.currentBet} ©️`;
                });
            }

            // デバッグ用のログ機能
            function logDrumEvent(event, data) {
                console.log(`[Eldritch's Drum] ${event}:`, data);
            }

            // セレクタを具体的に指定して初期化関数を修正
            function initializeElditchDrum() {
                // 既存のDrumが存在する場合は削除
                const existingDrum = document.getElementById('eldritchDrum');
                if (existingDrum) {
                    existingDrum.remove();
                }

                // Cultos Minerを探す
                const cultosminer = document.getElementById('cultosminer');
                if (!cultosminer) {
                    console.error('Cultos Miner element not found');
                    return;
                }

                // 既存のコンテナを確認
                let containerDiv = cultosminer.parentElement.querySelector('.drum-container');
                if (!containerDiv) {
                    // コンテナがない場合のみ新規作成
                    containerDiv = document.createElement('div');
                    containerDiv.className = 'drum-container';
                    cultosminer.parentNode.insertBefore(containerDiv, cultosminer);
                    containerDiv.appendChild(cultosminer);
                }

                // Drumの作成
                const drumDiv = document.createElement('div');
                drumDiv.id = 'eldritchDrum';
                containerDiv.appendChild(drumDiv);

                // コントロールの追加
                const controlsDiv = document.createElement('div');
                controlsDiv.id = 'drumControls';
                drumDiv.appendChild(controlsDiv);

                controlsDiv.innerHTML = `
        <button id="spinButton">SPIN (50 ©️)</button>
        <button id="autoSpinToggle">AUTO: OFF</button>
        <button id="betButton">BET: 50 ©️</button>
    `;

                // イベントリスナーの設定
                setupEventListeners();

                // 更新インターバルの設定（既存のインターバルがあれば削除）
                if (window.drumUpdateInterval) {
                    clearInterval(window.drumUpdateInterval);
                }
                window.drumUpdateInterval = setInterval(updateDrum, 50);
            }

            // DOMContentLoaded イベントリスナーを1回だけ設定
            const initialize = () => {
                // スタイルの追加（一度だけ）
                if (!document.getElementById('drumStyles')) {
                    const styleSheet = document.createElement('style');
                    styleSheet.id = 'drumStyles';
                    styleSheet.textContent = drumStyles;
                    document.head.appendChild(styleSheet);
                }

                // 遅延を入れて初期化
                setTimeout(initializeElditchDrum, 100);
            };

            // 既存のイベントリスナーを削除して再設定
            window.removeEventListener('DOMContentLoaded', initialize);
            document.addEventListener('DOMContentLoaded', initialize);

            // スピン結果の計算を改善
            function calculateSpinResults() {
                // デバッグ用の確率表示
                const settingMultiplier = 1 + (drumState.setting - 1) * 0.05;
                logDrumEvent('Spin probability multiplier', settingMultiplier);

                return drumState.reels.map(() =>
                    drumState.symbols.map(() => {
                        const symbol = weightedRandomSymbol(settingMultiplier);
                        return symbol.char;
                    })
                );
            }

            // 重み付きランダム選択の実装
            function weightedRandomSymbol(multiplier) {
                const random = Math.random();
                let probabilitySum = 0;

                for (const symbol of drumState.symbols) {
                    probabilitySum += symbol.probability * multiplier;
                    if (random <= probabilitySum) {
                        logDrumEvent('Selected symbol', symbol);
                        return symbol;
                    }
                }

                return drumState.symbols[0];
            }

            // 当選判定の実装
            function calculateWin(results) {
                let win = 0;
                const lines = [
                    [0, 0, 0], // 横1列目
                    [1, 1, 1], // 横2列目
                    [2, 2, 2], // 横3列目
                ];

                lines.forEach((line, index) => {
                    const symbols = line.map((row, col) => results[row][col]);
                    const uniqueSymbols = new Set(symbols);

                    if (uniqueSymbols.size === 1) {
                        const symbol = drumState.symbols.find(s => s.char === symbols[0]);
                        if (symbol) {
                            const lineWin = drumState.currentBet * symbol.payoutMultiplier;
                            win += lineWin;
                            logDrumEvent(`Line ${index + 1} win`, lineWin);
                        }
                    }
                });

                return win;
            }

            // 描画更新関数の改善
            function updateDrum() {
                const drumElement = document.getElementById('eldritchDrum');
                if (!drumElement) return;

                const isSimple = document.getElementById('resourceDisplay').classList.contains('simple');
                drumElement.classList.toggle('simple', isSimple);

                // メインディスプレイ部分の更新
                const displayContent = drumElement.querySelector('.drum-display') || document.createElement('div');
                displayContent.className = 'drum-display';
                displayContent.textContent = renderDrum();

                if (!drumElement.contains(displayContent)) {
                    drumElement.insertBefore(displayContent, drumElement.firstChild);
                }

                // オートスピン処理
                if (drumState.autoSpinEnabled && !drumState.spinning && gameState.cultos >= drumState.currentBet) {
                    spinReels();
                }
            }

            // エラーハンドリングの追加
            window.onerror = function (msg, url, lineNo, columnNo, error) {
                logDrumEvent('Error', {
                    message: msg,
                    location: `${url}:${lineNo}:${columnNo}`,
                    error: error
                });
                return false;
            };

            function jumpToSummonOldOne() {
                const summonOldOneSection = document.querySelector('.main-content');
                if (summonOldOneSection) {
                    summonOldOneSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setTimeout(() => {
                        window.scrollBy(0, -document.getElementById('game-header').offsetHeight);
                    }, 500);
                }
            }

            function setupTopButtons() {
                const jumpToSummonOldOneBtn = document.getElementById('jumpToSummonOldOne');
                if (jumpToSummonOldOneBtn) {
                    jumpToSummonOldOneBtn.addEventListener('click', jumpToSummonOldOne);
                }

                const jumpToMadnessTableBtn = document.getElementById('jumpToMadnessTable');
                if (jumpToMadnessTableBtn) {
                    jumpToMadnessTableBtn.addEventListener('click', jumpToMadnessTable);
                }

                // Back to Top button functionality is already handled by the existing code
            }

            // スクロールイベントリスナー
            window.addEventListener('scroll', function () {
                const backToTopBtn = document.getElementById('backToTopBtn');
                if (backToTopBtn) {
                    if (window.pageYOffset > 300) { // 300pxスクロールしたら表示
                        backToTopBtn.style.display = 'block';
                    } else {
                        backToTopBtn.style.display = 'none';
                    }
                }
            });

            function toggleTimeAcceleration() {
                const accelerationLevels = [1, 2, 5, 10, 50, 100];
                const currentIndex = accelerationLevels.indexOf(timeAcceleration);
                const nextIndex = (currentIndex + 1) % accelerationLevels.length;
                timeAcceleration = accelerationLevels[nextIndex];
                updateTimeAccelerationDisplay();
            }

            // 現在表示されているカードを取得する関数を修正
            function getCurrentVisibleCard() {
                try {
                    const cards = document.querySelectorAll('.monster-card');
                    if (!cards || cards.length === 0) return null;

                    const headerHeight = getHeaderOffsets();

                    for (const card of cards) {
                        const rect = card.getBoundingClientRect();
                        if (rect && rect.top >= headerHeight && rect.top < window.innerHeight) {
                            return card;
                        }
                    }

                    return cards[0]; // デフォルトで最初のカードを返す
                } catch (error) {
                    console.warn('Error getting current visible card:', error);
                    return null;
                }
            }

            let isAllCardsExpanded = true;

            function toggleMonsterCardDetails(expanded) {
                const monsterCards = document.querySelectorAll('.monster-card-details');
                const toggleAllBtn = document.getElementById('toggleAllMonsterCards');

                // 現在の状態を反転
                isAllCardsExpanded = expanded;

                monsterCards.forEach(card => {
                    if (expanded) {
                        card.style.maxHeight = '1000px';
                        card.classList.add('expanded');
                    } else {
                        card.style.maxHeight = '0';
                        card.classList.remove('expanded');
                    }

                    // プログレスバーの表示を切り替え
                    const progressBar = card.closest('.monster-card')?.querySelector('.summon-progress-bar');
                    if (progressBar) {
                        progressBar.style.display = expanded ? 'none' : 'block';
                    }
                });

                // ボタンのテキストを更新
                if (toggleAllBtn) {
                    toggleAllBtn.textContent = expanded ? 'Collapse All Cards' : 'Expand All Cards';
                }
            }

            function setupMonsterCardToggle() {
                const toggleAllBtn = document.getElementById('toggleAllMonsterCards');
                if (!toggleAllBtn) return;

                // クリックイベントを設定
                toggleAllBtn.onclick = function () {
                    toggleMonsterCardDetails(!isAllCardsExpanded);
                };
            }

            // DOMContentLoadedイベントで初期化を確実に行う
            document.addEventListener('DOMContentLoaded', () => {
                setupMonsterCardToggle();
            });


            function getHeaderOffsets() {
                let totalOffset = 0;
                const defaultOffset = 60;

                try {
                    const gameHeader = document.querySelector('.game-header');
                    if (gameHeader) {
                        // タイトルの折りたたみ状態を復元
                        const isTitleCollapsed = localStorage.getItem('titleCollapsed') === 'true';
                        if (isTitleCollapsed) {
                            gameHeader.classList.add('collapsed');
                        } else {
                            gameHeader.classList.remove('collapsed');
                        }
                        totalOffset += gameHeader.offsetHeight;
                    }

                    const resourceDisplay = document.querySelector('#resourceDisplay');
                    if (resourceDisplay) {
                        totalOffset += resourceDisplay.offsetHeight;
                    }

                    return Math.max(totalOffset, defaultOffset);
                } catch (error) {
                    console.warn('Error calculating header offsets:', error);
                    return defaultOffset;
                }
            }

            // タイトルのトグル関数を修正
            function toggleTitle() {
                const gameHeader = document.querySelector('.game-header');
                if (gameHeader) {
                    const isCollapsed = gameHeader.classList.toggle('collapsed');
                    localStorage.setItem('titleCollapsed', isCollapsed);
                }
            }

            function getFirstVisibleCard() {
                try {
                    const cards = document.querySelectorAll('.monster-card');
                    if (cards.length === 0) return null;

                    const totalOffset = getHeaderOffsets();

                    for (const card of cards) {
                        const rect = card.getBoundingClientRect();
                        if (rect.top >= totalOffset && rect.top < window.innerHeight) {
                            return card;
                        }
                    }
                    return cards[0]; // デフォルトで最初のカードを返す
                } catch (error) {
                    console.error('Error in getFirstVisibleCard:', error);
                    return null;
                }
            }

            function getScrollOffset(element) {
                if (!element) return 0;

                try {
                    const totalOffset = getHeaderOffsets();
                    const elementRect = element.getBoundingClientRect();
                    return Math.max(0, window.pageYOffset + elementRect.top - totalOffset - 10);
                } catch (error) {
                    console.error('Error in getScrollOffset:', error);
                    return 0;
                }
            }

            function jumpToMadnessTable() {
                const madnessTable = document.getElementById('madnessTable');
                if (madnessTable) {
                    madnessTable.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setTimeout(() => {
                        window.scrollBy(0, -60);  // トップボタンの高さ分だけ上にスクロール
                    }, 500);  // スクロールアニメーションが終わった後に実行
                }
            }


            function updateTimeAccelerationDisplay() {
                const display = document.getElementById('timeAccelerationDisplay');
                const tickSpeedDisplay = document.getElementById('tickSpeedDisplay');

                if (display) {
                    display.textContent = `x${timeAcceleration}`;
                }

                if (tickSpeedDisplay) {
                    // 契約による加速も考慮
                    const totalSpeed = timeAcceleration * (gameState.pacts?.tickSpeedMultiplier || 1);
                    tickSpeedDisplay.textContent = `x${totalSpeed.toFixed(3)}`;
                    tickSpeedDisplay.style.color = '#4CAF50';  // 緑色で表示
                }
            }

            document.getElementById('toggleTimeAcceleration').addEventListener('click', function () {
                const accelerationLevels = [1, 2, 5, 10, 50, 100];
                const currentIndex = accelerationLevels.indexOf(timeAcceleration);
                const nextIndex = (currentIndex + 1) % accelerationLevels.length;
                timeAcceleration = accelerationLevels[nextIndex];
                updateTimeAccelerationDisplay();
            });

            // コスト計算関数の修正
            function getCost(type) {
                // フォロワーの場合は別計算
                if (type === 'follower') {
                    const baseFollowerCost = 10;
                    const followerCount = gameState.followers;

                    // フォロワーは単純な指数関数的成長を維持
                    if (followerCount < 1000) {
                        return Math.floor(baseFollowerCost * Math.pow(1.1, followerCount));
                    } else {
                        // 1000以降は線形に近い成長
                        return Math.floor(baseFollowerCost * Math.pow(1.1, 1000) * (1 + (followerCount - 1000) * 0.01));
                    }
                }

                // モンスターの場合
                const monster = gameState.monsters[type];
                if (!monster) return Infinity;

                const baseSourceCost = monster.baseSourceCost || baseCosts[type] || 100;
                const count = monster.count || 0;

                // 波形を生成する関数
                function getWaveMultiplier(count) {
                    // 基本の波形（複合的な正弦波）
                    const baseWave = Math.sin(count * 0.4) * 0.2 + // 主波形
                        Math.sin(count * 0.8) * 0.1;   // 二次波形

                    // 段階的な価格調整（5体ごとに小さな価格低下）
                    const stepDiscount = (count % 5 === 4) ? -0.15 : 0;

                    // 10体ごとの大きな価格上昇
                    const majorSpike = (count % 10 === 9) ? 0.3 : 0;

                    // カウントが増えるごとに波の影響を徐々に減少
                    const waveReduction = Math.max(0.2, 1 - count * 0.005);

                    // 最終的な乗数（波形効果を制限）
                    return 1 + ((baseWave + stepDiscount + majorSpike) * waveReduction);
                }

                // 基本の指数関数的上昇
                let baseMultiplier;
                if (count < 100) {
                    baseMultiplier = Math.pow(1.15, count);
                } else {
                    baseMultiplier = Math.pow(1.15, 100) * (1 + (count - 100) * 0.05);
                }

                // 波形効果を適用
                const waveMultiplier = getWaveMultiplier(count);
                const finalCost = Math.floor(baseSourceCost * baseMultiplier * waveMultiplier);

                // コストの上限を設定
                return Math.min(finalCost, Number.MAX_SAFE_INTEGER);
            }

            // Collect source function
            function collectSource() {
                gameState.source += 1; // 1回のクリックで1つだけ増加
                logAction("Collected 1 source");
            }

            // デバッグ用の関数を追加
            function debug(message) {
                console.log(`[DEBUG] ${message}`);
            }

            // アンロック状態を更新する関数
            function validateUnlockState() {
                // アドベンチャラーのアンロック状態を更新
                for (let adventurer of gameState.adventurers) {
                    if (!gameState.unlockedContent.adventurers.has(adventurer.name)) {
                        if (checkUnlockCondition('adventurers', adventurer.name)) {
                            gameState.unlockedContent.adventurers.add(adventurer.name);
                            logAction(`New Adventurer Unlocked: ${adventurer.name}!`);
                        }
                    }
                }

                // モンスターのアンロック状態を更新
                for (let monsterName in gameState.monsters) {
                    if (!gameState.unlockedContent.monsters.has(monsterName)) {
                        if (checkUnlockCondition('monsters', monsterName)) {
                            gameState.unlockedContent.monsters.add(monsterName);
                            logAction(`New Monster Unlocked: ${monsterName}!`);
                        }
                    }
                }

                // アップグレードのアンロック状態を更新
                for (let upgradeName in upgradeDefinitions) {
                    if (!gameState.unlockedContent.upgrades.has(upgradeName)) {
                        if (checkUnlockCondition('upgrades', upgradeName)) {
                            gameState.unlockedContent.upgrades.add(upgradeName);
                            logAction(`New Upgrade Unlocked: ${upgradeName}!`);
                        }
                    }
                }
            }

            // アンロック条件の説明を取得する関数
            function getUnlockDescription(category, id) {
                const conditions = unlockConditions[category][id];
                if (!conditions) return 'Unknown condition';

                // 最初から解放されている場合
                if (conditions.isUnlocked) return '';

                // 説明文が直接設定されている場合はそれを返す
                if (conditions.description) return conditions.description;

                // requirement オブジェクトから説明を生成
                const req = conditions.requirement;
                if (!req) return 'Unknown requirement';

                let descriptions = [];

                // Source requirement
                if (req.source) {
                    descriptions.push(`${formatNumber(req.source)} source`);
                }

                // Miasma requirement
                if (req.miasma) {
                    descriptions.push(`${formatNumber(req.miasma)} miasma`);
                }

                // Followers requirement
                if (req.followers) {
                    descriptions.push(`${formatNumber(req.followers)} followers`);
                }

                // Monster requirements
                if (req.monsters) {
                    for (const [monsterType, count] of Object.entries(req.monsters)) {
                        descriptions.push(`${count} ${monsterType}`);
                    }
                }

                // Upgrade requirements
                if (req.upgrades) {
                    if (Array.isArray(req.upgrades)) {
                        descriptions.push(`upgrades: ${req.upgrades.join(', ')}`);
                    }
                }

                // Adventurer level requirements
                if (req.adventurers) {
                    for (const [advName, advReq] of Object.entries(req.adventurers)) {
                        if (advReq.level) {
                            descriptions.push(`Level ${advReq.level} ${advName}`);
                        }
                    }
                }

                return `Requires ${descriptions.join(' and ')}`;
            }

            function checkUnlockCondition(type, name) {
                // アンロック済みの場合は true を返す
                if (gameState.unlockedContent[type].has(name)) {
                    return true;
                }

                const condition = unlockConditions[type]?.[name];
                if (!condition) return false;
                if (condition.isUnlocked) return true;

                const requirement = condition.requirement;
                if (!requirement) return false;

                // アドベンチャラーのレベル要件チェック
                if (requirement.adventurers) {
                    for (const [advName, reqData] of Object.entries(requirement.adventurers)) {
                        // 対象のアドベンチャラーを探す
                        const adventurer = gameState.adventurers.find(adv => adv.name === advName);
                        // レベル要件を満たしていない場合は false を返す
                        if (!adventurer || adventurer.level < reqData.level) {
                            return false;
                        }
                    }
                }

                // モンスター要件チェック
                if (requirement.monsters) {
                    for (const [monsterType, count] of Object.entries(requirement.monsters)) {
                        if (!gameState.monsters[monsterType] || gameState.monsters[monsterType].count < count) {
                            return false;
                        }
                    }
                }

                // アップグレード要件チェック
                if (requirement.upgrades) {
                    for (const upgrade of requirement.upgrades) {
                        if (!gameState.upgrades.includes(upgrade)) {
                            return false;
                        }
                    }
                }

                // モンスタータイプの数チェック
                if (requirement.monsterTypes) {
                    const uniqueMonsterTypes = Object.values(gameState.monsters)
                        .filter(monster => monster.count > 0).length;
                    if (uniqueMonsterTypes < requirement.monsterTypes) {
                        return false;
                    }
                }

                // モンスターレベル要件チェック
                if (requirement.monsterLevel) {
                    const hasHighLevelMonster = Object.values(gameState.monsters)
                        .some(monster => monster.level >= requirement.monsterLevel);
                    if (!hasHighLevelMonster) {
                        return false;
                    }
                }

                // すべての条件を満たした場合
                if (gameState.unlockedContent[type]) {
                    gameState.unlockedContent[type].add(name);
                }

                return true;
            }

            // updateUnlockStatus関数を修正
            function updateUnlockStatus(skipDisplayUpdate = false) {
                if (!gameState.unlockedContent) {
                    initializeGameState();
                }

                let unlockOccurred = false;

                try {
                    // アドベンチャラーのアンロック処理を修正
                    for (const adventurer of gameState.adventurers) {
                        if (!gameState.unlockedContent.adventurers.has(adventurer.name)) {
                            if (checkUnlockCondition('adventurers', adventurer.name)) {
                                gameState.unlockedContent.adventurers.add(adventurer.name);
                                showUnlockNotification('adventurer', adventurer.name);
                                debug(`Adventurer unlocked: ${adventurer.name}`);
                                unlockOccurred = true;
                            }
                        }
                    }

                    // アップグレードのアンロックチェック
                    upgradeOrder.forEach(upgradeName => {
                        if (!gameState.unlockedContent.upgrades.has(upgradeName)) {
                            if (checkUnlockCondition('upgrades', upgradeName)) {
                                gameState.unlockedContent.upgrades.add(upgradeName);
                                showUnlockNotification('upgrade', upgradeName);
                                debug(`Upgrade unlocked: ${upgradeName}`);
                                unlockOccurred = true;
                            }
                        }
                    });

                    // モンスターのアンロックチェック
                    monsterOrder.forEach(monsterName => {
                        if (!gameState.unlockedContent.monsters.has(monsterName)) {
                            if (checkUnlockCondition('monsters', monsterName)) {
                                gameState.unlockedContent.monsters.add(monsterName);
                                showUnlockNotification('monster', monsterName);
                                debug(`Monster unlocked: ${monsterName}`);
                                unlockOccurred = true;
                            }
                        }
                    });

                    // リソースのアンロックチェック
                    Object.keys(unlockConditions.resources || {}).forEach(resourceName => {
                        if (!gameState.unlockedContent.resources.has(resourceName)) {
                            if (checkUnlockCondition('resources', resourceName)) {
                                gameState.unlockedContent.resources.add(resourceName);
                                showUnlockNotification('resource', resourceName);
                                debug(`Resource unlocked: ${resourceName}`);
                                unlockOccurred = true;
                            }
                        }
                    });

                    if (unlockOccurred && !skipDisplayUpdate) {
                        updateDisplaysAfterUnlock();
                        // アドベンチャラーカードの更新を明示的に呼び出し
                        updateAdventurerCards();
                    }

                } catch (error) {
                    console.error('Error in updateUnlockStatus:', error);
                    debug(`Error updating unlock status: ${error.message}`);
                }

                return unlockOccurred;
            }

            function initializeNotificationSystem() {
                // 既存のコンテナを削除（重複防止）
                const oldContainer = document.getElementById('notifications-container');
                if (oldContainer) {
                    oldContainer.remove();
                }

                // 新しいコンテナを作成
                const container = document.createElement('div');
                container.id = 'notifications-container';
                container.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 100000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: none;
        max-height: 90vh;
        overflow-y: auto;
    `;
                document.body.appendChild(container);
            }

            // 通知コンテナをDOMに追加する関数
            function createNotificationContainer() {
                if (!document.getElementById('notification-container')) {
                    const container = document.createElement('div');
                    container.id = 'notification-container';
                    container.className = 'notification-container';
                    document.body.appendChild(container);
                }
            }

            // アンロック進捗を更新する関数
            function updateUnlockProgress() {
                // モンスターの進捗
                const monsterProgress = document.getElementById('monster-unlock-progress');
                if (monsterProgress) {
                    const unlockedMonsters = gameState.unlockedContent.monsters.size;
                    const totalMonsters = Object.keys(gameState.monsters).length;
                    monsterProgress.textContent = `Monsters: ${unlockedMonsters}/${totalMonsters}`;
                }

                // アドベンチャラーの進捗
                const adventurerProgress = document.getElementById('adventurer-unlock-progress');
                if (adventurerProgress) {
                    const unlockedAdventurers = gameState.unlockedContent.adventurers.size;
                    const totalAdventurers = gameState.adventurers.length;
                    adventurerProgress.textContent = `Adventurers: ${unlockedAdventurers}/${totalAdventurers}`;
                }

                // アップグレードの進捗
                const upgradeProgress = document.getElementById('upgrade-unlock-progress');
                if (upgradeProgress) {
                    const unlockedUpgrades = gameState.unlockedContent.upgrades.size;
                    const totalUpgrades = Object.keys(upgradeDefinitions).length;
                    upgradeProgress.textContent = `Upgrades: ${unlockedUpgrades}/${totalUpgrades}`;
                }
            }

            // 補助関数（もし既に定義されていない場合）
            function logAction(message) {
                const logContainer = document.getElementById('action-log');
                if (!logContainer) return;

                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                logEntry.textContent = message;

                logContainer.insertBefore(logEntry, logContainer.firstChild);

                // ログエントリの数を制限（最新の50個を保持）
                while (logContainer.children.length > 50) {
                    logContainer.removeChild(logContainer.lastChild);
                }
            }

            function animateUnlock(element) {
                if (!element) return;

                element.classList.add('unlocking');
                element.addEventListener('animationend', () => {
                    element.classList.remove('unlocking');
                }, { once: true });
            }

            function checkSpecialUnlocks() {
                if (!gameState.unlockedContent) {
                    gameState.unlockedContent = {
                        adventurers: new Set(['Novice Explorer']),
                        monsters: new Set(['Shoggoth']),
                        upgrades: new Set(['Ritual Knowledge']),
                        resources: new Set()
                    };
                }

                // 各カテゴリが存在することを確認
                if (!gameState.unlockedContent.monsters) gameState.unlockedContent.monsters = new Set(['Shoggoth']);
                if (!gameState.unlockedContent.adventurers) gameState.unlockedContent.adventurers = new Set(['Novice Explorer']);
                if (!gameState.unlockedContent.upgrades) gameState.unlockedContent.upgrades = new Set(['Ritual Knowledge']);
                // 総生産量に基づくアンロック
                const totalProduction = calculateTotalProduction();
                if (totalProduction >= 1000 && !gameState.specialUnlocks.has('production1000')) {
                    gameState.specialUnlocks.add('production1000');
                    showUnlockNotification('special', 'Production Milestone: 1,000/s');
                }

                // フォロワー数に基づくアンロック
                if (gameState.followers >= 100 && !gameState.specialUnlocks.has('followers100')) {
                    gameState.specialUnlocks.add('followers100');
                    showUnlockNotification('special', 'Follower Milestone: 100');
                }

                // モンスター数に基づくアンロック
                const totalMonsters = Object.values(gameState.monsters)
                    .reduce((sum, monster) => sum + monster.count, 0);
                if (totalMonsters >= 50 && !gameState.specialUnlocks.has('monsters50')) {
                    gameState.specialUnlocks.add('monsters50');
                    showUnlockNotification('special', 'Monster Milestone: 50 total');
                }

                // アップグレード数に基づくアンロック
                if (gameState.upgrades.length >= 5 && !gameState.specialUnlocks.has('upgrades5')) {
                    gameState.specialUnlocks.add('upgrades5');
                    showUnlockNotification('special', 'Upgrade Milestone: 5 purchased');
                }
            }

            function checkAndUpdateUnlocks() {
                // gameState.unlockedContentが存在することを確認
                if (!gameState.unlockedContent) {
                    gameState.unlockedContent = {
                        adventurers: new Set(['Novice Explorer']),
                        monsters: new Set(['Shoggoth']),
                        upgrades: new Set(['Ritual Knowledge']),
                        resources: new Set()
                    };
                }

                // 各カテゴリが存在することを確認
                if (!gameState.unlockedContent.monsters) {
                    gameState.unlockedContent.monsters = new Set(['Shoggoth']);
                }
                if (!gameState.unlockedContent.adventurers) {
                    gameState.unlockedContent.adventurers = new Set(['Novice Explorer']);
                }
                if (!gameState.unlockedContent.upgrades) {
                    gameState.unlockedContent.upgrades = new Set(['Ritual Knowledge']);
                }

                // upgradesプロパティが配列として存在することを確認
                if (!Array.isArray(gameState.upgrades)) {
                    gameState.upgrades = ['Ritual Knowledge'];
                }

                // 各カテゴリのアンロック状態をチェック
                for (let monsterName in gameState.monsters) {
                    if (checkUnlockCondition('monsters', monsterName)) {
                        gameState.unlockedContent.monsters.add(monsterName);
                    }
                }

                for (let adventurer of gameState.adventurers) {
                    if (checkUnlockCondition('adventurers', adventurer.name)) {
                        gameState.unlockedContent.adventurers.add(adventurer.name);
                    }
                }

                for (let upgradeName in upgradeDefinitions) {
                    if (checkUnlockCondition('upgrades', upgradeName)) {
                        gameState.unlockedContent.upgrades.add(upgradeName);
                    }
                }
            }

            const cardConfigs = {
                monsters: {
                    prefix: 'monster-',
                    conditions: unlockConditions.monsters,
                    lastUnlockState: {},
                    getUnlockDescription: (id) => getUnlockDescription('monsters', id)
                },
                adventurers: {
                    prefix: 'adventurer-',
                    conditions: unlockConditions.adventurers,
                    lastUnlockState: {},
                    getUnlockDescription: (id) => getUnlockDescription('adventurers', id)
                },
                upgrades: {
                    prefix: 'upgrade-',
                    conditions: unlockConditions.upgrades,
                    lastUnlockState: {},
                    getUnlockDescription: (id) => getUnlockDescription('upgrades', id)
                }
            };

            // アンロック状態をチェックする関数を修正
            function checkNewUnlocks() {
                // 初期アンロックのリスト
                const initialUnlocks = {
                    monsters: ['Shoggoth'],
                    adventurers: ['Novice Explorer'],
                    upgrades: ['Ritual Knowledge']
                };
                // 各カテゴリーのアンロック条件をチェック
                for (const category in unlockConditions) {
                    for (const [itemId, condition] of Object.entries(unlockConditions[category])) {
                        // 初期アンロックの場合はスキップ
                        if (initialUnlocks[category]?.includes(itemId)) {
                            continue;
                        }

                        if (!gameState.unlockedContent[category].has(itemId) && checkUnlockCondition(category, itemId)) {
                            gameState.unlockedContent[category].add(itemId);
                            showUnlockNotification(category, itemId);
                            updateDisplaysAfterUnlock();
                        }
                    }
                }
            }

            function showUnlockNotification(type, name) {
                try {
                    // 通知要素の作成
                    const notification = document.createElement('div');
                    notification.className = 'unlock-notification';
                    notification.innerHTML = `
            <div class="notification-icon ${type}-icon"></div>
            <div class="notification-content">
                <h4>New ${type} Unlocked!</h4>
                <p>${name}</p>
            </div>
        `;

                    // 既存の通知を確認し、位置を調整
                    const existingNotifications = document.querySelectorAll('.unlock-notification');
                    const offset = existingNotifications.length * 70;

                    // 通知のスタイル
                    notification.style.cssText = `
            position: fixed;
            top: ${20 + offset}px;
            right: 20px;
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 15px;
            color: #e0e0e0;
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 250px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            animation: slideIn 0.5s ease-out, fadeOut 0.5s ease-in 4.5s;
            pointer-events: none;
        `;

                    document.body.appendChild(notification);

                    // 5秒後に通知を消す（フェードアウトアニメーション付き）
                    setTimeout(() => {
                        notification.style.animation = 'fadeOut 0.5s ease-in forwards';
                        setTimeout(() => notification.remove(), 500);
                    }, 4500);

                } catch (error) {
                    console.error('Error showing unlock notification:', error);
                }
            }

            // アンロックアニメーション
            function animateUnlock(card) {
                card.classList.add('unlocking');
                card.classList.remove('locked');
                card.classList.add('unlocked');

                // アニメーション後にクラスを削除
                card.addEventListener('animationend', () => {
                    card.classList.remove('unlocking');
                }, { once: true });
            }

            function updateUnlockSystem() {
                checkAndUpdateUnlocks();
                updateUnlockStatus();
                updateProgressBars();
            }

            async function executeAction(action, params = {}) {
                debug(`executeAction called with action: ${action.name}`);
                if (globalLock) {
                    debug("Global lock is active, action not executed");
                    return;
                }
                globalLock = true;

                try {
                    if (action === summonMonster) {
                        await action(params.type);  // パラメータからタイプを取り出す
                    } else {
                        await action(params);
                    }
                    debug(`Action ${action.name} executed successfully`);
                } catch (error) {
                    debug(`Error executing action ${action.name}: ${error}`);
                } finally {
                    globalLock = false;
                }
            }

            function updateRecruitFollowerButton() {
                const recruitFollowerBtn = document.getElementById('recruitFollowerBtn');
                const cost = getCost('follower');

                if (recruitFollowerBtn) {
                    const canAfford = gameState.source >= cost;
                    recruitFollowerBtn.disabled = !canAfford;

                    if (!canAfford) {
                        recruitFollowerBtn.classList.remove('button-enabled', 'whiflash');
                        recruitFollowerBtn.classList.add('disabled');
                    } else {
                        recruitFollowerBtn.classList.remove('disabled');
                        recruitFollowerBtn.classList.add('button-enabled');
                    }
                }
            }

            function recruitFollower() {
                // アクションロックをチェック
                if (actionLocks.recruitFollower) {
                    return;
                }

                // アクションロックを設定
                actionLocks.recruitFollower = true;

                try {
                    const cost = getCost('follower');
                    const recruitFollowerBtn = document.getElementById('recruitFollowerBtn');

                    if (gameState.source >= cost) {
                        // 1人のフォロワーのみを追加
                        gameState.source -= cost;
                        gameState.followers++;
                        logAction(`Recruited 1 follower for ${cost} source`);

                        if (recruitFollowerBtn) {
                            recruitFollowerBtn.classList.add('whiflash');
                        }

                        // 統計情報の更新
                        if (gameState.statistics) {
                            gameState.statistics.totalFollowersRecruited++;
                            gameState.statistics.peakFollowers = Math.max(
                                gameState.statistics.peakFollowers || 0,
                                gameState.followers
                            );
                        }

                        // UI更新
                        updateCultosMiner();
                        updateResourceDisplay();
                        updateRecruitFollowerButton();
                    }
                } catch (error) {
                    console.error("Error in recruitFollower:", error);
                } finally {
                    // アクションロックを解除
                    setTimeout(() => {
                        actionLocks.recruitFollower = false;
                    }, 50); // 50ミリ秒のクールダウン
                }
            }

            let isSummoning = false;

            function summonMonster(type) {
                if (isSummoning) {
                    debug("Summoning already in progress");
                    return;
                }

                isSummoning = true;

                try {
                    const monsterData = gameState.monsters[type];
                    if (!monsterData) {
                        console.log("Monster data not found");
                        return;
                    }

                    const sourceCost = getCost(type);
                    const followerCost = Math.floor(monsterData.baseFollowerCost *
                        Math.pow(monsterData.followerCostGrowth, monsterData.count));

                    if (gameState.source < sourceCost || gameState.followers < followerCost) {
                        console.log("Not enough resources");
                        return;
                    }

                    // リソースを消費して召喚実行
                    gameState.source -= sourceCost;
                    gameState.followers -= followerCost;
                    monsterData.count++;

                    // UI更新とログ
                    logAction(`Summoned 1 ${type} for ${formatNumber(sourceCost)} source and ${formatNumber(followerCost)} followers`);
                    updateMonsterCards();
                    updateResourceDisplay();
                    updateCultosMiner();

                } catch (error) {
                    console.error("Summoning error:", error);
                } finally {
                    setTimeout(() => {
                        isSummoning = false;
                    }, 50);
                }
            }

            function buyUpgrade(upgrade) {
                debug(`buyUpgrade called for ${upgrade}`);

                // アップグレードのロック状態をチェック
                if (!checkUnlockCondition('upgrades', upgrade)) {
                    debug(`Attempted to buy locked upgrade: ${upgrade}`);
                    logAction(`Cannot purchase ${upgrade} - not yet unlocked`);
                    return;
                }

                const cost = Math.floor(baseCosts[upgrade] * (gameState.upgradeCostMultiplier || 1));
                if (gameState.source >= cost && !gameState.upgrades.includes(upgrade)) {
                    gameState.source -= cost;
                    gameState.upgrades.push(upgrade);
                    applyUpgrade(upgrade);
                    updateUpgradeSymbols();
                    updateUpgradeGrid();
                    updateDisplay();
                    logAction(`Bought ${upgrade} upgrade for ${formatNumber(cost)} source`);
                    debug(`Upgrade bought. New upgrades: ${gameState.upgrades}`);

                } else {
                    if (gameState.source < cost) {
                        logAction(`Not enough source to buy ${upgrade}. Need ${formatNumber(cost)}, have ${formatNumber(gameState.source)}`);
                    } else {
                        logAction(`${upgrade} has already been purchased`);
                    }
                    debug(`Unable to buy upgrade ${upgrade}. Cost: ${cost}, Available: ${gameState.source}, Already owned: ${gameState.upgrades.includes(upgrade)}`);
                }
            }

            function calculateTimeToSummon(sourceDifference, productionPerSecond) {
                if (productionPerSecond <= 0) {
                    return sourceDifference > 0 ? Infinity : 0;
                }
                return Math.max(0, sourceDifference / productionPerSecond);
            }

            function calculateSynergyEffects() {
                let synergyEffects = {
                    source: 1,
                    miasma: 1,
                    all: 1
                };

                // アクティブなモンスターを特定
                const activeMonsters = new Set(
                    Object.entries(gameState.monsters)
                        .filter(([_, monster]) => monster.count > 0)
                        .map(([type, _]) => type)
                );

                // シナジー効果の計算
                activeMonsters.forEach(monsterType => {
                    const monster = gameState.monsters[monsterType];
                    if (monster.synergy && activeMonsters.has(monster.synergy.partner)) {
                        const effectType = monster.synergy.type || 'all';
                        const effectValue = monster.synergy.effect;

                        // シナジー効果を乗算で適用
                        synergyEffects[effectType] *= (1 + effectValue);

                        // デバッグログ
                        debug(`Synergy activated: ${monsterType} with ${monster.synergy.partner}, type: ${effectType}, value: ${effectValue}`);
                    }
                });

                return synergyEffects;
            }

            function applySpecialAbilities() {
                for (const monsterType in gameState.monsters) {
                    const monster = gameState.monsters[monsterType];
                    if (!monster || !monster.specialAbility || monster.count === 0) continue;

                    const triggerCount = Math.floor(monster.count / monster.specialAbility.trigger);
                    if (triggerCount === 0) continue;

                    const effect = monster.specialAbility.effect;
                    switch (effect.type) {
                        case 'allMonsterEfficiency':
                            // すべてのモンスターの効率を上昇（上限なし）
                            const efficiencyBonus = 1 + (effect.value * triggerCount);
                            for (const targetMonster in gameState.monsters) {
                                gameState.monsters[targetMonster].sourceEfficiency *= efficiencyBonus;
                                gameState.monsters[targetMonster].miasmaEfficiency *= efficiencyBonus;
                            }
                            debug(`Applied all monster efficiency bonus: +${((efficiencyBonus - 1) * 100).toFixed(1)}%`);
                            break;

                        case 'madnessChance':
                            // 狂気チャンス増加（最大20%まで）
                            const maxMadnessBonus = 0.20;
                            const madnessBonus = Math.min(effect.value * triggerCount, maxMadnessBonus);
                            gameState.madnessChanceMultiplier = 1 + madnessBonus;
                            debug(`Applied madness chance modifier: +${(madnessBonus * 100).toFixed(1)}% (max: 20%)`);
                            break;

                        case 'miasmaEfficiency':
                            // ミアスマ効率上昇（上限なし）
                            const miasmaBonus = Math.pow(1 + effect.value, triggerCount);
                            for (const targetMonster in gameState.monsters) {
                                gameState.monsters[targetMonster].miasmaEfficiency *= miasmaBonus;
                            }
                            debug(`Applied miasma efficiency bonus: x${miasmaBonus.toFixed(2)}`);
                            break;

                        case 'sourceProduction':
                            // Source生産量上昇（上限なし）
                            const sourceBonus = Math.pow(1 + effect.value, triggerCount);
                            for (const targetMonster in gameState.monsters) {
                                gameState.monsters[targetMonster].sourceEfficiency *= sourceBonus;
                            }
                            debug(`Applied source production bonus: x${sourceBonus.toFixed(2)}`);
                            break;

                        case 'upgradeEffect':
                            // アップグレード効果増強（上限なし）
                            const upgradeBonus = 1 + (effect.value * triggerCount);
                            gameState.upgradeEffectMultiplier = (gameState.upgradeEffectMultiplier || 1) * upgradeBonus;
                            debug(`Applied upgrade effect multiplier: x${upgradeBonus.toFixed(2)}`);
                            break;

                        case 'followerProduction':
                            // フォロワー生産量増加（上限なし）
                            const followerBonus = effect.value * triggerCount;
                            gameState.followerProductionBonus = (gameState.followerProductionBonus || 0) + followerBonus;
                            debug(`Applied follower production bonus: +${(followerBonus * 100).toFixed(1)}%`);
                            break;

                        case 'cosmicResonance':
                            // 宇宙共鳴効果（全体の生産量増加、上限なし）
                            const resonanceBonus = Math.pow(1 + effect.value, triggerCount);
                            gameState.cosmicResonanceMultiplier = (gameState.cosmicResonanceMultiplier || 1) * resonanceBonus;
                            debug(`Applied cosmic resonance multiplier: x${resonanceBonus.toFixed(2)}`);
                            break;

                        case 'upgradeCost':
                            // アップグレードコスト削減（指定された最大値まで）
                            const totalDiscount = Math.min(effect.value * triggerCount, effect.maxDiscount);
                            gameState.upgradeCostMultiplier = Math.max(0.1, (1 - totalDiscount));
                            debug(`Applied upgrade cost reduction: -${(totalDiscount * 100).toFixed(1)}%`);
                            break;

                        case 'adventurerResistanceRecoveryTime':
                            // アドベンチャラーの抵抗クールダウン時間削減（最小500ms）
                            const cooldownReduction = effect.value * triggerCount;
                            gameState.adventurerCooldownReduction = Math.min(
                                (gameState.adventurerCooldownReduction || 0) + cooldownReduction,
                                gameState.adventurerBaseCooldown - 500
                            );
                            debug(`Applied adventurer cooldown reduction: ${cooldownReduction}ms`);
                            break;
                    }
                }

                // 効果が適用されたことを示すフラグを設定
                gameState.specialAbilitiesApplied = true;
            }

            function applySpecialAbilityEffect(monsterType, effectType, value) {
                const monster = gameState.monsters[monsterType];
                if (!monster || !monster.specialAbility || monster.specialAbility.effect.type !== effectType) {
                    return value;  // 効果が適用できない場合は元の値を返す
                }

                const triggerCount = Math.floor(monster.count / monster.specialAbility.trigger);
                if (triggerCount === 0) {
                    return value;  // トリガー条件を満たしていない場合は元の値を返す
                }

                switch (effectType) {
                    case 'allMonsterEfficiency':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    case 'followerEfficiencyMultiplier':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, monster.count);
                    case 'followerEfficiency':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    case 'sourceProduction':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    case 'upgradeEffect':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    case 'followerProduction':
                        return value + monster.specialAbility.effect.value * triggerCount;
                    case 'cosmicResonance':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    case 'upgradeCost':
                        const totalDiscount = Math.min(monster.specialAbility.effect.maxDiscount, monster.specialAbility.effect.value * triggerCount);
                        return value * (1 - totalDiscount);
                    case 'adventurerResistanceRecoveryTime':
                        return value - (monster.specialAbility.effect.value * triggerCount);
                    case 'miasmaEfficiency':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    case 'madnessChance':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    default:
                        return value;
                }
            }

            function applyUpgrade(upgrade, multiplier = 1) {
                switch (upgrade) {
                    case "Ritual Knowledge":
                        gameState.followerEfficiency *= (1 + 0.25 * multiplier);
                        break;
                    case "Eldritch Tome":
                        for (let monster in gameState.monsters) {
                            gameState.monsters[monster].sourceEfficiency *= (1 + 0.25 * multiplier);
                            gameState.monsters[monster].miasmaEfficiency *= (1 + 0.25 * multiplier);
                        }
                        break;
                    case "Hiroshi Sakamoto`s Paper":
                        // Cultosマイニングのアンロックに必要な処理
                        const cultosminer = document.getElementById('cultosminer');
                        const cultosColumn = document.getElementById('cultosColumn');

                        if (cultosminer) {
                            cultosminer.classList.remove('cultosminer-disabled');
                        }
                        if (cultosColumn) {
                            cultosColumn.classList.remove('cultos-hidden');
                        }

                        // Cultosマイニング機能の初期化
                        if (!gameState.hasOwnProperty('cultos')) {
                            gameState.cultos = 0;
                            gameState.cultosRate = 0;
                        }
                        break;
                    case "Cosmic Alignment":
                        gameState.cosmicAlignmentBonus = 1 + (0.1 * multiplier);
                        break;
                    case "Forbidden Ritual":
                        for (let monster in gameState.monsters) {
                            gameState.monsters[monster].sourceEfficiency *= (1 + 0.4 * multiplier);
                        }
                        break;
                    case "Hermetic Teachings":
                        gameState.followerEfficiency *= (1 + 0.3 * multiplier);
                        break;
                    case "Cosmic Insight":
                        gameState.followerEfficiency *= (1 + 0.35 * multiplier);
                        for (let monster in gameState.monsters) {
                            gameState.monsters[monster].sourceEfficiency *= (1 + 0.35 * multiplier);
                            gameState.monsters[monster].miasmaEfficiency *= (1 + 0.35 * multiplier);
                        }
                        break;
                    case "Astral Projection":
                        gameState.astralProjectionRate = 0.03 * multiplier;
                        break;
                    case "Dimensional Rift":
                        for (let upgrade of gameState.upgrades) {
                            if (upgrade !== "Dimensional Rift") {
                                applyUpgrade(upgrade, 1 + 0.5 * multiplier);
                            }
                        }
                        break;
                    case "Necronomicon Fragment":
                        for (let monster in gameState.monsters) {
                            gameState.monsters[monster].sourceEfficiency *= (1 + 0.5 * multiplier);
                            gameState.monsters[monster].miasmaEfficiency *= (1 + 0.5 * multiplier);
                        }
                        break;
                    case "Psychic Attunement":
                        for (let monster in gameState.monsters) {
                            gameState.monsters[monster].miasmaEfficiency *= (1 + 0.3 * multiplier);
                        }
                        break;
                    case "Quantum Entanglement":
                        gameState.quantumEntanglementBonus = 0.05 * multiplier;
                        break;
                    case "Temporal Manipulation":
                        gameState.temporalManipulationBonus = 1 + (0.2 * multiplier);
                        break;
                    case "Eldritch Evolution":
                        gameState.eldritchEvolutionRate = 0.001 * multiplier;
                        break;
                }
            }

            function updateUpgradeGrid() {
                const grid = document.getElementById('upgradeGrid');
                if (!grid) return;

                const sourceCount = Math.floor(gameState.source);

                // 既存のカードを一時的に保存
                const existingCards = {};
                grid.querySelectorAll('.upgrade-card').forEach(card => {
                    const upgradeName = card.id.replace('upgrade-', '');
                    existingCards[upgradeName] = card;
                });

                // upgradeOrderに従ってアップグレードを並べ替え
                for (let upgrade of upgradeOrder) {
                    // 既に購入済みの場合はスキップ
                    if (gameState.upgrades.includes(upgrade)) {
                        const existingCard = document.getElementById(`upgrade-${upgrade}`);
                        if (existingCard) {
                            existingCard.remove();
                        }
                        continue;
                    }

                    let card = existingCards[upgrade];
                    if (!card) {
                        card = document.createElement('div');
                        card.id = `upgrade-${upgrade}`;
                        card.className = 'upgrade-card';

                        // tooltipのコンテンツを作成
                        const tooltipText = getUpgradeEffectDescription(upgrade);

                        card.innerHTML = `
                <div class="upgrade-card-header">
                    <h3>
                        <span class="upgrade-symbol" title="${tooltipText}">${upgradeSymbols[upgrade] || ''}</span>
                        ${upgrade}
                    </h3>
                    <div class="upgrade-cost">Cost: </div>
                </div>
                <div class="upgrade-description">${upgradeEffects[upgrade]}</div>
                <div class="unlock-requirement"></div>
                <button class="buy-upgrade-btn" data-upgrade="${upgrade}" disabled>Purchase</button>
            `;
                        grid.appendChild(card);
                    }

                    // アンロック状態の確認
                    const isUnlocked = checkUnlockCondition('upgrades', upgrade);
                    card.classList.toggle('locked', !isUnlocked);
                    card.classList.toggle('unlocked', isUnlocked);

                    // アンロック条件の表示を更新
                    const unlockReqElement = card.querySelector('.unlock-requirement');
                    if (unlockReqElement) {
                        const unlockDesc = getUnlockDescription('upgrades', upgrade);
                        if (unlockReqElement.textContent !== unlockDesc) {
                            unlockReqElement.textContent = unlockDesc;
                            unlockReqElement.style.display = isUnlocked ? 'none' : 'block';
                        }
                    }

                    // コストと購入ボタンの更新
                    const cost = Math.floor(baseCosts[upgrade] * (gameState.upgradeCostMultiplier || 1));
                    const costElement = card.querySelector('.upgrade-cost');
                    if (costElement) {
                        costElement.textContent = `Cost: ${formatNumber(cost)} source`;
                    }

                    const button = card.querySelector('.buy-upgrade-btn');
                    if (button) {
                        const canAfford = sourceCount >= cost && isUnlocked;
                        button.disabled = !canAfford;
                        button.classList.toggle('button-enabled', canAfford);
                        button.classList.toggle('button-disabled', !canAfford);
                    }
                }
            }

            function updateUpgradeCards() {
                const grid = document.getElementById('upgradeGrid');
                if (!grid) return;

                const sourceCount = Math.floor(gameState.source);

                // Ensure upgradeOrder exists and is an array
                if (!Array.isArray(upgradeOrder)) {
                    console.error('upgradeOrder is not properly defined');
                    return;
                }

                // Clear existing cards first
                grid.innerHTML = '';

                // Iterate through upgrade order
                for (let upgrade of upgradeOrder) {
                    // Skip if already purchased
                    if (gameState.upgrades && gameState.upgrades.includes(upgrade)) continue;

                    const card = document.createElement('div');
                    card.id = `upgrade-${upgrade}`;
                    card.className = 'upgrade-card';

                    // Get upgrade definition safely
                    const upgradeData = upgradeDefinitions[upgrade] || {
                        cost: baseCosts[upgrade] || 100,
                        description: upgradeEffects[upgrade] || 'No description available'
                    };

                    // Safely get cost with multiplier
                    const cost = Math.floor((upgradeData.cost || baseCosts[upgrade] || 100) *
                        (gameState.upgradeCostMultiplier || 1));

                    // Check unlock condition
                    const isUnlocked = checkUnlockCondition('upgrades', upgrade);
                    const canAfford = sourceCount >= cost && isUnlocked;

                    // Create card HTML
                    card.innerHTML = `
            <div class="upgrade-card-header">
                <h3>${upgradeSymbols[upgrade] || ''} ${upgrade}</h3>
                <div class="upgrade-cost">Cost: ${formatNumber(cost)} source</div>
            </div>
            <div class="upgrade-description">${upgradeData.description}</div>
            ${!isUnlocked ? `<div class="unlock-requirement">${getUnlockDescription('upgrades', upgrade)}</div>` : ''}
            <button onclick="buyUpgrade('${upgrade}')" ${!canAfford ? 'disabled' : ''}>Purchase</button>
        `;

                    // Add appropriate classes
                    card.classList.toggle('locked', !isUnlocked);
                    card.classList.toggle('unlocked', isUnlocked);

                    grid.appendChild(card);
                }

                // Update upgrade symbols
                updateUpgradeSymbols();
            }

            function checkUnlockCondition(type, name) {
                if (gameState.unlockedContent[type].has(name)) {
                    return true;
                }
                const condition = unlockConditions[type]?.[name];
                if (!condition) return false;
                if (condition.isUnlocked) return true;

                const requirement = condition.requirement;
                if (!requirement) return false;

                // アドベンチャラーのレベル要件チェック
                if (requirement.adventurers) {
                    for (const [advName, reqData] of Object.entries(requirement.adventurers)) {
                        const adventurer = gameState.adventurers.find(adv => adv.name === advName);
                        // ここで reqData.level を使用するように修正
                        if (!adventurer || adventurer.level < reqData.level) {
                            return false;
                        }
                    }
                }

                // Check each requirement type
                if (requirement.monsters) {
                    for (const [monsterType, count] of Object.entries(requirement.monsters)) {
                        if (!gameState.monsters[monsterType] || gameState.monsters[monsterType].count < count) {
                            return false;
                        }
                    }
                }

                if (requirement.upgrades) {
                    for (const upgrade of requirement.upgrades) {
                        if (!gameState.upgrades.includes(upgrade)) {
                            return false;
                        }
                    }
                }

                if (requirement.monsterTypes) {
                    const uniqueMonsters = Object.values(gameState.monsters)
                        .filter(monster => monster.count > 0).length;
                    if (uniqueMonsters < requirement.monsterTypes) {
                        return false;
                    }
                }

                if (requirement.monsterLevel) {
                    const hasHighLevelMonster = Object.values(gameState.monsters)
                        .some(monster => monster.level >= requirement.monsterLevel);
                    if (!hasHighLevelMonster) {
                        return false;
                    }
                }

                return true;
            }

            function calculateUpgradeBoost() {
                let boost = 1;

                // 各アップグレードの効果を適用
                if (gameState.upgrades.includes('Hiroshi Sakamoto`s Paper')) {
                    boost *= 1.5; // 基本ボーナス
                }
                // 他のアップグレードの効果も必要に応じて追加

                return boost;
            }

            function canAffordUpgrade(upgradeId) {
                const cost = Math.floor((upgradeDefinitions[upgradeId]?.cost || baseCosts[upgradeId] || 100) *
                    (gameState.upgradeCostMultiplier || 1));
                return gameState.source >= cost && !gameState.upgrades.includes(upgradeId);
            }

            // アップグレード効果の説明を取得する関数
            function getUpgradeEffectDescription(upgradeName) {
                const upgrade = upgradeDefinitions[upgradeName];
                if (!upgrade) return 'Unknown upgrade';

                switch (upgrade.type) {
                    case 'sourceEfficiency':
                        return `Increases source production by ${(upgrade.effect * 100).toFixed(1)}%`;
                    case 'miasmaEfficiency':
                        return `Increases miasma production by ${(upgrade.effect * 100).toFixed(1)}%`;
                    case 'followerEfficiency':
                        return `Increases follower efficiency by ${(upgrade.effect * 100).toFixed(1)}%`;
                    case 'monsterEfficiency':
                        return `Increases all monster efficiency by ${(upgrade.effect * 100).toFixed(1)}%`;
                    case 'cultosMiner':
                        return `Unlocks the ability to use Cultos Miner`;
                    case 'cosmicAlignment':
                        return `Increases all production by ${(upgrade.effect * 100).toFixed(1)}% when followers match monsters`;
                    case 'astralProjection':
                        return `Generates ${(upgrade.effect * 100).toFixed(1)}% of your source per second`;
                    case 'quantumEntanglement':
                        return `Increases all production by ${(upgrade.effect * 100).toFixed(1)}% when having paired monsters`;
                    case 'temporalManipulation':
                        return `Multiplies all production by ${upgrade.effect.toFixed(2)}x`;
                    case 'eldritchEvolution':
                        return `Monsters gain ${(upgrade.effect * 100).toFixed(1)}% efficiency every minute`;
                    default:
                        return upgrade.description || 'Effect unknown';
                }
            }

            function checkAdventurerUnlock(adventurerName) {
                const condition = unlockConditions.adventurers[adventurerName];
                if (!condition || condition.isUnlocked) return true;

                const req = condition.requirement;
                if (!req) return false;

                // ミアスマの要件チェック
                if (req.miasma && gameState.miasma < req.miasma) return false;

                // アドベンチャラーのレベル要件チェック
                if (req.adventurers) {
                    for (const [reqName, reqLevel] of Object.entries(req.adventurers)) {
                        const adventurer = gameState.adventurers.find(a => a.name === reqName);
                        if (!adventurer || adventurer.level < reqLevel.level) return false;
                    }
                }

                // モンスターの数要件チェック
                if (req.monsters) {
                    for (const [monsterName, count] of Object.entries(req.monsters)) {
                        if (!gameState.monsters[monsterName] || gameState.monsters[monsterName].count < count) return false;
                    }
                }

                return true;
            }

            // アンロック状態を更新する関数
            function updateAdventurerUnlocks() {
                gameState.adventurers.forEach(adventurer => {
                    if (!gameState.unlockedContent.adventurers.has(adventurer.name)) {
                        if (checkAdventurerUnlock(adventurer.name)) {
                            gameState.unlockedContent.adventurers.add(adventurer.name);
                            logAction(`New Adventurer Unlocked: ${adventurer.name}!`);
                        }
                    }
                });
            }

            function updateAdventurerStates() {
                const currentTime = gamePaused ? lastFrameTime : Date.now();

                for (const [index, adventurer] of gameState.adventurers.entries()) {
                    // アドベンチャラーがアンロックされているか確認
                    const isUnlocked = gameState.unlockedContent.adventurers.has(adventurer.name);
                    if (!isUnlocked) continue;

                    // クールダウンの確認と更新
                    if (adventurer.cooldownEndTime > 0) {
                        if (!gamePaused && currentTime >= adventurer.cooldownEndTime) {
                            // クールダウン終了時の処理
                            if (adventurer.isMad) {
                                adventurer.isMad = false;
                                logAction(`${adventurer.name} has returned to sanity!`);
                            }
                            adventurer.cooldownEndTime = 0;
                        }
                    }

                    // アドベンチャラーカードの更新
                    const adventurerElement = document.getElementById(`adventurer-${index}`);
                    if (adventurerElement) {
                        // クールダウン表示の更新
                        const cooldownDisplay = adventurerElement.querySelector('.cooldown-status');
                        if (cooldownDisplay) {
                            if (adventurer.cooldownEndTime > currentTime) {
                                const remainingTime = (adventurer.cooldownEndTime - currentTime) / timeAcceleration;
                                cooldownDisplay.textContent = formatTime(remainingTime / 1000);
                            } else {
                                cooldownDisplay.textContent = 'Ready';
                            }
                        }

                        // ステータス表示の更新
                        const statusDisplay = adventurerElement.querySelector('.adventurer-status');
                        if (statusDisplay) {
                            if (adventurer.isMad) {
                                statusDisplay.textContent = 'Mad';
                            } else if (adventurer.cooldownEndTime > currentTime) {
                                statusDisplay.textContent = 'Cooling Down';
                            } else {
                                statusDisplay.textContent = 'Ready';
                            }
                        }

                        // マッドネスボタンの更新
                        const madnessButton = adventurerElement.querySelector('.madness-btn');
                        if (madnessButton) {
                            const canAttemptMadness = !adventurer.isMad &&
                                adventurer.cooldownEndTime <= currentTime &&
                                gameState.miasma >= adventurer.miasmaRequired;

                            madnessButton.disabled = !canAttemptMadness || gamePaused;
                        }
                    }
                }
            }

            function updateAdventurerCards() {
                const adventurerContainer = document.getElementById('adventurers');
                if (!adventurerContainer) return;

                // 各アドベンチャラーカードの更新
                for (let adventurer of gameState.adventurers) {
                    const card = document.getElementById(`adventurer-${adventurer.name.replace(/\s+/g, '-')}`);
                    if (!card) continue;

                    // アンロック状態の確認
                    const isUnlocked = checkUnlockCondition('adventurers', adventurer.name);

                    // クールダウン状態の確認
                    const now = Date.now();
                    const isOnCooldown = now < adventurer.cooldownEndTime;
                    const isMad = adventurer.isMad;

                    // クールダウン残り時間の計算
                    let cooldownRemaining = 0;
                    if (isOnCooldown) {
                        cooldownRemaining = Math.ceil((adventurer.cooldownEndTime - now) / 1000);
                    }

                    // 各要素の更新
                    const levelElement = card.querySelector('.adventurer-level');
                    if (levelElement) {
                        levelElement.textContent = `Level ${adventurer.level}`;
                    }

                    const productionElement = card.querySelector('.adventurer-production');
                    if (productionElement) {
                        const baseProduction = adventurer.baseFollowerProduction * Math.pow(1.1, adventurer.level - 1);
                        productionElement.textContent = `${formatNumber(baseProduction, 1)} followers/s`;
                    }

                    const madnessChanceElement = card.querySelector('.adventurer-madness-chance');
                    if (madnessChanceElement) {
                        madnessChanceElement.textContent = `${(adventurer.madnessChance * 100).toFixed(1)}% madness chance`;
                    }

                    const statusElement = card.querySelector('.adventurer-status');
                    if (statusElement) {
                        if (isMad) {
                            statusElement.textContent = 'Status: Mad';
                            statusElement.classList.add('status-mad');
                        } else if (isOnCooldown) {
                            statusElement.textContent = `Cooldown: ${cooldownRemaining}s`;
                            statusElement.classList.add('status-cooldown');
                        } else {
                            statusElement.textContent = 'Status: Ready';
                            statusElement.classList.add('status-ready');
                        }
                    }

                    // 探索ボタンの更新
                    const exploreButton = card.querySelector('.explore-btn');
                    if (exploreButton) {
                        const canExplore = !isOnCooldown && !isMad;
                        exploreButton.disabled = !canExplore;
                        exploreButton.classList.toggle('button-enabled', canExplore);
                        exploreButton.classList.toggle('button-disabled', !canExplore);
                    }

                    // 治療ボタンの更新
                    const healButton = card.querySelector('.heal-btn');
                    if (healButton) {
                        const healCost = Math.floor(100 * Math.pow(1.5, adventurer.level - 1));
                        healButton.textContent = `Heal (${healCost} source)`;
                        const canHeal = isMad && gameState.source >= healCost;
                        healButton.disabled = !isMad || !canHeal;
                        healButton.classList.toggle('button-enabled', canHeal && isMad);
                        healButton.classList.toggle('button-disabled', !canHeal || !isMad);
                    }

                    // レベルアップボタンの更新
                    const levelUpButton = card.querySelector('.level-up-btn');
                    if (levelUpButton) {
                        const levelUpCost = Math.floor(200 * Math.pow(2, adventurer.level - 1));
                        levelUpButton.textContent = `Level Up (${levelUpCost} source)`;
                        const canLevelUp = gameState.source >= levelUpCost;
                        levelUpButton.disabled = !canLevelUp;
                        levelUpButton.classList.toggle('button-enabled', canLevelUp);
                        levelUpButton.classList.toggle('button-disabled', !canLevelUp);
                    }

                    // プログレスバーの更新
                    const progressBar = card.querySelector('.cooldown-progress-bar');
                    if (progressBar && isOnCooldown) {
                        const percentage = ((adventurer.cooldownEndTime - now) / adventurer.cooldownTime) * 100;
                        progressBar.style.width = `${100 - percentage}%`;
                    }

                    // アンロック状態の更新
                    card.classList.toggle('locked', !isUnlocked);
                    card.classList.toggle('unlocked', isUnlocked);
                    card.classList.toggle('mad', isMad);
                    card.classList.toggle('on-cooldown', isOnCooldown);
                }
            }

            // updateMadnessTable関数を修正
            function updateMadnessTable() {
                const adventurersContainer = document.getElementById('adventurers');
                if (!adventurersContainer) {
                    console.error("Adventurers container not found");
                    return;
                }

                const currentTime = Date.now();
                const miasmaCount = Math.floor(gameState.miasma);

                gameState.adventurers.forEach((adventurer, index) => {
                    let adventurerElement = document.getElementById(`adventurer-${index}`);
                    if (!adventurerElement) {
                        // 新しいアドベンチャー要素の作成
                        adventurerElement = document.createElement('div');
                        adventurerElement.id = `adventurer-${index}`;
                        adventurerElement.className = 'adventurer';
                        adventurerElement.innerHTML = `
                <h3>${adventurer.name}</h3>
                <div class="ascii-art">${asciiArt[adventurer.name]}</div>
                <p class="level-display">Level: <span class="adventurer-level">0</span></p>
                <p class="miasma-required">Miasma Required: <span class="miasma-requirement">0</span></p>
                <p class="production-display">Follower Production: <span class="follower-production">0</span>/sec</p>
                <p class="chance-display">Madness Chance: <span class="madness-chance">0</span>%</p>
                <p class="status-display">Status: <span class="adventurer-status">Ready</span></p>
                <button class="madness-btn" data-index="${index}">Attempt Madness</button>
                <p class="cooldown-display">Cooldown: <span class="cooldown-status">Ready</span></p>
                <div class="unlock-requirement"></div>
            `;
                        adventurersContainer.appendChild(adventurerElement);
                    }

                    // ロック状態の更新（永続的アンロックを考慮）
                    const isUnlocked = gameState.unlockedContent.adventurers.has(adventurer.name);
                    adventurerElement.classList.toggle('locked', !isUnlocked);

                    if (!isUnlocked) {
                        // ロック状態の表示
                        const unlockDesc = getUnlockDescription('adventurers', adventurer.name);
                        const requirementElem = adventurerElement.querySelector('.unlock-requirement');
                        if (requirementElem) {
                            requirementElem.textContent = unlockDesc;
                            requirementElem.style.display = 'block';
                        }
                    } else {
                        // アンロック状態の表示
                        const requirementElem = adventurerElement.querySelector('.unlock-requirement');
                        if (requirementElem) {
                            requirementElem.style.display = 'none';
                        }
                    }

                    // クールダウンと状態の更新
                    const cooldownRemaining = Math.max(0, adventurer.cooldownEndTime - currentTime);
                    const adjustedCooldown = cooldownRemaining / timeAcceleration; // tick speedで調整
                    const isReady = cooldownRemaining === 0 && !adventurer.isMad;
                    const canAttemptMadness = isUnlocked && miasmaCount >= adventurer.miasmaRequired && isReady;

                    // 各要素の更新
                    updateElementText(adventurerElement, '.adventurer-level', adventurer.level);
                    updateElementText(adventurerElement, '.miasma-requirement', formatNumber(Math.floor(adventurer.miasmaRequired)));
                    updateElementText(adventurerElement, '.follower-production', formatNumber(adventurer.followerProduction, 1));
                    updateElementText(adventurerElement, '.madness-chance', (calculateFinalMadnessChance(adventurer) * 100).toFixed(0));

                    // 状態表示の更新
                    const statusText = adventurer.isMad ? 'Mad' :
                        (cooldownRemaining > 0 ? 'Cooldown' :
                            (isUnlocked ? 'Ready' : 'Locked'));
                    updateElementText(adventurerElement, '.adventurer-status', statusText);

                    // クールダウン表示の更新
                    const cooldownText = cooldownRemaining > 0 ?
                        formatTime(adjustedCooldown / 1000) : // tick speedで調整された時間を表示
                        (isUnlocked ? 'Ready' : 'Locked');
                    updateElementText(adventurerElement, '.cooldown-status', cooldownText);

                    // ASCII アートのスタイル更新
                    const asciiArtElem = adventurerElement.querySelector('.ascii-art');
                    if (asciiArtElem) {
                        asciiArtElem.classList.toggle('red-filter', adventurer.isMad);
                    }

                    // マッドネスボタンの更新を修正
                    const madnessBtn = adventurerElement.querySelector('.madness-btn');
                    if (madnessBtn) {
                        const isOnCooldown = currentTime < adventurer.cooldownEndTime;
                        const hasEnoughMiasma = miasmaCount >= adventurer.miasmaRequired;
                        const canAttemptMadness = isUnlocked && !isOnCooldown && !adventurer.isMad && hasEnoughMiasma;

                        // ボタンの状態を更新
                        madnessBtn.disabled = !canAttemptMadness;
                        madnessBtn.classList.toggle('button-enabled', canAttemptMadness);
                        madnessBtn.classList.toggle('button-disabled', !canAttemptMadness);

                        // ボタンのテキストとツールチップを更新
                        let btnText = 'Attempt Madness';
                        let tooltipText = '';

                        if (!isUnlocked) {
                            tooltipText = 'Adventurer is locked';
                            btnText = 'Locked';
                        } else if (adventurer.isMad) {
                            tooltipText = 'Already mad';
                            btnText = 'Currently Mad';
                        } else if (isOnCooldown) {
                            tooltipText = 'Cooling Down';
                            btnText = 'Cooling Down';
                        } else if (!hasEnoughMiasma) {
                            tooltipText = `Need ${formatNumber(Math.ceil(adventurer.miasmaRequired - miasmaCount))} more miasma`;
                            btnText = 'Not Enough Miasma';
                        }

                        madnessBtn.textContent = btnText;
                        madnessBtn.title = tooltipText;
                    }

                    // 進行状態に応じたスタイル更新
                    adventurerElement.classList.toggle('active', adventurer.isMad);
                    adventurerElement.classList.toggle('cooldown', cooldownRemaining > 0);
                    adventurerElement.classList.toggle('available', canAttemptMadness);

                    // レベル表示のスタイル更新
                    const levelDisplay = adventurerElement.querySelector('.level-display');
                    if (levelDisplay) {
                        levelDisplay.classList.toggle('max-level', adventurer.level >= 10);
                    }

                    // プログレスバーの更新（オプション）
                    const progressBar = adventurerElement.querySelector('.madness-progress');
                    if (progressBar) {
                        const progress = Math.min(100, (miasmaCount / adventurer.miasmaRequired) * 100);
                        progressBar.style.width = `${progress}%`;
                        progressBar.classList.toggle('full', progress >= 100);
                    }
                });
            }

            function calculateMadnessChance(adventurer) {
                let finalChance = adventurer.madnessChance;

                // This Manの特殊能力による補正（上限20%までに制限）
                const maxMadnessBonus = 0.20; // 最大20%の補正
                const thisManBonus = (gameState.madnessChanceMultiplier || 1) - 1;
                const clampedBonus = Math.min(thisManBonus, maxMadnessBonus);

                finalChance *= (1 + clampedBonus);

                // 契約効果の適用
                if (gameState.pacts?.commonMultiplier) {
                    finalChance *= gameState.pacts.commonMultiplier;
                }

                // 最終的な確率を0～1の範囲に制限
                return Math.min(Math.max(finalChance, 0), 1);
            }

            function calculateFinalMadnessChance(adventurer) {
                let finalChance = adventurer.madnessChance;

                // モンスターの特殊能力による影響を計算（重複適用を防ぐ）
                let totalMonsterBonus = 0;
                for (let monsterType in gameState.monsters) {
                    const monster = gameState.monsters[monsterType];
                    if (monster.count > 0 && monster.specialAbility?.effect?.type === 'madnessChance') {
                        const triggerCount = Math.floor(monster.count / monster.specialAbility.trigger);
                        if (triggerCount > 0) {
                            totalMonsterBonus += monster.specialAbility.effect.value * triggerCount;
                        }
                    }
                }

                // モンスターボーナスを一括適用
                finalChance *= (1 + totalMonsterBonus);

                // 契約効果の適用
                if (gameState.pacts?.commonMultiplier) {
                    finalChance *= gameState.pacts.commonMultiplier;
                }

                // 最終的な確率を0～1の範囲に制限
                return Math.min(Math.max(finalChance, 0), 1);
            }

            // ヘルパー関数：要素のテキストを安全に更新
            function updateElementText(parentElement, selector, text) {
                const element = parentElement.querySelector(selector);
                if (element) {
                    element.textContent = text;
                } else {
                    console.warn(`Element not found: ${selector}`);
                }
            }


            // attemptMadness関数の修正
            function attemptMadness(index) {
                // ゲームが一時停止中の場合は処理をスキップ
                if (gamePaused) {
                    return;
                }

                const currentTime = Date.now();
                const adventurer = gameState.adventurers[index];


                if (!adventurer || adventurer.cooldownEndTime > currentTime) {
                    return;
                }

                // アドベンチャラーのロック状態をチェック
                if (!checkUnlockCondition('adventurers', adventurer.name)) {
                    debug(`Attempted to interact with locked adventurer: ${adventurer.name}`);
                    logAction(`Cannot attempt madness with ${adventurer.name} - not yet unlocked`);
                    return;
                }

                // ミアスマのコストチェック
                if (gameState.miasma < adventurer.miasmaRequired) {
                    return;
                }

                gameState.miasma -= adventurer.miasmaRequired;

                // madnessChanceの計算を修正
                const baseChance = adventurer.madnessChance;
                let finalChance = calculateFinalMadnessChance(adventurer);

                debug(`Attempting madness with chance: ${finalChance}`);

                // モンスターの特殊能力による影響を計算
                for (let monsterType in gameState.monsters) {
                    if (gameState.monsters[monsterType].count > 0) {
                        const monster = gameState.monsters[monsterType];
                        if (monster.specialAbility &&
                            monster.specialAbility.effect.type === 'madnessChance') {
                            const triggerCount = Math.floor(monster.count / monster.specialAbility.trigger);
                            if (triggerCount > 0) {
                                finalChance *= (1 + monster.specialAbility.effect.value * triggerCount);
                            }
                        }
                    }
                }

                // 契約効果の適用
                if (gameState.pacts?.commonMultiplier) {
                    finalChance *= gameState.pacts.commonMultiplier;
                }

                // madnessChanceMultiplierの適用（存在する場合）
                if (gameState.madnessChanceMultiplier) {
                    finalChance *= gameState.madnessChanceMultiplier;
                }

                debug(`Attempting madness with chance: ${finalChance}`);

                if (Math.random() < finalChance) {
                    // 狂気成功の処理
                    let madnessCooldown = adventurer.baseCooldown * (1 + (adventurer.level * 0.1));
                    madnessCooldown = Math.max(500, madnessCooldown * timeAcceleration);
                    adventurer.cooldownEndTime = currentTime + madnessCooldown;
                    adventurer.isMad = true;
                    adventurer.level++;
                    adventurer.followerProduction *= 1.5;
                    adventurer.miasmaRequired *= 1.5;
                    adventurer.madnessChance *= 0.9;

                    const followerReward = Math.floor(adventurer.followerReward * Math.sqrt(adventurer.level));
                    gameState.followers += followerReward;

                    // セリフを表示する処理
                    const adventurerElement = document.querySelector(`#adventurer-${index}`);
                    if (adventurerElement) {
                        const dialogueList = dialogues.adventurers[adventurer.name];
                        if (dialogueList && dialogueList.mad && dialogueList.mad.length > 0) {
                            const madDialogues = dialogueList.mad;
                            const randomText = madDialogues[Math.floor(Math.random() * madDialogues.length)];
                            showSpeechBubble(adventurerElement, randomText, 5000, 'mad');
                        }
                    }

                    // 統計の更新
                    if (gameState.statistics) {
                        gameState.statistics.successfulMadness = (gameState.statistics.successfulMadness || 0) + 1;
                    }

                    logAction(`${adventurer.name} went mad! Level up to ${adventurer.level}. Generating ${formatNumber(adventurer.followerProduction, 1)} followers/sec. Gained ${formatNumber(followerReward)} followers.`);
                } else {
                    // 失敗時の処理
                    let resistanceCooldown = Math.max(500, (adventurer.baseCooldown * (1 + (adventurer.level * 0.1))) / 2);

                    // モンスターの特殊能力による影響を計算
                    for (let monsterType in gameState.monsters) {
                        resistanceCooldown = applySpecialAbilityEffect(monsterType, 'adventurerResistanceRecoveryTime', resistanceCooldown);
                    }

                    resistanceCooldown = Math.max(500, resistanceCooldown * timeAcceleration);
                    adventurer.cooldownEndTime = currentTime + resistanceCooldown;

                    // レジスト時のセリフを表示
                    const adventurerElement = document.querySelector(`#adventurer-${index}`);
                    if (adventurerElement) {
                        const dialogueList = dialogues.adventurers[adventurer.name];
                        if (dialogueList && dialogueList.resist && dialogueList.resist.length > 0) {
                            const resistDialogues = dialogueList.resist;
                            const randomText = resistDialogues[Math.floor(Math.random() * resistDialogues.length)];
                            showSpeechBubble(adventurerElement, randomText, 3000, 'resist');
                        }
                    }

                    logAction(`${adventurer.name} resisted the madness.`);
                }

                // 統計の更新
                if (gameState.statistics) {
                    gameState.statistics.totalMadnessAttempts = (gameState.statistics.totalMadnessAttempts || 0) + 1;
                }

                updateMadnessTable();
                updateResourceDisplay();
            }

            function handleMadnessAttempt(event) {
                if (event.target.classList.contains('madness-btn') && !event.target.disabled) {
                    const index = parseInt(event.target.dataset.index);
                    const adventurer = gameState.adventurers[index];
                    const currentTime = Date.now();

                    if (gameState.miasma >= adventurer.miasmaRequired && adventurer.cooldownEndTime <= currentTime) {
                        attemptMadness(index);
                    } else {
                        //console.log(`Madness attempt prevented. Miasma: ${gameState.miasma}, Required: ${adventurer.miasmaRequired}, Cooldown: ${adventurer.cooldownEndTime - currentTime}ms`);
                    }
                    event.preventDefault();
                }
            }

            // イベントリスナーの設定
            const adventurersContainer = document.getElementById('adventurers');
            if (adventurersContainer) {
                adventurersContainer.addEventListener('click', handleMadnessAttempt);
            }

            function calculateTotalProduction() {
                let sourceProduction = 0;
                let miasmaProduction = 0;

                // モンスターからの生産
                for (let monsterName in gameState.monsters) {
                    const monster = gameState.monsters[monsterName];
                    sourceProduction += monster.count * monster.sourceEfficiency;
                    miasmaProduction += monster.count * monster.miasmaEfficiency;
                }

                // アドベンチャラーからの生産
                for (let adventurer of gameState.adventurers) {
                    if (adventurer.isUnlocked && !adventurer.isMad) {
                        sourceProduction += adventurer.baseFollowerProduction * Math.pow(1.1, adventurer.level - 1);
                    }
                }

                return sourceProduction + miasmaProduction;
            }

            function calculateBaseProduction() {
                let sourceProduction = gameState.followers * gameState.followerEfficiency;
                let miasmaProduction = 0;
                let followerProduction = 0;

                // モンスターからの生産量を計算
                for (let monster in gameState.monsters) {
                    const monsterData = gameState.monsters[monster];
                    sourceProduction += monsterData.count * monsterData.sourceEfficiency;
                    miasmaProduction += monsterData.count * monsterData.miasmaEfficiency;
                }

                // アドベンチャラーからのフォロワー生産を計算
                for (const adventurer of gameState.adventurers) {
                    if (!adventurer.isMad && gameState.unlockedContent.adventurers.has(adventurer.name)) {
                        // レベルに応じた生産量の計算
                        const baseProduction = adventurer.baseFollowerProduction * Math.pow(1.1, adventurer.level - 1);
                        followerProduction += baseProduction;
                    }
                }

                // 契約効果の適用
                if (gameState.pacts?.active) {
                    const multiplier = gameState.pacts.commonMultiplier || 1;
                    followerProduction *= multiplier;
                }

                return { sourceProduction, miasmaProduction, followerProduction };
            }

            // 必要最低follower数を計算する関数
            function calculateMinimumFollowers() {
                const baseProduction = calculateBaseProduction();
                const sourceRate = baseProduction.sourceProduction;
                const miasmaRate = baseProduction.miasmaProduction;

                // 生産量に基づいて必要最低数を計算
                const sourceBasedMin = Math.floor(sourceRate / 1000);
                const miasmaBasedMin = Math.floor(miasmaRate / 500);

                return Math.max(sourceBasedMin, miasmaBasedMin, 1); // 最低1人は必要
            }

            // 生産量ペナルティを計算する関数
            function calculateProductionPenalty() {
                const currentFollowers = gameState.followers;
                const minimumRequired = calculateMinimumFollowers();

                return currentFollowers < minimumRequired ? 0.3 : 1; // 不足時は生産量3/10
            }

            // 最終的な生産量の計算関数
            function calculateResourceProduction() {
                // 基本生産量の初期化
                let sourceProduction = gameState.followers * gameState.followerEfficiency;
                let miasmaProduction = 0;
                let followerProduction = 0;

                // シナジー効果を計算（加算方式）
                const synergyEffects = {
                    source: 0,
                    miasma: 0,
                    all: 0
                };

                // モンスターのシナジー効果を計算
                for (const [monsterType, monster] of Object.entries(gameState.monsters)) {
                    if (monster.count > 0 && monster.synergy) {
                        const partnerMonster = gameState.monsters[monster.synergy.partner];
                        if (partnerMonster && partnerMonster.count > 0) {
                            const synergyBonus = monster.synergy.effect;
                            switch (monster.synergy.type) {
                                case 'source':
                                    synergyEffects.source += synergyBonus;
                                    break;
                                case 'miasma':
                                    synergyEffects.miasma += synergyBonus;
                                    break;
                                case 'all':
                                    synergyEffects.all += synergyBonus;
                                    break;
                            }
                        }
                    }
                }

                // モンスターからの生産量を計算
                for (const [monsterType, monster] of Object.entries(gameState.monsters)) {
                    if (monster.count > 0) {
                        // 基本生産量
                        let monsterSourceProduction = monster.count * monster.sourceEfficiency;
                        let monsterMiasmaProduction = monster.count * monster.miasmaEfficiency;

                        // シナジーボーナスの適用（加算方式）
                        const totalSourceBonus = 1 + synergyEffects.source + synergyEffects.all;
                        const totalMiasmaBonus = 1 + synergyEffects.miasma + synergyEffects.all;

                        monsterSourceProduction *= totalSourceBonus;
                        monsterMiasmaProduction *= totalMiasmaBonus;

                        sourceProduction += monsterSourceProduction;
                        miasmaProduction += monsterMiasmaProduction;
                    }
                }

                // アドベンチャラーからのフォロワー生産を計算
                for (const adventurer of gameState.adventurers) {
                    if (gameState.unlockedContent.adventurers.has(adventurer.name)) {
                        // クールダウン中かつ狂気状態の時のみ生産
                        const currentTime = Date.now();
                        const isOnCooldown = currentTime < adventurer.cooldownEndTime;

                        if (adventurer.isMad && isOnCooldown) {
                            // レベルボーナスを加算方式で計算
                            const levelBonus = 1 + (adventurer.level - 1) * 0.1; // 10%ずつ加算
                            followerProduction += adventurer.followerProduction * levelBonus; // followerProductionを使用
                        }
                    }
                }

                // グローバルボーナスの計算（加算方式）
                let globalBonus = 1;

                // Cosmic Alignment ボーナス
                if (gameState.cosmicAlignmentBonus) {
                    globalBonus += (gameState.cosmicAlignmentBonus - 1);
                }

                // Quantum Entanglement ボーナス
                if (gameState.quantumEntanglementBonus) {
                    globalBonus += gameState.quantumEntanglementBonus;
                }

                // Temporal Manipulation ボーナス
                if (gameState.temporalManipulationBonus) {
                    globalBonus += (gameState.temporalManipulationBonus - 1);
                }

                // Astral Projection ボーナス
                if (gameState.astralProjectionRate) {
                    globalBonus += gameState.astralProjectionRate;
                }

                // 契約効果の適用
                if (gameState.pacts?.active) {
                    const pactBonus = (gameState.pacts.commonMultiplier || 1) - 1;
                    globalBonus += pactBonus;
                }

                // Cultosボーナスの計算
                const cultosBonus = calculateCultosBonus() - 1;
                globalBonus += cultosBonus;

                // 生産ペナルティの計算
                const productionPenalty = calculateProductionPenalty();
                globalBonus *= productionPenalty;

                // 最終的な生産量の計算
                sourceProduction *= globalBonus;
                miasmaProduction *= globalBonus;
                followerProduction *= globalBonus;

                // 小数点以下を適切に処理
                return {
                    sourceProduction: Math.max(0, sourceProduction),
                    miasmaProduction: Math.max(0, miasmaProduction),
                    followerProduction: Math.max(0, followerProduction),
                    baseFollowerProduction: followerProduction / globalBonus // ペナルティ適用前の基本生産量
                };
            }

            // 表示を更新する関数
            function updateResourceDisplay() {
                const sourceCount = Math.floor(gameState.source);
                const miasmaCount = Math.floor(gameState.miasma);
                const baseProduction = calculateBaseProduction();
                const minimumFollowers = calculateMinimumFollowers();
                const penalty = calculateProductionPenalty();
                const finalProduction = calculateResourceProduction();

                // リソースカウントの更新
                document.getElementById('largeSourceCount').textContent = formatNumber(sourceCount, 3);
                document.getElementById('largeMiasmaCount').textContent = formatNumber(miasmaCount, 3);

                // 生産率の更新
                const sourcePerSecond = document.getElementById('largeSourcePerSecond');
                const miasmaPerSecond = document.getElementById('largeMiasmaPerSecond');

                sourcePerSecond.textContent = formatNumber(finalProduction.sourceProduction, 3);
                miasmaPerSecond.textContent = formatNumber(finalProduction.miasmaProduction, 3);

                // Cultosの表示を更新
                const cultosCount = document.querySelector('.cultos-count');
                const cultosHashRate = document.getElementById('cultosHashRate');

                if (cultosCount) {
                    cultosCount.textContent = formatNumber(gameState.cultos, 3);
                }
                if (cultosHashRate) {
                    cultosHashRate.textContent = formatHashRate(gameState.cultosRate);
                }

                // ペナルティ状態の視覚的表示
                if (penalty < 1) {
                    sourcePerSecond.classList.add('penalty');
                    miasmaPerSecond.classList.add('penalty');
                } else {
                    sourcePerSecond.classList.remove('penalty');
                    miasmaPerSecond.classList.remove('penalty');
                }

                // フォロワー情報の更新
                const followerSection = document.getElementById('followerSection');
                if (followerSection) {
                    const followerInfo = followerSection.querySelector('.follower-info') ||
                        document.createElement('div');
                    followerInfo.className = 'follower-info';

                    followerInfo.innerHTML = `
            <p>Current Followers: ${formatNumber(gameState.followers)}</p>
            <p class="${gameState.followers < minimumFollowers ? 'warning' : ''}">
                Minimum Required: ${formatNumber(minimumFollowers)}
                ${gameState.followers < minimumFollowers ?
                            `<br><span class="penalty-warning">
                        Production reduced to 33%<br>
                        Base production: ${formatNumber(baseProduction.sourceProduction)}/s<br>
                        Current production: ${formatNumber(finalProduction.sourceProduction)}/s
                    </span>` :
                            ''}
            </p>
        `;

                    if (!followerSection.querySelector('.follower-info')) {
                        followerSection.appendChild(followerInfo);
                    }
                }
                // Cultosの表示/非表示を制御
                updateCultosVisibility();
            }

            function updateGameState(deltaTime) {
                // 契約の効果を適用
                const baseMultiplier = timeAcceleration * (gameState.pacts?.tickSpeedMultiplier || 1);

                // 生産量の計算
                const production = calculateResourceProduction();

                // リソースの更新（時間とマルチプライヤーを適用）
                gameState.source += production.sourceProduction * deltaTime * baseMultiplier;
                gameState.miasma += production.miasmaProduction * deltaTime * baseMultiplier;

                // Cultos生産の更新
                const cultosRate = calculateCultosRate(deltaTime);
                gameState.cultos += cultosRate * deltaTime;

                // followerAccumulatorの初期化を確実に行う
                if (typeof gameState.followerAccumulator !== 'number') {
                    gameState.followerAccumulator = 0;
                }

                // フォロワーの累積処理
                if (production.followerProduction > 0) {
                    gameState.followerAccumulator += production.followerProduction * deltaTime * baseMultiplier;

                    if (gameState.followerAccumulator >= 1) {
                        const newFollowers = Math.floor(gameState.followerAccumulator);
                        gameState.followers += newFollowers;
                        gameState.followerAccumulator -= newFollowers;
                    }
                }

                // 最小フォロワー数の保証（契約効果）
                updatePactEffects();

                // その他のゲームシステムの更新
                updateAdventurerStates();
                applySpecialAbilities();
                checkPacts();
                updateUnlockSystem();
                sanitizeGameState();

                // 統計情報の更新
                if (gameState.statistics) {
                    gameState.statistics.totalSourceGenerated += production.sourceProduction * deltaTime * baseMultiplier;
                    gameState.statistics.totalMiasmaGenerated += production.miasmaProduction * deltaTime * baseMultiplier;
                    gameState.statistics.peakFollowers = Math.max(
                        gameState.statistics.peakFollowers || 0,
                        gameState.followers || 0
                    );
                }
            }

            // updateDisplay関数の修正
            function updateDisplay() {
                try {
                    Object.keys(UPDATE_INTERVALS).forEach(key => {
                        const now = Date.now();
                        if (now - lastUpdateTimes[key] >= UPDATE_INTERVALS[key]) {
                            switch (key) {
                                case 'monsterGrid':
                                    updateMonsterGrid();
                                    break;
                                case 'followerSection':
                                    updateFollowerSection();
                                    break;
                                case 'madnessTable':
                                    updateMadnessTable();
                                    break;
                                case 'upgradeGrid':
                                    updateUpgradeGrid();
                                    break;
                                case 'gameDetails':
                            }
                            lastUpdateTimes[key] = now;
                        }
                    });
                } catch (error) {
                    console.error('Error in updateDisplay:', error);
                }
            }

            // updateGameDetails 関数の追加
            function updateGameDetails() {
                const detailsDiv = document.getElementById('gameDetails');
                if (!detailsDiv) {
                    console.warn("Game details div not found");
                    return;
                }

                const followerBoost = 1 + (gameState.followers * 0.01);
                const monsterTypes = Object.values(gameState.monsters).filter(m => m.count > 0).length;
                const monsterSynergyBoost = 1 + (monsterTypes * 0.1);

                let detailsHTML = `
        <p><strong>Follower Efficiency:</strong> ${formatNumber(gameState.followerEfficiency, 2)}</p>
        <p><strong>Follower Boost:</strong> ${formatNumber(followerBoost, 2)}x</p>
        <p><strong>Monster Synergy Boost:</strong> ${formatNumber(monsterSynergyBoost, 2)}x</p>
        <p><strong>Cosmic Alignment Bonus:</strong> ${formatNumber(gameState.cosmicAlignmentBonus, 2)}x</p>
        <p><strong>Astral Projection Rate:</strong> ${formatNumber(gameState.astralProjectionRate * 100, 2)}%</p>
        <p><strong>Quantum Entanglement Bonus:</strong> ${formatNumber(gameState.quantumEntanglementBonus * 100, 2)}%</p>
        <p><strong>Temporal Manipulation Bonus:</strong> ${formatNumber(gameState.temporalManipulationBonus, 2)}x</p>
        <p><strong>Eldritch Evolution Rate:</strong> ${formatNumber(gameState.eldritchEvolutionRate * 100, 2)}%</p>
        <p><strong>Active Upgrades:</strong> ${gameState.upgrades.join(', ') || 'None'}</p>
        <h3>Monster Production:</h3>
    `;

                for (let monster in gameState.monsters) {
                    if (gameState.monsters[monster].count > 0) {
                        const production = gameState.monsters[monster].count * gameState.monsters[monster].sourceEfficiency * followerBoost * monsterSynergyBoost;
                        detailsHTML += `<p>${monster}: ${formatNumber(production, 1)} source/sec</p>`;
                    }
                }

                detailsDiv.innerHTML = detailsHTML;
            }

            function calculateMonsterEfficiency(monsterType) {
                const monster = gameState.monsters[monsterType];
                let sourceEfficiency = monster.sourceEfficiency;
                let miasmaEfficiency = monster.miasmaEfficiency;

                // Apply global multipliers
                const globalMultiplier = (gameState.pacts?.commonMultiplier || 1);

                // Apply Cosmic Alignment bonus if active
                if (gameState.cosmicAlignmentBonus) {
                    sourceEfficiency *= gameState.cosmicAlignmentBonus;
                    miasmaEfficiency *= gameState.cosmicAlignmentBonus;
                }

                // Apply Quantum Entanglement bonus if active
                if (gameState.quantumEntanglementBonus) {
                    sourceEfficiency *= (1 + gameState.quantumEntanglementBonus);
                    miasmaEfficiency *= (1 + gameState.quantumEntanglementBonus);
                }

                // Apply Temporal Manipulation bonus if active
                if (gameState.temporalManipulationBonus) {
                    sourceEfficiency *= gameState.temporalManipulationBonus;
                    miasmaEfficiency *= gameState.temporalManipulationBonus;
                }

                // Apply Eldritch Evolution bonus if active
                if (gameState.eldritchEvolutionRate && monster.evolutionTime) {
                    const evolutionBonus = 1 + (gameState.eldritchEvolutionRate *
                        Math.floor((Date.now() - monster.evolutionTime) / 60000));
                    sourceEfficiency *= evolutionBonus;
                    miasmaEfficiency *= evolutionBonus;
                }

                // Apply global multiplier from pacts
                sourceEfficiency *= globalMultiplier;
                miasmaEfficiency *= globalMultiplier;

                return {
                    sourceEfficiency,
                    miasmaEfficiency
                };
            }

            function updateMonsterGrid() {
                const grid = document.getElementById('monsterGrid');
                if (!grid) {
                    console.error("Monster grid not found");
                    return;
                }

                const sourceCount = Math.floor(gameState.source);
                const followerCount = gameState.followers;

                for (let monster of monsterOrder) {
                    let card = document.getElementById(`monster-${monster}`);
                    if (!card) {
                        card = document.createElement('div');
                        card.id = `monster-${monster}`;
                        card.className = 'monster-card';
                        card.innerHTML = `
                <div class="monster-card-header">
                    <h3>${monster} (<span class="header-count">0</span>)</h3>
                    <div class="monster-details">
                        <p>Total Source Production: <span class="monster-source-production"></span>/sec</p>
                        <p>Total Miasma Production: <span class="monster-miasma-production"></span>/sec</p>
                    </div>
                </div>
                <div class="monster-card-details expanded">
                    <div class="ascii-art">${asciiArt[monster]}</div>
                    <p>Count: <span class="monster-count"></span></p>
                    <p>Source Efficiency: <span class="monster-source-efficiency"></span></p>
                    <p>Miasma Efficiency: <span class="monster-miasma-efficiency"></span></p>
                    <div class="monster-details">
                        <p>Next Summon Cost: <span class="monster-next-cost"></span> source and <span class="monster-follower-cost"></span> followers</p>
                        <p>Time to Next Summon: <span class="monster-time-to-summon"></span></p>
                        <p>Synergy: <span class="monster-synergy"></span></p>
                        <p>Special Ability: <span class="monster-special-ability"></span></p>
                    </div>
                </div>
                <div class="summon-progress-bar">
                    <div class="resource-progress source-progress"></div>
                    <div class="resource-progress follower-progress"></div>
                </div>
                <button class="summon-monster-btn" data-monster="${monster}">Summon ${monster}</button>
                <div class="unlock-requirement"></div>`;
                        grid.appendChild(card);

                        // ヘッダークリックイベントの設定
                        const header = card.querySelector('.monster-card-header');
                        const details = card.querySelector('.monster-card-details');
                        const summonBtn = card.querySelector('.summon-monster-btn');
                        summonBtn.addEventListener('click', () => summonMonster(monster));
                    }

                    const monsterData = gameState.monsters[monster];
                    if (!monsterData) {
                        console.error(`No data found for monster: ${monster}`);
                        continue;
                    }

                    // アンロック状態の確認と表示更新
                    const isUnlocked = checkUnlockCondition('monsters', monster);
                    card.classList.toggle('locked', !isUnlocked);
                    card.classList.toggle('unlocked', isUnlocked);

                    // プログレスバーの表示制御
                    const progressBar = card.querySelector('.summon-progress-bar');
                    const details = card.querySelector('.monster-card-details');
                    if (progressBar) {
                        progressBar.style.display = (!isUnlocked || details.classList.contains('expanded')) ? 'none' : 'block';
                    }

                    const unlockReqElement = card.querySelector('.unlock-requirement');
                    if (unlockReqElement) {
                        if (!isUnlocked) {
                            const unlockDesc = getUnlockDescription('monsters', monster);
                            unlockReqElement.textContent = `Unlock Requirement: ${unlockDesc}`;
                            unlockReqElement.style.display = 'block';
                            unlockReqElement.classList.add('unlock-requirement-text');
                        } else {
                            unlockReqElement.style.display = 'none';
                            unlockReqElement.classList.remove('unlock-requirement-text');
                        }
                    }

                    const finalEfficiencies = calculateMonsterEfficiency(monster);
                    const count = Math.floor(monsterData.count || 0);
                    const sourceEfficiency = monsterData.sourceEfficiency || 0;
                    const miasmaEfficiency = monsterData.miasmaEfficiency || 0;
                    const sourceProduction = count * finalEfficiencies.sourceEfficiency;
                    const miasmaProduction = count * finalEfficiencies.miasmaEfficiency;
                    const nextCost = getCost(monster);
                    const followerCost = Math.floor(monsterData.baseFollowerCost * Math.pow(monsterData.followerCostGrowth, count));
                    const sourceDifference = nextCost - sourceCount;
                    const { sourceProduction: currentSourceProduction } = calculateResourceProduction();
                    const timeToSummon = calculateTimeToSummon(sourceDifference, currentSourceProduction);

                    // プログレスバーの更新
                    if (progressBar && isUnlocked) {
                        const sourceProgressEl = progressBar.querySelector('.source-progress');
                        const followerProgressEl = progressBar.querySelector('.follower-progress');

                        if (sourceProgressEl && followerProgressEl) {
                            const sourceProgress = Math.min(100, (sourceCount / nextCost) * 100);
                            const followerProgress = Math.min(100, (followerCount / followerCost) * 100);

                            sourceProgressEl.style.width = `${sourceProgress}%`;
                            followerProgressEl.style.width = `${followerProgress}%`;

                            sourceProgressEl.style.opacity = sourceProgress === 100 ? '0.8' : '0.5';
                            followerProgressEl.style.opacity = followerProgress === 100 ? '0.8' : '0.5';
                        }
                    }

                    // 各要素の更新
                    updateElementText(card, '.monster-count', formatNumber(count, 0));
                    updateElementText(card, '.monster-source-efficiency', formatNumber(finalEfficiencies.sourceEfficiency, 1));
                    updateElementText(card, '.monster-miasma-efficiency', formatNumber(finalEfficiencies.miasmaEfficiency, 1));
                    updateElementText(card, '.monster-source-production', formatNumber(sourceProduction, 1));
                    updateElementText(card, '.monster-miasma-production', formatNumber(miasmaProduction, 1));
                    updateElementText(card, '.monster-next-cost', formatNumber(nextCost, 0));
                    updateElementText(card, '.monster-follower-cost', formatNumber(followerCost, 0));
                    updateElementText(card, '.monster-time-to-summon', formatTime(timeToSummon));
                    updateElementText(card, '.header-count', formatNumber(count, 0));

                    // シナジー情報の更新
                    const synergyInfo = monsterData.synergy;
                    const synergyElement = card.querySelector('.monster-synergy');
                    if (synergyInfo && synergyElement) {
                        let synergyText = `+${(synergyInfo.effect * 100).toFixed(1)}% `;
                        if (synergyInfo.type) {
                            synergyText += `${synergyInfo.type} `;
                        }
                        synergyText += `production with ${synergyInfo.partner}`;
                        synergyElement.textContent = synergyText;
                    }

                    const specialAbilityInfo = monsterData.specialAbility;
                    const specialAbilityElement = card.querySelector('.monster-special-ability');
                    if (specialAbilityElement) {
                        if (specialAbilityInfo) {
                            const description = describeSpecialAbility(specialAbilityInfo);
                            specialAbilityElement.textContent = description;
                        } else {
                            specialAbilityElement.textContent = 'None';
                        }
                    }

                    // サモンボタンの更新
                    const summonBtn = card.querySelector('.summon-monster-btn');
                    if (summonBtn) {
                        const canAfford = sourceCount >= nextCost && followerCount >= followerCost;
                        summonBtn.disabled = !canAfford;
                        summonBtn.classList.toggle('button-enabled', canAfford);
                        summonBtn.classList.toggle('button-disabled', !canAfford);
                    }
                }
            }

            function updateMonsterStates() {
                for (const monsterType in gameState.monsters) {
                    const monster = gameState.monsters[monsterType];
                    if (monster.count > 0) {
                        // 特殊能力の発動条件チェック
                        const triggerCount = Math.floor(monster.count / monster.specialAbility.trigger);
                        if (triggerCount > 0) {
                            if (monster.specialAbility.effect.type === 'madnessChance') {
                                // madnessChanceの更新をログに記録
                                debug(`${monsterType}: Applying madness chance modifier: ${monster.specialAbility.effect.value * triggerCount}`);
                            }
                        }
                    }
                }
            }

            function checkSpecialAbilityEffects() {
                for (const monsterType in gameState.monsters) {
                    const monster = gameState.monsters[monsterType];
                    if (monster.count > 0 && monster.specialAbility) {
                        const triggerCount = Math.floor(monster.count / monster.specialAbility.trigger);
                        debug(`${monsterType} special ability status:
                Count: ${monster.count}
                Triggers: ${triggerCount}
                Effect Type: ${monster.specialAbility.effect.type}
                Effect Value: ${monster.specialAbility.effect.value}
                Current Multiplier: ${gameState.madnessChanceMultiplier || 1}`);
                    }
                }
            }

            // アンロック状態の更新時にプログレスバーの表示/非表示を制御する関数を修正
            function updateMonsterCardLockState(card, isLocked) {
                const progressBar = card.querySelector('.summon-progress-bar');
                const details = card.querySelector('.monster-card-details');

                if (progressBar) {
                    if (isLocked) {
                        progressBar.style.display = 'none';
                    } else {
                        // アンロック状態で折りたたまれている場合のみ表示
                        progressBar.style.display = details.classList.contains('expanded') ? 'none' : 'block';
                    }
                }
            }

            function updateMonsterCards() {
                const monsterGrid = document.getElementById('monsterGrid');
                if (!monsterGrid) return;

                // sourceCountを定義
                const sourceCount = Math.floor(gameState.source);

                // 既存のモンスターカードの更新
                for (let monsterName in gameState.monsters) {
                    const monster = gameState.monsters[monsterName];
                    const card = document.getElementById(`monster-${monsterName}`);

                    if (!card) continue;

                    // モンスターの基本情報を更新
                    const countElement = card.querySelector('.monster-count');
                    if (countElement) {
                        countElement.textContent = formatNumber(monster.count, 0);
                    }

                    // 生産効率の更新
                    const sourceEfficiencyElement = card.querySelector('.monster-source-efficiency');
                    if (sourceEfficiencyElement) {
                        sourceEfficiencyElement.textContent = formatNumber(monster.sourceEfficiency, 2);
                    }

                    const miasmaEfficiencyElement = card.querySelector('.monster-miasma-efficiency');
                    if (miasmaEfficiencyElement) {
                        miasmaEfficiencyElement.textContent = formatNumber(monster.miasmaEfficiency, 2);
                    }

                    // 総生産量の更新
                    const sourceProduction = monster.count * monster.sourceEfficiency;
                    const miasmaProduction = monster.count * monster.miasmaEfficiency;

                    const sourceProductionElement = card.querySelector('.monster-source-production');
                    if (sourceProductionElement) {
                        sourceProductionElement.textContent = formatNumber(sourceProduction, 1);
                    }

                    const miasmaProductionElement = card.querySelector('.monster-miasma-production');
                    if (miasmaProductionElement) {
                        miasmaProductionElement.textContent = formatNumber(miasmaProduction, 1);
                    }

                    // コストの更新
                    const nextCost = getCost(monsterName);
                    const followerCost = Math.floor(monster.baseFollowerCost * Math.pow(monster.followerCostGrowth, monster.count));

                    const nextCostElement = card.querySelector('.monster-next-cost');
                    if (nextCostElement) {
                        nextCostElement.textContent = formatNumber(nextCost, 0);
                    }

                    const followerCostElement = card.querySelector('.monster-follower-cost');
                    if (followerCostElement) {
                        followerCostElement.textContent = formatNumber(followerCost, 0);
                    }

                    // サモンボタンの更新
                    const summonBtn = card.querySelector('.summon-monster-btn');
                    if (summonBtn) {
                        const monster = gameState.monsters[monsterName];
                        const followerCost = Math.floor(monster.baseFollowerCost * Math.pow(monster.followerCostGrowth, monster.count));
                        const sourceCost = getCost(monsterName);

                        // 通常の条件チェック
                        const hasEnoughFollowers = gameState.followers >= followerCost;
                        const hasEnoughSource = sourceCount >= sourceCost;

                        // 契約による最小フォロワー数の制限をチェック
                        let meetsMinimumRequirement = true;
                        if (gameState.pacts?.active?.includes('1')) {
                            // 召喚後に最小フォロワー数の半分を下回らないようにする
                            const minimumFollowers = gameState.minimumFollowers || 0;
                            meetsMinimumRequirement = (gameState.followers - followerCost) >= (minimumFollowers);
                        }

                        // すべての条件を満たす場合のみサモン可能
                        const canSummon = hasEnoughFollowers && hasEnoughSource;

                        summonBtn.disabled = !canSummon;
                        summonBtn.classList.toggle('button-enabled', canSummon);
                        summonBtn.classList.toggle('button-disabled', !canSummon);

                        // ツールチップのテキストを更新
                        let tooltipText = '';
                        if (!hasEnoughSource) {
                            tooltipText = `Need ${formatNumber(sourceCost - sourceCount)} more source`;
                        } else if (!hasEnoughFollowers) {
                            tooltipText = `Need ${formatNumber(followerCost - gameState.followers)} more followers`;
                        } else if (!meetsMinimumRequirement) {
                            tooltipText = `Must maintain minimum follower count (${formatNumber(gameState.minimumFollowers)})`;
                        }
                        summonBtn.title = tooltipText;
                    }

                    // 狂気チャンスの表示を更新
                    const madnessChanceElement = card.querySelector('.madness-chance');
                    if (madnessChanceElement) {
                        const chance = calculateMadnessChance(adventurer);
                        madnessChanceElement.textContent = `${(chance * 100).toFixed(1)}%`;

                        // 補正が適用されている場合は視覚的なフィードバックを追加
                        const hasBonus = chance > adventurer.madnessChance;
                        madnessChanceElement.classList.toggle('has-bonus', hasBonus);

                        if (hasBonus) {
                            const baseChance = adventurer.madnessChance * 100;
                            const totalChance = chance * 100;
                            madnessChanceElement.title = `Base: ${baseChance.toFixed(1)}% + Bonus: ${(totalChance - baseChance).toFixed(1)}%`;
                        }
                    }

                    // アンロック状態の更新
                    const isUnlocked = checkUnlockCondition('monsters', monsterName);
                    card.classList.toggle('locked', !isUnlocked);
                    card.classList.toggle('unlocked', isUnlocked);
                }

                // プログレスバーの更新
                updateProgressBars();
            }

            function updateProgressBars() {
                // モンスターカードのプログレスバー更新
                for (let monsterType in gameState.monsters) {
                    const card = document.getElementById(`monster-${monsterType}`);
                    if (!card) continue;

                    const monster = gameState.monsters[monsterType];
                    const sourceCost = getCost(monsterType);
                    const followerCost = Math.floor(monster.baseFollowerCost *
                        Math.pow(monster.followerCostGrowth, monster.count));

                    // プログレスバーのコンテナを確認
                    let progressContainer = card.querySelector('.summon-progress-bar');
                    if (!progressContainer) continue;

                    // リソースの進捗率を計算
                    const sourceProgress = Math.min(100, (gameState.source / sourceCost * 100));
                    const followerProgress = Math.min(100, (gameState.followers / followerCost * 100));
                    const hasEnoughFollowers = gameState.followers >= followerCost;

                    // プログレスバーの要素を取得
                    const sourceProgressBar = progressContainer.querySelector('.source-progress');
                    const followerProgressBar = progressContainer.querySelector('.follower-progress');

                    // Source進捗バーの更新
                    if (sourceProgressBar) {
                        sourceProgressBar.style.width = `${sourceProgress}%`;
                        sourceProgressBar.style.opacity = gameState.source >= sourceCost ? '0.8' : '0.5';
                    }

                    // Follower進捗バーの更新
                    if (followerProgressBar) {
                        followerProgressBar.style.width = `${followerProgress}%`;
                        followerProgressBar.style.opacity = hasEnoughFollowers ? '0.8' : '0.5';
                        followerProgressBar.style.backgroundColor = ''; // 常にデフォルトの色を使用
                    }

                    // ASCII進捗バーの更新
                    let asciiContainer = progressContainer.querySelector('.ascii-progress');
                    if (!asciiContainer) {
                        asciiContainer = document.createElement('div');
                        asciiContainer.className = 'ascii-progress';
                        progressContainer.appendChild(asciiContainer);
                    }

                    // 召喚可能状態の判定
                    const canSummon = gameState.source >= sourceCost && hasEnoughFollowers;

                    // ASCIIバーの更新
                    const sourceBar = createBar(sourceProgress, 'source', true);
                    const followerBar = createBar(followerProgress, 'follower', true);

                    asciiContainer.innerHTML = `
            <div class="ascii-progress-line source">
                <span class="bar">${sourceBar}</span>
            </div>
            <div class="ascii-progress-line follower">
                <span class="bar">${followerBar}</span>
            </div>
        `;
                }
            }

            function createBar(percentage, style = 'default', canSummon = true) {
                const width = 60;
                const themes = {
                    source: {
                        start: '<span style="color: #42bd49">S: </span>',
                        end: '<span style="color: #42bd49">»</span>',
                        fills: [
                            '<span style="color: #064808">||</span>',
                            '<span style="color: #1a8d1d">||</span>',
                            '<span style="color: #2eb233">||</span>',
                            '<span style="color: #42bd49">||</span>'
                        ],
                        maxFills: [
                            '<span style="color: #50ff50; text-shadow: 0 0 5px #50ff50">||</span>'
                        ],
                        empty: '<span style="color: #064808"> </span>',
                    },
                    follower: {
                        start: '<span style="color: #9932CC">F: </span>',
                        end: '<span style="color: #9932CC">»</span>',
                        fills: [
                            '<span style="color: #4B0082">||</span>',
                            '<span style="color: #800080">||</span>',
                            '<span style="color: #9932CC">||</span>',
                            '<span style="color: #fb40fb">||</span>'
                        ],
                        maxFills: [
                            '<span style="color: #ff50ff; text-shadow: 0 0 5px #ff50ff">||</span>'
                        ],
                        empty: '<span style="color: #4B0082"> </span>',
                    }
                };

                const theme = canSummon ? themes[style] : themes.gray;
                const fillCount = Math.floor((percentage / 100) * width);
                const emptyCount = width - fillCount;

                let barContent = percentage >= 100 ?
                    theme.maxFills[0].repeat(fillCount) :
                    Array.from({ length: fillCount }, (_, i) =>
                        theme.fills[Math.floor((i / width) * theme.fills.length)]).join('');

                return `${theme.start}${barContent}${theme.empty.repeat(emptyCount)}${theme.end}`;
            }

            function describeSpecialAbility(ability) {
                if (!ability) return 'None';

                const { trigger, effect } = ability;
                if (!effect) return 'Invalid special ability';

                // Effect description based on type
                let effectDescription;
                switch (effect.type) {
                    case 'allMonsterEfficiency':
                        effectDescription = `Increase all monster efficiency by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    case 'miasmaEfficiency':
                        effectDescription = `Increase miasma production by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    case 'followerEfficiency':
                        effectDescription = `Increase follower efficiency by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    case 'sourceProduction':
                        effectDescription = `Increase source production by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    case 'upgradeEffect':
                        effectDescription = `Increase all upgrade effects by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    case 'followerProduction':
                        effectDescription = `Increase follower production by ${effect.value.toFixed(1)} per second`;
                        break;
                    case 'cosmicResonance':
                        effectDescription = `Increase all production by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    case 'upgradeCost':
                        effectDescription = `Reduce upgrade costs by ${(effect.value * 100).toFixed(1)}% (max ${(effect.maxDiscount * 100).toFixed(1)}%)`;
                        break;
                    case 'adventurerResistanceRecoveryTime':
                        effectDescription = `Reduce adventurer resistance cooldown by ${(effect.value / 1000).toFixed(1)} second(s)`;
                        break;
                    case 'madnessChance':
                        effectDescription = `Increase madness chance by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    default:
                        effectDescription = 'Unknown effect type';
                }

                return `Every ${trigger} ${trigger === 1 ? 'summon' : 'summons'}: ${effectDescription}`;
            }

            // モンスターのイベントリスナーを設定する関数
            function setupMonsterEventListeners() {
                const monsterButtons = document.querySelectorAll('.summon-monster-btn');
                monsterButtons.forEach(button => {
                    button.removeEventListener('click', handleMonsterSummon); // 既存のリスナーを削除
                    button.addEventListener('click', handleMonsterSummon); // 新しいリスナーを追加
                });
            }

            // モンスター召喚ハンドラー
            function handleMonsterSummon(event) {
                const monsterType = event.target.dataset.monster;
                if (monsterType) {
                    summonMonster(monsterType);
                }
            }

            // モンスターUIを再構築する新しい関数
            function rebuildMonsterUI() {
                const monsterGrid = document.getElementById('monsterGrid');
                if (monsterGrid) {
                    monsterGrid.innerHTML = ''; // グリッドをクリア
                    updateMonsterGrid(); // グリッドを再構築
                }

                // モンスターのイベントリスナーを再設定
                setupMonsterEventListeners();
            }

            // Add visual effects for pact modal
            function animatePactModal() {
                const modal = document.querySelector('.pact-modal');
                const content = document.querySelector('.pact-content');
                const description = document.querySelector('.pact-description');
                const effects = document.querySelectorAll('.pact-effect');

                // Fade in modal
                modal.style.opacity = '0';
                modal.style.display = 'flex';
                setTimeout(() => {
                    modal.style.opacity = '1';
                }, 10);

                // Slide up animation
                content.style.transform = 'translateY(50px)';
                setTimeout(() => {
                    content.style.transform = 'translateY(0)';
                }, 500);

                // Text reveal animation
                description.innerHTML = '';
                let i = 0;
                const text = PACTS[1].description;
                function revealText() {
                    if (i < text.length) {
                        description.innerHTML += text.charAt(i);
                        i++;
                        setTimeout(revealText, 30);
                    }
                }
                setTimeout(revealText, 1000);

                // Effects fade in  
                effects.forEach((effect, index) => {
                    effect.style.opacity = '0';
                    effect.style.transform = 'translateX(-20px)';
                    setTimeout(() => {
                        effect.style.opacity = '1';
                        effect.style.transform = 'translateX(0)';
                    }, 1500 + (index * 200));
                });
            }

            // Update follower ASCII art with new appearance
            function updateFollowerAsciiArt(newArt, tooltipText) {
                const followerArt = document.getElementById('followerAsciiArt');
                if (followerArt) {
                    followerArt.classList.add('transforming');

                    setTimeout(() => {
                        followerArt.innerHTML = newArt;
                        followerArt.classList.remove('transforming');
                        followerArt.classList.add('transformed');
                    }, 1000);
                }
            }

            // Add visual feedback for pact activation
            function addPactVisualEffects() {
                const gameContainer = document.querySelector('.container');
                if (gameContainer) {
                    gameContainer.classList.add('pact-active');
                    setTimeout(() => {
                        gameContainer.classList.remove('pact-active');
                    }, 2000);
                }
            }

            function hideManualRecruitButtons() {
                const elements = [
                    document.getElementById('recruitFollowerBtn'),
                    document.getElementById('collectSource'),
                    ...document.querySelectorAll('.recruit-follower-btn')
                ];

                elements.forEach(element => {
                    if (element) {
                        element.style.display = 'none';
                        element.disabled = true;
                        element.classList.add('sealed-by-pact');
                    }
                });

                // リクルートボタンのコンテナも非表示に
                const recruitContainer = document.querySelector('.recruit-container');
                if (recruitContainer) {
                    recruitContainer.style.display = 'none';
                    recruitContainer.classList.add('sealed-by-pact');
                }
            }

            function showManualRecruitButtons() {
                try {
                    // 全てのリクルートボタンを取得
                    const sourceBtn = document.getElementById('collectSource');
                    const followerBtn = document.getElementById('recruitFollowerBtn');
                    const recruitButtons = document.querySelectorAll('.recruit-follower-btn');

                    // sealed-by-pactクラスが付いているボタンのみ表示を戻す
                    [sourceBtn, followerBtn, ...recruitButtons].forEach(btn => {
                        if (btn && btn.classList.contains('sealed-by-pact')) {
                            btn.style.display = 'block';
                            btn.classList.remove('sealed-by-pact');
                            btn.disabled = false;
                        }
                    });

                    // リクルートボタンのコンテナも表示を戻す
                    const recruitContainer = document.querySelector('.recruit-container.sealed-by-pact');
                    if (recruitContainer) {
                        recruitContainer.style.display = 'block';
                        recruitContainer.classList.remove('sealed-by-pact');
                    }

                    //console.log("Manual recruit buttons shown");
                } catch (error) {
                    console.error("Error showing manual recruit buttons:", error);
                }
            }

            // 契約チェック関数 - すべての契約に対応
            function checkPacts() {
                if (!gameState.pacts.showingPactModal) {
                    // 第1の契約チェック
                    if (!gameState.pacts.active.includes('1') && gameState.source >= 1e6 - 1) {
                        showPactModal(1);
                        return;
                    }
                    // 第2の契約チェック
                    if (gameState.pacts.active.includes('1') && !gameState.pacts.active.includes('2') &&
                        gameState.source >= 1e28 - 1) {
                        showPactModal(2);
                        return;
                    }
                }
            }

            // 契約モーダルを表示する共通関数
            function showPactModal(pactId) {
                const pact = PACTS[pactId];
                if (!pact) return;

                gameState.pacts.showingPactModal = true;
                gamePaused = true;

                const effectsList = pact.effects
                    .map(effect => `<li class="pact-effect">${effect.description}</li>`)
                    .join('');

                const modalHtml = `
    <div class="pact-modal">
        <div class="pact-content">
            <h2 class="pact-title">${pact.name}</h2>
            <div class="pact-scroll">
                <p class="pact-description">${pact.description}</p>
                <p class="pact-flavor">${pact.flavorText}</p>
                <ul class="pact-effects">${effectsList}</ul>
                <p class="pact-warning">${pact.warning}</p>
            </div>
            <div class="pact-buttons">
                <button onclick="acceptPact(${pactId})">Accept Contract</button>
                <button onclick="declinePact()" class="decline-btn">Decline</button>
            </div>
        </div>
    </div>`;

                document.body.insertAdjacentHTML('beforeend', modalHtml);
                animatePactModal();
            }

            // PACTの状態を追跡するためのプロパティをgameStateに追加
            if (!gameState.pacts) {
                gameState.pacts = {
                    active: [],
                    currentFollowerArt: null,
                    commonMultiplier: 1,
                    tickSpeedMultiplier: 1,
                    showingPactModal: false
                };
            }

            function applyPactEffects(pact) {
                pact.effects.forEach(effect => {
                    switch (effect.type) {
                        case "minimumFollowers":
                            gameState.minimumFollowers = Math.max(gameState.minimumFollowers || 0, effect.value);
                            gameState.followers = Math.max(gameState.followers || 0, effect.value);
                            break;
                        case "followerEfficiency":
                            gameState.followerEfficiency = (gameState.followerEfficiency || 0.1) * (1 + effect.value);
                            break;
                        case "globalMultiplier":
                            gameState.pacts.commonMultiplier *= (1 + effect.value);
                            break;
                        case "tickSpeed":
                            gameState.pacts.tickSpeedMultiplier *= (1 + effect.value);
                            break;
                        case "sealManualRecruits":
                            hideManualRecruitButtons();
                            break;
                    }
                });
            }

            // PACTに特有のUI更新を行う関数
            function updatePactSpecificUI() {
                // 手動リクルートボタンの状態を更新
                if (gameState.pacts.active.includes('1')) {
                    hideManualRecruitButtons();
                } else {
                    showManualRecruitButtons();
                }

                // フォロワーの外観を更新
                updateFollowerAppearance();

                // アップグレードの順序を確実に維持
                const upgradeGrid = document.getElementById('upgradeGrid');
                if (upgradeGrid) {
                    upgradeGrid.innerHTML = '';
                    updateUpgradeGrid();
                }

                // エンブレムを更新
                updateCultosMiner();

                // tick speed表示を更新
                updateTimeAccelerationDisplay();

                // 統計情報を更新
                if (document.getElementById('statisticsModal')?.classList.contains('active')) {
                    updateStatistics();
                }
            }


            // PACT適用時の処理を改善
            function applyPact(pactId) {
                const pact = PACTS[pactId];
                if (!pact) return;

                // 現在のフォロワー数を保存
                const currentFollowers = gameState.followers;

                // 契約による最小フォロワー数を計算
                let minimumFollowers = 0;
                pact.effects.forEach(effect => {
                    if (effect.type === "minimumFollowers") {
                        minimumFollowers = Math.max(minimumFollowers, effect.value);
                    }
                });

                // フォロワー数を更新（現在の数と最小値の半分の大きい方を維持）
                gameState.followers = Math.max(currentFollowers, minimumFollowers);

                // PACTの効果を適用
                pact.effects.forEach(effect => {
                    switch (effect.type) {
                        case "minimumFollowers":
                            gameState.minimumFollowers = effect.value;
                            break;
                        case "followerEfficiency":
                            gameState.followerEfficiency *= (1 + effect.value);
                            break;
                        case "globalMultiplier":
                            gameState.pacts.commonMultiplier *= (1 + effect.value);
                            break;
                        case "tickSpeed":
                            gameState.pacts.tickSpeedMultiplier *= (1 + effect.value);
                            break;
                    }
                });

                // PACTをアクティブリストに追加
                if (!gameState.pacts.active.includes(pactId)) {
                    gameState.pacts.active.push(pactId);
                }

                // フォロワーのアートを更新
                gameState.pacts.currentFollowerArt = pact.followerAsciiArt;
                gameState.pacts.currentTooltipText = pact.tooltipText;

                // UI更新を実行
                updateFollowerAppearance();
                rebuildUI();

                // 視覚効果を追加
                addPactVisualEffects();
                logAction(`The ${pact.name} has been sealed`);

                // ゲームの状態を保存
                saveGame();
            }

            // フォロワーの外観を更新する関数を改善
            function updateFollowerAppearance() {
                const followerArt = document.getElementById('followerAsciiArt');
                if (!followerArt) return;

                // 最新のPACTのフォロワーアートを取得
                let currentArt = null;
                let currentTooltip = null;

                if (gameState.pacts?.active?.length > 0) {
                    const lastPactId = gameState.pacts.active[gameState.pacts.active.length - 1];
                    const lastPact = PACTS[lastPactId];
                    if (lastPact) {
                        currentArt = lastPact.followerAsciiArt;
                        currentTooltip = lastPact.tooltipText;
                    }
                }

                // アニメーション付きで更新
                followerArt.classList.add('transforming');

                setTimeout(() => {
                    if (currentArt) {
                        followerArt.innerHTML = currentArt;
                        followerArt.setAttribute('data-tooltip', currentTooltip || '');
                        followerArt.classList.add('pact-transformed');
                    } else {
                        followerArt.innerHTML = asciiArt['Follower'];
                        followerArt.removeAttribute('data-tooltip');
                        followerArt.classList.remove('pact-transformed');
                    }
                    followerArt.classList.remove('transforming');
                }, 1000);
            }

            // 契約の視覚効果を更新する共通関数
            function updatePactVisuals(pact) {
                if (!pact) return;

                // フォロワーのASCII artとツールチップを更新
                updateFollowerAsciiArt(pact.followerAsciiArt, pact.tooltipText);

                // 視覚効果のアニメーション
                const gameContainer = document.querySelector('.container');
                if (gameContainer) {
                    gameContainer.classList.add('pact-active');
                    setTimeout(() => {
                        gameContainer.classList.remove('pact-active');
                    }, 2000);
                }

                // フォロワーの変身アニメーション
                const followerArt = document.getElementById('followerAsciiArt');
                if (followerArt) {
                    followerArt.classList.add('transforming');
                    setTimeout(() => {
                        followerArt.classList.remove('transforming');
                        followerArt.classList.add('transformed');
                    }, 1000);
                }
            }

            // acceptPact関数を完全に書き直し
            function acceptPact(pactId) {
                try {
                    console.log("Accepting pact:", pactId);

                    // 契約モーダルを閉じる
                    closePactModal();

                    // 現在の重要なデータを保存
                    const persistentData = {
                        statistics: { ...gameState.statistics },
                        pacts: {
                            active: [...(gameState.pacts?.active || []), pactId.toString()],
                            commonMultiplier: (gameState.pacts?.commonMultiplier || 1) * 1.25, // 25%増加
                            tickSpeedMultiplier: (gameState.pacts?.tickSpeedMultiplier || 1) * 1.25,
                            showingPactModal: false
                        },
                        cultos: gameState.cultos || 0,
                        cultosRate: gameState.cultosRate || 0,
                        minimumFollowers: 0
                    };

                    // ゲーム状態を初期状態にリセット
                    gameState = JSON.parse(JSON.stringify(initialGameState));

                    // 永続データを復元
                    gameState.statistics = persistentData.statistics;
                    gameState.pacts = persistentData.pacts;
                    gameState.cultos = persistentData.cultos;
                    gameState.cultosRate = persistentData.cultosRate;

                    // 初期アンロック状態を設定
                    gameState.unlockedContent = {
                        monsters: new Set(['Shoggoth']),
                        adventurers: new Set(['Novice Explorer']),
                        upgrades: new Set(['Ritual Knowledge']),
                        resources: new Set()
                    };

                    // PACT効果の即時適用
                    const pact = PACTS[pactId];
                    if (pact) {
                        pact.effects.forEach(effect => {
                            switch (effect.type) {
                                case "minimumFollowers":
                                    persistentData.minimumFollowers = Math.max(persistentData.minimumFollowers, effect.value);
                                    gameState.followers = effect.value; // 最小値を直接設定
                                    break;
                                case "followerEfficiency":
                                    gameState.followerEfficiency *= (1 + effect.value);
                                    break;
                                case "sealManualRecruits":
                                    // 手動リクルートを即座に無効化
                                    const recruitBtn = document.getElementById('recruitFollowerBtn');
                                    if (recruitBtn) {
                                        recruitBtn.style.display = 'none';
                                        recruitBtn.disabled = true;
                                        recruitBtn.classList.add('sealed-by-pact');
                                    }
                                    const collectSourceBtn = document.getElementById('collectSource');
                                    if (collectSourceBtn) {
                                        collectSourceBtn.style.display = 'none';
                                        collectSourceBtn.disabled = true;
                                        collectSourceBtn.classList.add('sealed-by-pact');
                                    }
                                    break;
                            }
                        });
                    }

                    // フォロワーの外観を即座に更新
                    const followerArt = document.getElementById('followerAsciiArt');
                    if (followerArt && pact.followerAsciiArt) {
                        followerArt.innerHTML = pact.followerAsciiArt;
                        if (pact.tooltipText) {
                            followerArt.setAttribute('data-tooltip', pact.tooltipText);
                        }
                        followerArt.classList.add('transformed');
                    }

                    // DOMの完全な再構築
                    resetDOM();
                    rebuildUI();

                    // 追加のUI更新
                    updateResourceDisplay();
                    updateCultosMiner();
                    updateTimeAccelerationDisplay();
                    updateUpgradeSymbols();
                    updateButtonStates();

                    // この時点でボタンの状態を強制的に更新
                    if (pactId === '1') {
                        const allRecruitButtons = document.querySelectorAll('.recruit-follower-btn, #recruitFollowerBtn');
                        allRecruitButtons.forEach(btn => {
                            btn.style.display = 'none';
                            btn.disabled = true;
                            btn.classList.add('sealed-by-pact');
                        });
                    }

                    // ゲームを再開
                    gamePaused = false;

                    // 状態を保存
                    saveGame();

                    logAction(`The ${PACTS[pactId].name} has been sealed - Progress has been reset`);

                    // 即座にアップグレードグリッドを更新
                    const upgradeGrid = document.getElementById('upgradeGrid');
                    if (upgradeGrid) {
                        upgradeGrid.innerHTML = '';
                        updateUpgradeGrid();
                    }

                    return true;

                } catch (error) {
                    console.error("Error accepting pact:", error);
                    return false;
                }
            }

            function closePactModal() {
                try {
                    const modal = document.querySelector('.pact-modal');
                    if (modal) {
                        modal.remove();
                    }
                    gameState.pacts.showingPactModal = false;
                    gamePaused = false;
                    console.log("Modal closed successfully");
                } catch (error) {
                    console.error("Error closing modal:", error);
                }
            }

            // ゲームロード時のフォロワー外観更新を確実に行う
            const existingLoadGame = window.loadGame;
            window.loadGame = function () {
                const result = existingLoadGame.apply(this, arguments);

                if (result && gameState.pacts?.active?.length > 0) {
                    const lastPactId = gameState.pacts.active[gameState.pacts.active.length - 1];
                    const pact = PACTS[lastPactId];

                    if (pact) {
                        const followerArt = document.getElementById('followerAsciiArt');
                        if (followerArt) {
                            followerArt.innerHTML = pact.followerAsciiArt;
                            if (pact.tooltipText) {
                                followerArt.setAttribute('data-tooltip', pact.tooltipText);
                            }
                            followerArt.classList.add('transformed');
                        }
                    }
                }

                return result;
            };

            // フォロワーセクション更新時にも外観を確認
            const existingUpdateFollowerSection = window.updateFollowerSection;
            window.updateFollowerSection = function () {
                existingUpdateFollowerSection.apply(this, arguments);

                if (gameState.pacts?.active?.length > 0) {
                    const lastPactId = gameState.pacts.active[gameState.pacts.active.length - 1];
                    const pact = PACTS[lastPactId];

                    if (pact) {
                        const followerArt = document.getElementById('followerAsciiArt');
                        if (followerArt) {
                            followerArt.innerHTML = pact.followerAsciiArt || asciiArt['Follower'];
                            if (pact.tooltipText) {
                                followerArt.setAttribute('data-tooltip', pact.tooltipText);
                            }
                        }
                    }
                }
            };

            // 契約拒否共通関数
            function declinePact() {
                closePactModal();
                gamePaused = false;
            }

            // ゲームループ内での契約効果の適用
            function updatePactEffects() {
                if (!gameState.pacts?.active) return;

                // 現在のフォロワー数を保存
                const currentFollowers = gameState.followers;
                let minimumFollowers = 0;

                // すべての有効な契約から最小フォロワー数を計算
                gameState.pacts.active.forEach(pactId => {
                    const pact = PACTS[pactId];
                    if (pact) {
                        const minFollowersEffect = pact.effects.find(e => e.type === "minimumFollowers");
                        if (minFollowersEffect) {
                            minimumFollowers = Math.max(minimumFollowers, minFollowersEffect.value);
                        }
                    }
                });

                // 最小フォロワー数を保存
                gameState.minimumFollowers = minimumFollowers;

                // フォロワー数を調整（現在の数と最小値の半分の大きい方を維持）
                gameState.followers = Math.max(currentFollowers, minimumFollowers);
            }

            // ゲームの状態をロードする際の契約の復元
            function restorePacts() {
                if (gameState.pacts && gameState.pacts.active) {
                    gameState.pacts.active.forEach(pactId => {
                        if (!gameState.pacts.applied.includes(pactId)) {  // 追加: すでに適用されているか確認
                            applyPact(parseInt(pactId));
                            gameState.pacts.applied.push(pactId);  // 追加: 適用済みリストに追加
                        }
                    });
                }
            }

            // ゲーム初期化時に契約システムを設定
            function initializePactSystem() {
                if (!gameState.pacts) {
                    gameState.pacts = {
                        active: [],
                        applied: [],  // 追加: 適用済みの契約を追跡するリスト
                        commonMultiplier: 1,
                        tickSpeedMultiplier: 1,
                        showingPactModal: false
                    };
                }
            }

            function addPactVisualEffects() {
                const gameContainer = document.querySelector('.container');
                if (gameContainer) {
                    gameContainer.classList.add('pact-active');
                    setTimeout(() => {
                        gameContainer.classList.remove('pact-active');
                    }, 2000);
                }
            }

            function formatTime(seconds) {
                // tick speedを考慮して時間を調整
                seconds = seconds / timeAcceleration;

                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = Math.floor(seconds % 60);

                let timeString = '';
                if (hours > 0) timeString += `${hours}h `;
                if (minutes > 0 || hours > 0) timeString += `${minutes}m `;
                timeString += `${remainingSeconds}s`;

                return timeString.trim();
            }

            // logAction 関数の再定義
            function logAction(message) {
                const log = document.getElementById('log');
                if (log) {
                    const p = document.createElement('p');
                    // 数値を含むメッセージの場合、formatNumber関数を使用して整形
                    p.textContent = message.replace(/\d+(\.\d+)?/g, match => formatNumber(parseFloat(match)));
                    log.insertBefore(p, log.firstChild);
                    if (log.childElementCount > 20) {
                        log.removeChild(log.lastChild);
                    }
                }
                debug(`Log: ${message}`);
            }

            function debugGameState() {
                debug("Current game state:");
                debug(`Source: ${gameState.source}`);
                debug(`Miasma: ${gameState.miasma}`);
                debug(`Followers: ${gameState.followers}`);
                debug(`Follower Efficiency: ${gameState.followerEfficiency}`);

                if (typeof gameState.source !== 'number') debug("WARNING: source is not a number");
                if (typeof gameState.miasma !== 'number') debug("WARNING: miasma is not a number");
                if (typeof gameState.followers !== 'number') debug("WARNING: followers is not a number");
                if (typeof gameState.followerEfficiency !== 'number') debug("WARNING: followerEfficiency is not a number");
            }

            // セーブ前の状態検証
            function validateBeforeSave() {
                const numericProps = ['source', 'miasma', 'followers', 'followerEfficiency'];
                let isValid = true;

                numericProps.forEach(prop => {
                    if (typeof gameState[prop] !== 'number' || isNaN(gameState[prop])) {
                        debug(`Invalid ${prop} before save: ${gameState[prop]}`);
                        gameState[prop] = 0;
                        isValid = false;
                    }
                });

                return isValid;
            }

            function saveGame() {
                try {
                    // データ整合性の確認
                    if (!Array.isArray(gameState.upgrades)) {
                        gameState.upgrades = [];
                    }

                    // アップグレードの重複排除と検証
                    gameState.upgrades = [...new Set(gameState.upgrades)].filter(
                        upgrade => upgradeDefinitions.hasOwnProperty(upgrade)
                    );

                    // アンロック状態の確認
                    if (!gameState.unlockedContent) {
                        gameState.unlockedContent = {
                            adventurers: new Set(['Novice Explorer']),
                            monsters: new Set(['Shoggoth']),
                            upgrades: new Set(['Ritual Knowledge']),
                            resources: new Set()
                        };
                    }

                    // 保存用のステート作成
                    const saveState = {
                        ...JSON.parse(JSON.stringify({
                            ...gameState,
                            unlockedContent: null // 一時的に除外
                        })),
                        // アンロック状態を配列として保存
                        unlockedContent: {
                            monsters: Array.from(gameState.unlockedContent.monsters || new Set()),
                            adventurers: Array.from(gameState.unlockedContent.adventurers || new Set()),
                            upgrades: Array.from(gameState.unlockedContent.upgrades || new Set()),
                            resources: Array.from(gameState.unlockedContent.resources || new Set())
                        },
                        // upgradeOrderを保存
                        upgradeOrder: upgradeOrder,
                        // バージョン情報
                        version: gameVersion
                    };

                    // PACTの状態を確実に保存
                    if (saveState.pacts?.active?.includes('1')) {
                        saveState.pacts.sealedRecruits = true;
                    }

                    // セーブデータを保存
                    localStorage.setItem('cultistComplexSave', JSON.stringify(saveState));

                    console.log('[DEBUG] Game saved successfully');

                    // バックアップの作成（オプション）
                    try {
                        localStorage.setItem('cultistComplexSave_backup', JSON.stringify(saveState));
                    } catch (backupError) {
                        console.warn('Failed to create backup:', backupError);
                    }

                    return true;

                } catch (error) {
                    console.error('Error saving game:', error);
                    logAction("Failed to save game: " + error.message);
                    return false;
                }
            }

            function setupAutoSave() {
                const autoSaveInterval = 5 * 60 * 1000; // 5分ごと
                setInterval(saveGame, autoSaveInterval);
            }

            // バックアップ作成
            function createBackup() {
                const currentSave = localStorage.getItem('cultistComplexSave');
                if (currentSave) {
                    localStorage.setItem('cultistComplexSave_backup', currentSave);
                    debug("Backup created");
                }
            }

            // ゲームロード時のunlockedContent復元関数
            function loadUnlockedContent(savedContent) {
                return {
                    monsters: new Set(savedContent.monsters || ['Shoggoth']),
                    adventurers: new Set(savedContent.adventurers || ['Novice Explorer']),
                    upgrades: new Set(savedContent.upgrades || ['Ritual Knowledge']),
                    resources: new Set(savedContent.resources || [])
                };
            }

            function loadGame() {
                try {
                    const savedGame = localStorage.getItem('cultistComplexSave');
                    if (!savedGame) {
                        logAction("No saved game found, starting new game");
                        return false;
                    }

                    const loadedState = JSON.parse(savedGame);

        // 基本値にリセット（契約効果を適用する前の初期値）
        const baseEfficiency = loadedState.followerEfficiency || 0.1; // 保存された効率値を使用
        const baseMultiplier = 1;

                    // gameStateを更新する前に効率値をリセット
                    gameState = {
                        ...loadedState,
                        followerEfficiency: baseEfficiency,
                        pacts: {
                            ...loadedState.pacts,
                            commonMultiplier: baseMultiplier,
                            tickSpeedMultiplier: baseMultiplier
                        }
                    };

                    // unlockedContentの復元
                    gameState.unlockedContent = {
                        monsters: new Set(loadedState.unlockedContent.monsters || ['Shoggoth']),
                        adventurers: new Set(loadedState.unlockedContent.adventurers || ['Novice Explorer']),
                        upgrades: new Set(loadedState.unlockedContent.upgrades || ['Ritual Knowledge']),
                        resources: new Set(loadedState.unlockedContent.resources || [])
                    };

                    // 保存されているフォロワー数を一時保存
                    const savedFollowers = loadedState.followers || 0;

                    // PACTの状態を確認し、必要に応じてボタンを非表示に
                    if (gameState.pacts?.active?.includes('1')) {
                        hideManualRecruitButtons();
                    }
                    // PACTの効果を再適用
                    if (gameState.pacts?.active?.length > 0) {
                        gameState.pacts.active.forEach(pactId => {
                            if (PACTS[pactId]) {
                                const pact = PACTS[pactId];
                                if (pact) {
                                    pact.effects.forEach(effect => {
                                        switch (effect.type) {
                                            case "minimumFollowers":
                                                gameState.minimumFollowers = Math.max(gameState.minimumFollowers || 0, effect.value);
                                                break;
                                            case "followerEfficiency":
                                                gameState.followerEfficiency *= (1 + effect.value);
                                                break;
                                            case "globalMultiplier":
                                                gameState.pacts.commonMultiplier *= (1 + effect.value);
                                                break;
                                            case "tickSpeed":
                                                gameState.pacts.tickSpeedMultiplier *= (1 + effect.value);
                                                break;
                                        }
                                    });
                                }
                            }
                        });
                    }

                    // フォロワー数を更新（最小値を考慮）
                    gameState.followers = Math.max(savedFollowers, gameState.minimumFollowers || 0);

                    // オフラインプログレスの処理
                    const lastUpdateTime = gameState.statistics?.lastUpdate || Date.now();
                    const currentTime = Date.now();
                    const offlineTime = currentTime - lastUpdateTime;

                    // 最小オフライン時間（1分）を超えている場合のみ処理
                    if (offlineTime >= 60 * 1000) {
                        const progress = processOfflineProgress(offlineTime);

                        // DOMが読み込まれているか確認
                        if (document.readyState === 'complete') {
                            showOfflineProgressModal(progress);
                        } else {
                            window.addEventListener('load', () => {
                                showOfflineProgressModal(progress);
                            });
                        }
                    }

                    // 統計情報を更新
                    if (gameState.statistics) {
                        gameState.statistics.lastUpdate = Date.now();
                    }

                    // 表示を更新
                    updateAllDisplays();
                    updateTimeAccelerationDisplay();

                    logAction("Game loaded successfully");
                    return true;

                } catch (error) {
                    console.error("Error loading game:", error);
                    // エラー時は初期状態を設定
                    gameState.unlockedContent = {
                        monsters: new Set(['Shoggoth']),
                        adventurers: new Set(['Novice Explorer']),
                        upgrades: new Set(['Ritual Knowledge']),
                        resources: new Set()
                    };
                    return false;
                }
            }

            // ヘルパー関数
            function isValidJSON(str) {
                try {
                    JSON.parse(str);
                    return true;
                } catch (e) {
                    return false;
                }
            }

            function validateGameState() {
                try {
                    // unlockedContentの検証と修正
                    if (!gameState.unlockedContent) {
                        gameState.unlockedContent = {
                            adventurers: new Set(['Novice Explorer']),
                            monsters: new Set(['Shoggoth']),
                            upgrades: new Set(['Ritual Knowledge']),
                            resources: new Set()
                        };
                    } else {
                        // 各カテゴリーの存在確認とSet型への変換
                        const categories = ['adventurers', 'monsters', 'upgrades', 'resources'];
                        for (const category of categories) {
                            if (!gameState.unlockedContent[category]) {
                                gameState.unlockedContent[category] = new Set();
                            } else if (!(gameState.unlockedContent[category] instanceof Set)) {
                                gameState.unlockedContent[category] = new Set(Array.from(gameState.unlockedContent[category]));
                            }
                        }

                        // 基本要素のアンロックを保証
                        gameState.unlockedContent.adventurers.add('Novice Explorer');
                        gameState.unlockedContent.monsters.add('Shoggoth');
                        gameState.unlockedContent.upgrades.add('Ritual Knowledge');
                    }

                    // 数値プロパティの検証と修正
                    const numericProps = {
                        source: { default: 0, min: 0 },
                        miasma: { default: 0, min: 0 },
                        cultos: { default: 0, min: 0 },
                        cultosRate: { default: 0, min: 0 },
                        followers: { default: 0, min: 0 },
                        followerEfficiency: { default: 0.1, min: 0.1 },
                        followerAccumulator: { default: 0, min: 0 },
                        cosmicAlignmentBonus: { default: 1, min: 1 },
                        astralProjectionRate: { default: 0, min: 0 },
                        quantumEntanglementBonus: { default: 0, min: 0 },
                        temporalManipulationBonus: { default: 1, min: 1 },
                        eldritchEvolutionRate: { default: 0, min: 0 },
                        upgradeCostMultiplier: { default: 1, min: 0.1 }
                    };

                    for (const [prop, config] of Object.entries(numericProps)) {
                        if (typeof gameState[prop] !== 'number' ||
                            isNaN(gameState[prop]) ||
                            !isFinite(gameState[prop]) ||
                            gameState[prop] < config.min) {
                            gameState[prop] = config.default;
                        }
                    }

                    // モンスターデータの検証
                    if (!gameState.monsters) {
                        gameState.monsters = JSON.parse(JSON.stringify(initialGameState.monsters));
                    } else {
                        for (const monsterType in initialGameState.monsters) {
                            if (!gameState.monsters[monsterType]) {
                                gameState.monsters[monsterType] = JSON.parse(JSON.stringify(initialGameState.monsters[monsterType]));
                            } else {
                                const monster = gameState.monsters[monsterType];
                                // 必須プロパティの検証
                                const requiredProps = {
                                    count: { default: 0, min: 0 },
                                    sourceEfficiency: { default: monsterEfficiencies[monsterType].sourceEfficiency, min: 0 },
                                    miasmaEfficiency: { default: monsterEfficiencies[monsterType].miasmaEfficiency, min: 0 },
                                    baseFollowerCost: { default: initialGameState.monsters[monsterType].baseFollowerCost, min: 1 },
                                    followerCostGrowth: { default: initialGameState.monsters[monsterType].followerCostGrowth, min: 1 }
                                };

                                for (const [prop, config] of Object.entries(requiredProps)) {
                                    if (typeof monster[prop] !== 'number' ||
                                        isNaN(monster[prop]) ||
                                        !isFinite(monster[prop]) ||
                                        monster[prop] < config.min) {
                                        monster[prop] = config.default;
                                    }
                                }

                                // シナジーとスペシャルアビリティの検証
                                if (!monster.synergy || typeof monster.synergy !== 'object') {
                                    monster.synergy = initialGameState.monsters[monsterType].synergy;
                                }
                                if (!monster.specialAbility || typeof monster.specialAbility !== 'object') {
                                    monster.specialAbility = initialGameState.monsters[monsterType].specialAbility;
                                }
                            }
                        }
                    }

                    // アドベンチャラーデータの検証
                    if (!Array.isArray(gameState.adventurers)) {
                        gameState.adventurers = JSON.parse(JSON.stringify(initialGameState.adventurers));
                    } else {
                        gameState.adventurers = gameState.adventurers.map((adventurer, index) => {
                            const defaultAdventurer = initialGameState.adventurers[index];
                            if (!adventurer || typeof adventurer !== 'object') {
                                return { ...defaultAdventurer };
                            }

                            return {
                                name: adventurer.name || defaultAdventurer.name,
                                miasmaRequired: validateNumber(adventurer.miasmaRequired, defaultAdventurer.miasmaRequired),
                                followerReward: validateNumber(adventurer.followerReward, defaultAdventurer.followerReward),
                                followerProduction: validateNumber(adventurer.followerProduction, defaultAdventurer.followerProduction),
                                madnessChance: validateNumber(adventurer.madnessChance, defaultAdventurer.madnessChance, 0, 1),
                                level: validateNumber(adventurer.level, 0),
                                isMad: !!adventurer.isMad,
                                cooldownEndTime: validateNumber(adventurer.cooldownEndTime, 0),
                                baseCooldown: validateNumber(adventurer.baseCooldown, defaultAdventurer.baseCooldown)
                            };
                        });
                    }

                    // アップグレードの検証
                    if (!Array.isArray(gameState.upgrades)) {
                        gameState.upgrades = [];
                    } else {
                        gameState.upgrades = gameState.upgrades.filter(upgrade =>
                            upgradeDefinitions.hasOwnProperty(upgrade)
                        );
                    }

                    // 契約システムの検証
                    if (!gameState.pacts || typeof gameState.pacts !== 'object') {
                        gameState.pacts = {
                            active: [],
                            commonMultiplier: 1,
                            tickSpeedMultiplier: 1,
                            showingPactModal: false
                        };
                    } else {
                        if (!Array.isArray(gameState.pacts.active)) gameState.pacts.active = [];
                        gameState.pacts.commonMultiplier = validateNumber(gameState.pacts.commonMultiplier, 1, 1);
                        gameState.pacts.tickSpeedMultiplier = validateNumber(gameState.pacts.tickSpeedMultiplier, 1, 1);
                        gameState.pacts.showingPactModal = !!gameState.pacts.showingPactModal;
                    }

                    // 統計情報の検証
                    if (!gameState.statistics || typeof gameState.statistics !== 'object') {
                        gameState.statistics = {
                            startTime: Date.now(),
                            lastUpdate: Date.now(),
                            totalSourceGenerated: 0,
                            totalMiasmaGenerated: 0,
                            totalFollowersRecruited: 0,
                            peakFollowers: 0,
                            totalMonstersSummoned: 0,
                            totalMadnessAttempts: 0,
                            successfulMadness: 0
                        };
                    } else {
                        const now = Date.now();
                        gameState.statistics.startTime = validateNumber(gameState.statistics.startTime, now);
                        gameState.statistics.lastUpdate = validateNumber(gameState.statistics.lastUpdate, now);
                        gameState.statistics.totalSourceGenerated = validateNumber(gameState.statistics.totalSourceGenerated, 0);
                        gameState.statistics.totalMiasmaGenerated = validateNumber(gameState.statistics.totalMiasmaGenerated, 0);
                        gameState.statistics.totalFollowersRecruited = validateNumber(gameState.statistics.totalFollowersRecruited, 0);
                        gameState.statistics.peakFollowers = validateNumber(gameState.statistics.peakFollowers, 0);
                        gameState.statistics.totalMonstersSummoned = validateNumber(gameState.statistics.totalMonstersSummoned, 0);
                        gameState.statistics.totalMadnessAttempts = validateNumber(gameState.statistics.totalMadnessAttempts, 0);
                        gameState.statistics.successfulMadness = validateNumber(gameState.statistics.successfulMadness, 0);
                    }

                    return true;
                } catch (error) {
                    console.error("Error in validateGameState:", error);
                    return false;
                }
            }

            // 補助関数: 数値の検証
            function validateNumber(value, defaultValue, min = -Infinity, max = Infinity) {
                if (typeof value !== 'number' || isNaN(value) || !isFinite(value) || value < min || value > max) {
                    return defaultValue;
                }
                return value;
            }

            function showLoadSuccessNotification() {
                const notification = document.createElement('div');
                notification.className = 'load-success-notification';
                notification.textContent = 'Game loaded successfully!';
                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 3000);
            }

            function handleLoadError(error) {
                // エラー通知を表示
                const notification = document.createElement('div');
                notification.className = 'load-error-notification';
                notification.innerHTML = `
        <h3>Error Loading Game</h3>
        <p>${error.message}</p>
        <p>The game has been reset to prevent further issues.</p>
        <button onclick="this.parentElement.remove()">Close</button>
    `;
                document.body.appendChild(notification);

                // ゲーム状態をリセット
                resetGameState();
                rebuildUI();
            }

            // 新しい関数: アンロック後のUI更新専用
            function updateDisplaysAfterUnlock() {
                updateMonsterGrid();
                updateUpgradeGrid();
                updateMadnessTable();
                updateResourceDisplay();
                updateCultosMiner();
                updateUpgradeSymbols();
            }

            function updateAllDisplays() {
                console.log('Updating all displays');
                updateResourceDisplay();
                updateUpgradeGrid();
                updateMonsterCards();
                updateAdventurerCards();
                updateGameDetails();
                updateMadnessTable();
                updateUnlockStatus(true);
                updateProgressBars();
                updateUpgradeSymbols();
                updateCultosMiner();
                updateRecruitFollowerButton();
            }

            // エラー時のリカバリー処理
            function attemptDataRecovery() {
                const backup = localStorage.getItem('cultistComplexSave_backup');
                if (backup && isValidJSON(backup)) {
                    localStorage.setItem('cultistComplexSave', backup);
                    return true;
                }
                return false;
            }

            function processOfflineProgress(offlineTime) {
                try {
                    const offlineSeconds = offlineTime / 1000;
                    const timeMultiplier = timeAcceleration * (gameState.pacts?.tickSpeedMultiplier || 1);

                    // PACTの条件をチェック
                    let shouldPauseProduction = false;
                    if (!gameState.pacts.active.includes('1') && gameState.source >= 1e6 - 1) {
                        shouldPauseProduction = true;
                    } else if (gameState.pacts.active.includes('1') && !gameState.pacts.active.includes('2') &&
                        gameState.source >= 1e28 - 1) {
                        shouldPauseProduction = true;
                    }

                    // 基本的な生産量を計算
                    const baseProduction = calculateResourceProduction();
                    const offlineProgress = {
                        source: shouldPauseProduction ? 0 : baseProduction.sourceProduction * offlineSeconds * timeMultiplier,
                        miasma: shouldPauseProduction ? 0 : baseProduction.miasmaProduction * offlineSeconds * timeMultiplier,
                        followers: 0,
                        cultos: 0
                    };

                    // アドベンチャラーの処理を修正
                    if (gameState.adventurers) {
                        gameState.adventurers.forEach((adventurer, index) => {
                            const currentTime = Date.now();

                            // クールダウン中だった場合の処理
                            if (adventurer.cooldownEndTime > 0) {
                                if (currentTime >= adventurer.cooldownEndTime) {
                                    // クールダウンが終了している場合
                                    adventurer.cooldownEndTime = 0;
                                    if (adventurer.isMad) {
                                        adventurer.isMad = false;
                                        logAction(`${adventurer.name} has returned to sanity!`);
                                    }
                                }
                            }

                            // 狂気状態での生産計算
                            if (adventurer.isMad) {
                                const remainingCooldown = Math.max(0, adventurer.cooldownEndTime - currentTime);
                                const activeTime = offlineTime - remainingCooldown;

                                if (activeTime > 0) {
                                    const followerProduction = calculateFollowerProduction(adventurer);
                                    const productionPerSecond = followerProduction / (adventurer.baseCooldown / 1000);
                                    offlineProgress.followers += productionPerSecond * (activeTime / 1000);
                                }
                            }
                        });
                    }

                    // Cultosの生産を処理
                    if (gameState.unlockedContent?.resources?.has('cultos')) {
                        const cultosRate = calculateCultosRate();
                        offlineProgress.cultos = cultosRate * offlineSeconds * timeMultiplier;
                    }

                    // リソースを更新（PACTの条件を考慮）
                    if (!shouldPauseProduction) {
                        gameState.source += offlineProgress.source;
                        gameState.miasma += offlineProgress.miasma;
                    }

                    // フォロワー数を更新（契約の最小値を考慮）
                    let minimumFollowers = 0;
                    if (gameState.pacts?.active) {
                        gameState.pacts.active.forEach(pactId => {
                            const pact = PACTS[pactId];
                            if (pact) {
                                pact.effects.forEach(effect => {
                                    if (effect.type === "minimumFollowers") {
                                        minimumFollowers = Math.max(minimumFollowers, effect.value);
                                    }
                                });
                            }
                        });
                    }

                    gameState.followers = Math.max(
                        gameState.followers + offlineProgress.followers,
                        minimumFollowers
                    );

                    // Cultosを更新
                    if (offlineProgress.cultos > 0) {
                        gameState.cultos = (gameState.cultos || 0) + offlineProgress.cultos;
                    }

                    // 統計情報を更新
                    if (gameState.statistics) {
                        gameState.statistics.totalSourceGenerated += offlineProgress.source;
                        gameState.statistics.totalMiasmaGenerated += offlineProgress.miasma;
                        gameState.statistics.lastUpdate = Date.now();
                    }

                    return {
                        timeAway: formatTime(Math.floor(offlineSeconds)),
                        source: formatNumber(offlineProgress.source),
                        miasma: formatNumber(offlineProgress.miasma),
                        followers: formatNumber(offlineProgress.followers),
                        cultos: formatNumber(offlineProgress.cultos),
                        productionPaused: shouldPauseProduction
                    };

                } catch (error) {
                    console.error("Error processing offline progress:", error);
                    return {
                        timeAway: "Error",
                        source: "0",
                        miasma: "0",
                        followers: "0",
                        cultos: "0",
                        productionPaused: false
                    };
                }
            }

            function showOfflineProgressModal(progress) {
                try {
                    debug("Attempting to show offline progress modal");

                    // 既存のモーダルがあれば削除
                    const existingModal = document.querySelector('.offline-progress-modal');
                    if (existingModal) {
                        existingModal.remove();
                        debug("Removed existing modal");
                    }

                    // 時間を適切にフォーマット
                    const timeAway = progress.timeAway;

                    const modalHtml = `
    <div class="offline-progress-modal modal-overlay" style="
        position: fixed !important;
        top: 50% !important;
        left: 50% !important;
        transform: translate(-50%, -50%) !important;
        width: 100vw !important;
        height: 100vh !important;
        background-color: rgba(0, 0, 0, 0.7) !important;
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        z-index: 999999999 !important;
        visibility: visible !important;
        opacity: 1 !important;
        pointer-events: auto !important;">
        <div class="modal-content" style="
            position: relative !important;
            background-color: #1a1a1a !important;
            border: 2px solid #4CAF50 !important;
            border-radius: 8px !important;
            padding: 20px !important;
            max-width: 500px !important;
            width: 90% !important;
            color: #e0e0e0 !important;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.3) !important;
            margin: 0 auto !important;
            transform: none !important;
            top: auto !important;
            left: auto !important;
            right: auto !important;
            bottom: auto !important;">
            <h2 style="color: #4CAF50 !important; margin-bottom: 15px !important; text-align: center !important;">Offline Progress</h2>
            <p style="margin-bottom: 10px !important; text-align: center !important;">Welcome back! You were away for ${progress.timeAway}</p>
            ${progress.productionPaused ?
                            `<p style="color: #ff9800; margin: 10px 0 !important; text-align: center !important;">
                    Resource production is paused until you accept the pending PACT
                </p>` : ''}
            <div class="progress-details" style="margin-bottom: 15px !important;">
                <p style="margin: 5px 0 !important;">Source gained: ${progress.source}</p>
                <p style="margin: 5px 0 !important;">Miasma gained: ${progress.miasma}</p>
                <p style="margin: 5px 0 !important;">Followers gained: ${progress.followers}</p>
                ${progress.cultos > 0 ? `<p style="margin: 5px 0 !important;">Cultos earned: ${progress.cultos}</p>` : ''}
            </div>
            <div class="production-details" style="margin-bottom: 15px !important;">
                <p style="margin: 5px 0 !important;">Current Production Rates:</p>
                <p style="margin: 5px 0 !important;">Source: ${formatNumber(calculateResourceProduction().sourceProduction)}/sec</p>
                <p style="margin: 5px 0 !important;">Miasma: ${formatNumber(calculateResourceProduction().miasmaProduction)}/sec</p>
                <p style="margin: 5px 0 !important;">Followers: ${formatNumber(calculateResourceProduction().followerProduction)}/sec</p>
            </div>
            <div style="text-align: center !important;">
                <button onclick="this.closest('.offline-progress-modal').remove()" style="
                    background-color: #4CAF50 !important;
                    color: white !important;
                    border: none !important;
                    padding: 8px 16px !important;
                    border-radius: 4px !important;
                    cursor: pointer !important;
                    margin-top: 10px !important;
                    font-size: 16px !important;">Close</button>
            </div>
        </div>
    </div>`;

                    // モーダルをbodyに追加
                    const gameContainer = document.querySelector('.container');
                    if (gameContainer) {
                        gameContainer.insertAdjacentHTML('beforeend', modalHtml);
                        debug("Modal added to game container");
                    } else {
                        document.body.insertAdjacentHTML('beforeend', modalHtml);
                        debug("Modal added to body (fallback)");
                    }
                    debug("Modal HTML inserted and centered");

                    // モーダルが正しく表示されているか確認
                    const addedModal = document.querySelector('.offline-progress-modal');
                    if (addedModal) {
                        debug("Modal successfully added to DOM");
                    } else {
                        debug("Warning: Modal not found in DOM after insertion");
                    }

                } catch (error) {
                    console.error("Error showing offline progress modal:", error);
                    debug(`Error showing modal: ${error.message}`);

                    // エラーが発生した場合でもユーザーに通知
                    logAction("Failed to show offline progress. Error: " + error.message);

                    // 最小限のフォールバックモーダルを表示
                    try {
                        const fallbackModal = document.createElement('div');
                        fallbackModal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                padding: 20px;
                border: 2px solid red;
                z-index: 999999999;
            `;
                        fallbackModal.innerHTML = `
                <h3>Offline Progress Error</h3>
                <p>There was an error showing your offline progress.</p>
                <button onclick="this.parentElement.remove()">Close</button>
            `;
                        document.body.appendChild(fallbackModal);
                    } catch (fallbackError) {
                        console.error("Failed to show fallback error modal:", fallbackError);
                    }
                }
            }

            // handleOfflineProgress関数も修正
            function handleOfflineProgress() {
                try {
                    const lastSaveTime = gameState.statistics?.lastUpdate || Date.now();
                    const currentTime = Date.now();
                    const offlineTime = currentTime - lastSaveTime;

                    debug(`Checking offline progress: ${offlineTime}ms elapsed`);

                    // 最小オフライン時間を1分に設定
                    const minimumOfflineTime = 60 * 1000; // 1分をミリ秒で表現

                    if (offlineTime >= minimumOfflineTime) {
                        debug("Processing offline progress...");
                        const progress = processOfflineProgress(offlineTime);

                        // 確実にDOMが読み込まれてから実行
                        if (document.readyState === 'complete') {
                            debug("DOM is ready, showing modal immediately");
                            showOfflineProgressModal(progress);
                        } else {
                            debug("DOM not ready, waiting for load event");
                            window.addEventListener('load', () => {
                                debug("DOM now loaded, showing modal");
                                showOfflineProgressModal(progress);
                            });
                        }

                        // 最終更新時刻を更新
                        if (gameState.statistics) {
                            gameState.statistics.lastUpdate = currentTime;
                        }

                        saveGame();
                    } else {
                        debug("Not enough time elapsed for offline progress");
                    }
                } catch (error) {
                    console.error("Error in handleOfflineProgress:", error);
                    debug(`Error handling offline progress: ${error.message}`);
                }
            }

            function validateMonsters(monsters) {
                const validatedMonsters = {};
                for (let monsterName in monsters) {
                    if (monsters.hasOwnProperty(monsterName)) {
                        validatedMonsters[monsterName] = {
                            count: validateNumber(monsters[monsterName].count, 0),
                            sourceEfficiency: validateNumber(monsters[monsterName].sourceEfficiency, gameState.monsters[monsterName].sourceEfficiency),
                            miasmaEfficiency: validateNumber(monsters[monsterName].miasmaEfficiency, gameState.monsters[monsterName].miasmaEfficiency),
                            baseFollowerCost: validateNumber(monsters[monsterName].baseFollowerCost, gameState.monsters[monsterName].baseFollowerCost),
                            followerCostGrowth: validateNumber(monsters[monsterName].followerCostGrowth, gameState.monsters[monsterName].followerCostGrowth),
                            synergy: monsters[monsterName].synergy || gameState.monsters[monsterName].synergy,
                            specialAbility: validateSpecialAbility(monsters[monsterName].specialAbility, gameState.monsters[monsterName].specialAbility)
                        };
                    }
                }
                return validatedMonsters;
            }

            function validateSpecialAbility(loadedAbility, defaultAbility) {
                if (!loadedAbility) return defaultAbility;

                return {
                    trigger: validateNumber(loadedAbility.trigger, defaultAbility.trigger),
                    effect: {
                        type: loadedAbility.effect.type || defaultAbility.effect.type,
                        value: validateNumber(loadedAbility.effect.value, defaultAbility.effect.value),
                        maxDiscount: loadedAbility.effect.maxDiscount !== undefined ?
                            validateNumber(loadedAbility.effect.maxDiscount, defaultAbility.effect.maxDiscount) :
                            defaultAbility.effect.maxDiscount
                    }
                };
            }

            function resetGameWithPersistentEffects() {
                // 永続的な効果を保存
                const persistentState = {
                    pacts: {
                        active: [...gameState.pacts.active],
                        commonMultiplier: gameState.pacts.commonMultiplier,
                        tickSpeedMultiplier: gameState.pacts.tickSpeedMultiplier
                    },
                    unlockedContent: {
                        adventurers: new Set([...gameState.unlockedContent.adventurers]),
                        monsters: new Set([...gameState.unlockedContent.monsters]),
                        upgrades: new Set([...gameState.unlockedContent.upgrades])
                    },
                    upgrades: [], // アップグレードは完全にリセット
                    statistics: { ...gameState.statistics },
                    minimumFollowers: 0,
                    followerEfficiency: 0.1 // 基本値
                };

                // 契約による最小フォロワー数と効率の計算
                gameState.pacts.active.forEach(pactId => {
                    const pact = PACTS[pactId];
                    if (pact) {
                        pact.effects.forEach(effect => {
                            switch (effect.type) {
                                case "minimumFollowers":
                                    persistentState.minimumFollowers = Math.max(persistentState.minimumFollowers, effect.value);
                                    break;
                                case "followerEfficiency":
                                    persistentState.followerEfficiency *= (1 + effect.value);
                                    break;
                            }
                        });
                    }
                });

                // ゲーム状態を初期状態にリセット
                gameState = JSON.parse(JSON.stringify(initialGameState));

                // 永続的な効果を復元
                gameState.pacts = persistentState.pacts;
                gameState.unlockedContent = persistentState.unlockedContent;
                gameState.upgrades = persistentState.upgrades;
                gameState.statistics = persistentState.statistics;

                // フォロワー関連の値を設定
                gameState.followers = persistentState.minimumFollowers;
                gameState.followerEfficiency = persistentState.followerEfficiency;

                // localStorage に永続的な状態を保存
                const persistentData = {
                    pacts: gameState.pacts,
                    followers: gameState.followers,
                    followerEfficiency: gameState.followerEfficiency,
                    unlockedContent: {
                        adventurers: Array.from(gameState.unlockedContent.adventurers),
                        monsters: Array.from(gameState.unlockedContent.monsters),
                        upgrades: Array.from(gameState.unlockedContent.upgrades)
                    }
                };
                localStorage.setItem('cultistComplexPersistent', JSON.stringify(persistentData));

                // UI の更新
                if (gameState.pacts.active.includes('1')) {
                    hideManualRecruitButtons();
                }

                // 完全な UI 更新
                updateAllDisplays();
                updateUnlockSystem();
                updateCultosMiner();
                updateUpgradeSymbols();

                logAction("Game has been reset while maintaining permanent effects");
            }

            function resetGameAndClearSave() {
                if (confirm("Are you sure you want to reset the game? This will erase all progress and cannot be undone.")) {
                    const currentTickSpeed = timeAcceleration;
                    // ゲーム状態を初期状態にリセット
                    gameState = JSON.parse(JSON.stringify(initialGameState));

                    // tickSpeedを復元
                    timeAcceleration = currentTickSpeed;

                    // Setオブジェクトの再初期化
                    gameState.unlockedContent = {
                        adventurers: new Set(['Novice Explorer']),
                        monsters: new Set(['Shoggoth']),
                        upgrades: new Set(['Ritual Knowledge']),
                        resources: new Set()
                    };

                    // 契約システムのリセット
                    gameState.pacts = {
                        active: [],
                        commonMultiplier: 1,
                        tickSpeedMultiplier: 1,
                        showingPactModal: false
                    };

                    // 統計情報のリセット
                    gameState.statistics = {
                        startTime: Date.now(),
                        lastUpdate: Date.now(),
                        totalSourceGenerated: 0,
                        totalMiasmaGenerated: 0,
                        totalFollowersRecruited: 0,
                        peakFollowers: 0,
                        totalMonstersSummoned: 0,
                        totalMadnessAttempts: 0,
                        successfulMadness: 0
                    };

                    // モンスターの初期化
                    for (const monsterName in gameState.monsters) {
                        gameState.monsters[monsterName] = {
                            count: 0,
                            baseSourceCost: gameState.monsters[monsterName].baseSourceCost
                        };
                    }

                    // ローカルストレージをクリア
                    localStorage.removeItem('gameState');

                    // DOMをリセット
                    resetDOM();

                    // UIを完全に再構築
                    rebuildUI();

                    // 手動リクルートボタンを表示し、封印状態をリセット
                    const recruitButton = document.getElementById('recruitFollowerBtn');
                    if (recruitButton) {
                        recruitButton.style.display = 'block';
                        recruitButton.classList.remove('sealed-by-pact');
                        recruitButton.disabled = false;
                        recruitButton.title = '';
                    }

                    // 全ての表示を更新
                    updateDisplay();
                    updateAllDisplays();

                    // エンブレムを更新
                    updateCultosMiner();

                    // ゲームの状態を検証
                    validateGameState();

                    logAction("Game has been reset to initial state");
                }
            }


            // 新しいゲームの初期化やリセット時には、initialGameStateのディープコピーを使用
            function resetGameState() {
                debug("Resetting game state to initial values");
                gameState = JSON.parse(JSON.stringify(initialGameState));

                // Set型のプロパティを再初期化（これらはJSONでは正しく保存/復元できないため）
                gameState.unlockedContent = {
                    monsters: new Set(['Shoggoth']),
                    adventurers: new Set(['Novice Explorer']),
                    upgrades: new Set(['Ritual Knowledge']),
                    resources: new Set()
                };

                // 統計情報の初期化
                gameState.statistics = {
                    startTime: Date.now(),
                    lastUpdate: Date.now(),
                    totalSourceGenerated: 0,
                    totalMiasmaGenerated: 0,
                    totalFollowersRecruited: 0,
                    peakFollowers: 0,
                    totalMonstersSummoned: 0,
                    totalMadnessAttempts: 0,
                    successfulMadness: 0
                };

                isSummoning = false;
                debug("Game state reset complete");
                return gameState;
            }

            function resetUIElements() {
                // ボタンの表示状態をリセット
                const collectSourceBtn = document.getElementById('collectSource');
                const recruitFollowerBtn = document.getElementById('recruitFollowerBtn');
                if (collectSourceBtn) {
                    collectSourceBtn.style.display = 'block';
                    collectSourceBtn.classList.remove('sealed-by-pact');
                }
                if (recruitFollowerBtn) {
                    recruitFollowerBtn.style.display = 'block';
                    recruitFollowerBtn.classList.remove('sealed-by-pact');
                }

                // フォロワーのアスキーアートをリセット
                const followerArt = document.getElementById('followerAsciiArt');
                if (followerArt) {
                    followerArt.innerHTML = asciiArt['Follower'];
                    followerArt.title = '';
                    followerArt.classList.remove('transforming', 'transformed');
                }

                // フォロワーセクションの完全なリセット
                const followerSection = document.getElementById('followerSection');
                if (followerSection) {
                    updateFollowerSection();  // 完全な再構築を行う
                }

                // ボタンの表示状態を確実にリセット
                showManualRecruitButtons();  // 明示的にボタンを表示

                // その他のUI更新
                updateResourceDisplay();
                updateMonsterCards();
                updateUpgradeCards();
                updateAdventurerCards();
                updateGameDetails();
                updateMadnessTable();
                updateUnlockStatus();
                updateProgressBars();
                updateUpgradeSymbols();
                updateCultosMiner();
            }

            function rebuildUI() {
                // リソース表示の更新
                updateResourceDisplay();

                // フォロワーセクションの再構築
                updateFollowerSection();

                // モンスターグリッドの完全なリセットと再構築
                const monsterGrid = document.getElementById('monsterGrid');
                if (monsterGrid) {
                    monsterGrid.innerHTML = '';
                    updateMonsterGrid();
                }

                // アップグレードグリッドの完全なリセットと再構築
                const upgradeGrid = document.getElementById('upgradeGrid');
                if (upgradeGrid) {
                    upgradeGrid.innerHTML = '';
                    updateUpgradeGrid();
                }

                // アドベンチャラーテーブルの完全なリセットと再構築
                const adventurersContainer = document.getElementById('adventurers');
                if (adventurersContainer) {
                    adventurersContainer.innerHTML = '';
                    updateMadnessTable();
                }

                // アップグレードシンボルの完全なリセット
                const symbolsContainer = document.getElementById('upgradeSymbols');
                if (symbolsContainer) {
                    symbolsContainer.innerHTML = '';
                    updateUpgradeSymbols();
                }

                // エンブレムの更新
                updateCultosMiner();

                // ゲーム詳細の更新
                updateGameDetails();

                // 手動リクルートボタンの表示状態を更新
                if (gameState.pacts.active.includes('1')) {
                    hideManualRecruitButtons();
                } else {
                    showManualRecruitButtons();
                }

                // 全ての表示を最終更新
                updateAllDisplays();
            }

            function resetDOM() {
                debug("Starting DOM reset");

                try {
                    // リソース表示のリセット
                    const resourceElements = {
                        'largeSourceCount': '0',
                        'largeSourcePerSecond': '0',
                        'largeMiasmaCount': '0',
                        'largeMiasmaPerSecond': '0'
                    };

                    for (const [id, value] of Object.entries(resourceElements)) {
                        const element = document.getElementById(id);
                        if (element) {
                            element.textContent = value;
                        } else {
                            debug(`Warning: Element ${id} not found`);
                        }
                    }

                    // フォロワーセクションの再構築
                    const followerSection = document.getElementById('followerSection');
                    if (followerSection) {
                        debug("Updating follower section");
                        updateFollowerSection();
                    } else {
                        debug("Warning: Follower section not found");
                    }

                    // モンスターグリッドのリセット
                    const monsterGrid = document.getElementById('monsterGrid');
                    if (monsterGrid) {
                        debug("Resetting monster grid");
                        monsterGrid.innerHTML = '';
                        updateMonsterGrid();
                    } else {
                        debug("Warning: Monster grid not found");
                    }

                    // アップグレードグリッドのリセット
                    const upgradeGrid = document.getElementById('upgradeGrid');
                    if (upgradeGrid) {
                        debug("Resetting upgrade grid");
                        upgradeGrid.innerHTML = '';
                        updateUpgradeGrid();
                    } else {
                        debug("Warning: Upgrade grid not found");
                    }

                    // 狂気テーブルのリセット
                    const madnessTable = document.getElementById('madnessTable');
                    if (madnessTable) {
                        debug("Updating madness table");
                        updateMadnessTable();
                    } else {
                        debug("Warning: Madness table not found");
                    }

                    // ログのクリア
                    const log = document.getElementById('log');
                    if (log) {
                        debug("Clearing log");
                        log.innerHTML = '';
                    } else {
                        debug("Warning: Log element not found");
                    }

                    // エンブレムのリセット
                    debug("Updating cultosminer");
                    updateCultosMiner();

                    debug("DOM reset completed successfully");
                } catch (error) {
                    console.error("Error during DOM reset:", error);
                    debug(`Error during DOM reset: ${error.message}`);
                }
            }

            function setupEventListeners() {
                debug("Setting up event listeners");

                document.addEventListener('click', (e) => {
                    const target = e.target;
                    if (target.matches('#recruitFollowerBtn')) {
                        recruitFollower();
                    } else if (target.matches('.summon-monster-btn')) {
                        summonMonster(target.dataset.monster);
                    } else if (target.matches('.madness-btn:not([disabled])')) {
                        attemptMadness(parseInt(target.dataset.index));
                    } else if (target.matches('.buy-upgrade-btn')) {
                        const upgradeId = target.dataset.upgrade;
                        if (upgradeId) {
                            buyUpgrade(upgradeId);
                        }
                    }
                });

                const toggleMadnessTableBtn = document.getElementById('toggleMadnessTable');
                if (toggleMadnessTableBtn) {
                    toggleMadnessTableBtn.addEventListener('click', toggleMadnessTable);
                    debug("Jump to Madness Table button listener added");  // コメントを更新
                } else {
                    debug("Jump to Madness Table button not found");  // コメントを更新
                }

                const backToTopBtn = document.getElementById("backToTopBtn");
                if (backToTopBtn) {
                    backToTopBtn.addEventListener("click", backToTop);
                    debug("Back to Top button listener added");
                } else {
                    debug("Back to Top button not found");
                }

                // セーブ・ロードボタンのイベントリスナー
                const saveLoadButtons = document.getElementById('saveLoadButtons');
                if (saveLoadButtons) {
                    const saveButton = saveLoadButtons.querySelector('button:nth-child(1)');
                    const loadButton = saveLoadButtons.querySelector('button:nth-child(2)');

                    if (saveButton) {
                        saveButton.addEventListener('click', saveGame);
                        debug("Save button listener added");
                    } else {
                        debug("Save button not found");
                    }

                    if (loadButton) {
                        loadButton.addEventListener('click', loadGame);
                        debug("Load button listener added");
                    } else {
                        debug("Load button not found");
                    }
                } else {
                    debug("Save/Load buttons container not found");
                }

                document.getElementById('spinButton')?.addEventListener('click', () => {
                    if (gameState.cultos >= drumState.currentBet) {
                        spinReels();
                    }
                });

                document.getElementById('autoSpinToggle')?.addEventListener('click', () => {
                    drumState.autoSpinEnabled = !drumState.autoSpinEnabled;
                    const button = document.getElementById('autoSpinToggle');
                    if (button) {
                        button.textContent = `AUTO: ${drumState.autoSpinEnabled ? 'ON' : 'OFF'}`;
                    }
                });

                document.getElementById('betButton')?.addEventListener('click', () => {
                    const betValues = [50, 100, 250, 500, 1000];
                    const currentIndex = betValues.indexOf(drumState.currentBet);
                    drumState.currentBet = betValues[(currentIndex + 1) % betValues.length];
                    const button = document.getElementById('betButton');
                    if (button) {
                        button.textContent = `BET: ${drumState.currentBet} ©️`;
                    }
                });
            }

            document.getElementById('pauseGameBtn').addEventListener('click', function () {
                gamePaused = !gamePaused;
                this.textContent = gamePaused ? 'Resume Game' : 'Pause Game';
                this.style.borderColor = gamePaused ? '#ff0000' : '#4CAF50';
                this.style.color = gamePaused ? '#ff0000' : '#e0e0e0';

                // Use logAction instead of addToLog
                logAction(gamePaused ? 'Game paused' : 'Game resumed');
            });

            let lastUpdateTime = Date.now();
            let accumulatedTime = 0;
            const TICK_RATE = 50; // 20 ticks per second

            let lastFrameTime = Date.now();

            function gameLoop() {
                try {
                    const currentTime = Date.now();

                    if (!gamePaused) {
                        const deltaTime = (currentTime - lastFrameTime) / 1000;
                        lastFrameTime = currentTime;

                        const timeMultiplier = timeAcceleration * (gameState.pacts?.tickSpeedMultiplier || 1);

                        const { sourceProduction, miasmaProduction, followerProduction } = calculateResourceProduction();

                        // フォロワーの蓄積処理を追加
                        if (followerProduction > 0) {
                            gameState.followerAccumulator = (gameState.followerAccumulator || 0) +
                                followerProduction * deltaTime * timeMultiplier;

                            // 蓄積が1以上になったら整数部分をフォロワーに追加
                            if (gameState.followerAccumulator >= 1) {
                                const newFollowers = Math.floor(gameState.followerAccumulator);
                                gameState.followers += newFollowers;
                                gameState.followerAccumulator -= newFollowers;
                            }
                        }
                        // リソースの更新
                        gameState.source += sourceProduction * deltaTime * timeMultiplier;
                        gameState.miasma += miasmaProduction * deltaTime * timeMultiplier;

                        // Cultos生産の処理
                        if (checkUnlockCondition('resources', 'cultos')) {
                            const cultosRate = calculateCultosRate(deltaTime);
                            if (cultosRate > 0) {
                                gameState.cultos += cultosRate * deltaTime * timeMultiplier;
                                gameState.cultos = Number(gameState.cultos.toFixed(12));
                                gameState.cultosRate = cultosRate * timeMultiplier;
                            }
                        }

                        // 契約による最小フォロワー数の保証
                        if (gameState.pacts?.active) {
                            let minimumFollowers = 0;
                            gameState.pacts.active.forEach(pactId => {
                                const pact = PACTS[pactId];
                                if (pact) {
                                    pact.effects.forEach(effect => {
                                        if (effect.type === "minimumFollowers") {
                                            minimumFollowers = Math.max(minimumFollowers, effect.value);
                                        }
                                    });
                                }
                            });
                            gameState.followers = Math.max(gameState.followers, minimumFollowers);
                        }

                        // モンスターの特殊能力の適用
                        applySpecialAbilities();

                        // アドベンチャラーの状態更新
                        updateAdventurerStates();

                        // アンロック状態の更新
                        checkNewUnlocks();
                        checkPacts();

                        // 統計情報の更新
                        if (gameState.statistics) {
                            // 総生産量の記録
                            gameState.statistics.totalSourceGenerated += sourceProduction * deltaTime * timeMultiplier;
                            gameState.statistics.totalMiasmaGenerated += miasmaProduction * deltaTime * timeMultiplier;

                            // ピークフォロワー数の更新
                            gameState.statistics.peakFollowers = Math.max(
                                gameState.statistics.peakFollowers || 0,
                                gameState.followers || 0
                            );

                            // 最終更新時刻の記録
                            gameState.statistics.lastUpdate = currentTime;
                        }

                        // 自動セーブの処理
                        const autoSaveInterval = 5 * 60 * 1000; // 5分
                        if (currentTime - (gameState.lastAutoSave || 0) >= autoSaveInterval) {
                            saveGame();
                            gameState.lastAutoSave = currentTime;
                        }

                        // 数値の検証と修正
                        sanitizeGameState();
                    }

                    // UI更新の間隔管理（一時停止中でも更新）
                    const now = Date.now();
                    Object.keys(UPDATE_INTERVALS).forEach(key => {
                        if (now - lastUpdateTimes[key] >= UPDATE_INTERVALS[key]) {
                            switch (key) {
                                case 'monsterGrid':
                                    updateMonsterGrid();
                                    break;
                                case 'followerSection':
                                    updateFollowerSection();
                                    break;
                                case 'madnessTable':
                                    updateMadnessTable();
                                    break;
                                case 'upgradeGrid':
                                    updateUpgradeGrid();
                                    break;
                                case 'gameDetails':
                                    updateGameDetails();
                                    break;
                            }
                            lastUpdateTimes[key] = now;
                        }
                    });

                    // 基本的なUI更新（毎フレーム）
                    updateResourceDisplay();
                    updateCultosMiner();
                    updateTimeAccelerationDisplay();
                    updateAllDisplays();

                    // ダイアログの処理（一時停止中は実行しない）
                    if (!gamePaused) {
                        const dialogChance = 0.02; // 2%の確率
                        if (Math.random() < dialogChance) {
                            randomDialogue();
                            showFollowerDialogue();
                        }
                    }

                    // 通知の整理
                    cleanupNotifications();

                } catch (error) {
                    console.error("Game loop error:", error);
                    handleGameLoopError(error);
                }

                // 次のフレームをリクエスト
                requestAnimationFrame(gameLoop);
            }

            // 補助関数：通知の整理
            function cleanupNotifications() {
                const container = document.getElementById('notifications-container');
                if (container && container.children.length > 5) {
                    // 古い通知を削除
                    while (container.children.length > 5) {
                        container.removeChild(container.firstChild);
                    }
                }
            }

            // ゲームループエラーのハンドリング
            function handleGameLoopError(error) {
                if (!gamePaused) {
                    // ゲームを一時停止
                    gamePaused = true;

                    // エラー通知を表示
                    const errorMessage = `Game paused due to error: ${error.message}. Check console for details.`;
                    logAction(errorMessage);

                    const notification = document.createElement('div');
                    notification.className = 'error-notification';
                    notification.innerHTML = `
            <h3>Game Error</h3>
            <p>${errorMessage}</p>
            <button onclick="resumeGame()">Try to Resume</button>
            <button onclick="this.parentElement.remove()">Close</button>
        `;
                    document.body.appendChild(notification);

                    // エラーログを出力
                    debug(`Game loop error: ${error.message}`);
                    console.error("Game loop error details:", error);

                    // バックアップの作成を試みる
                    try {
                        createBackup();
                    } catch (backupError) {
                        console.error("Failed to create backup:", backupError);
                    }
                }
            }

            // ゲームループの開始
            function startGameLoop() {
                lastFrameTime = Date.now();
                requestAnimationFrame(gameLoop);
                debug("Game loop started");
            }

            // エラーハンドリング関数を追加
            function handleGameError(error) {
                console.error("Game error:", error);
                logAction(`An error occurred: ${error.message}`);
            }

            function initializeUnlockedContent() {
                return {
                    adventurers: new Set(['Novice Explorer']),
                    monsters: new Set(['Shoggoth']),
                    upgrades: new Set(['Ritual Knowledge'])
                };
            }

            function initializeGame() {
                debug("Initializing game");

                try {
                    // 最終更新時刻の初期化
                    lastUpdateTimes = {
                        monsterGrid: 0,
                        followerSection: 0,
                        madnessTable: 0,
                        upgradeGrid: 0,
                        gameDetails: 0
                    };

                    // バージョン表示の更新
                    document.getElementById('version-display').textContent = `v${gameVersion}`;

                    // tickSpeed表示の初期化
                    const tickSpeedDisplay = document.getElementById('tickSpeedDisplay');
                    if (!tickSpeedDisplay) {
                        const container = document.createElement('div');
                        container.innerHTML = `
                <span>Tick Speed: <span id="tickSpeedDisplay" style="color: #4CAF50;">x1.00</span></span>
            `;
                        document.querySelector('#game-header div').appendChild(container);
                    }

                    // PACTの状態を確認
                    if (gameState.pacts?.active?.includes('1')) {
                        hideManualRecruitButtons();
                    }


                    // 既存の初期化処理
                    initializeGameState();
                    initializePactSystem();
                    setupTopButtons();
                    setupEventListeners();
                    setCultosMiner();

                    // セーブデータのロード
                    const savedGame = localStorage.getItem('cultistComplexSave');
                    if (savedGame) {
                        loadGame();
                    } else {
                        resetGameState();
                        rebuildUI();
                    }

                    // UI更新
                    updateCultosMiner();
                    updateDisplay();
                    updateTimeAccelerationDisplay();

                    debug("Game initialization complete");
                } catch (error) {
                    console.error("Error during game initialization:", error);
                    handleInitializationError(error);
                }
            }

            // 関連するゲーム状態の初期化関数も更新
            function initializeGameState() {
                debug("Initializing game state");

                // gameStateが未定義の場合は完全に新しい状態を作成
                if (!gameState) {
                    gameState = JSON.parse(JSON.stringify(initialGameState));
                }

                // 基本プロパティの確認と初期化
                const baseProps = {
                    source: 0,
                    miasma: 0,
                    followers: 0,
                    followerEfficiency: 0.1,
                    followerAccumulator: 0,
                    cosmicAlignmentBonus: 1,
                    astralProjectionRate: 0,
                    quantumEntanglementBonus: 0,
                    temporalManipulationBonus: 1,
                    eldritchEvolutionRate: 0,
                    upgradeCostMultiplier: 1
                };

                // 基本プロパティの初期化
                for (const [prop, defaultValue] of Object.entries(baseProps)) {
                    if (typeof gameState[prop] !== 'number' || isNaN(gameState[prop])) {
                        debug(`Initializing ${prop} to default value: ${defaultValue}`);
                        gameState[prop] = defaultValue;
                    }
                }

                // バージョン情報の設定
                gameState.version = gameVersion;

                // unlockedContentの初期化を確実に行う
                if (!gameState.unlockedContent) {
                    gameState.unlockedContent = {
                        adventurers: new Set(['Novice Explorer']),
                        monsters: new Set(['Shoggoth']),
                        upgrades: new Set(['Ritual Knowledge']),
                        resources: new Set()
                    };
                } else {
                    // 既存のunlockedContentを確実にSetオブジェクトに変換
                    gameState.unlockedContent = {
                        adventurers: new Set(Array.from(gameState.unlockedContent.adventurers || ['Novice Explorer'])),
                        monsters: new Set(Array.from(gameState.unlockedContent.monsters || ['Shoggoth'])),
                        upgrades: new Set(Array.from(gameState.unlockedContent.upgrades || ['Ritual Knowledge'])),
                        resources: new Set(Array.from(gameState.unlockedContent.resources || []))
                    };
                }

                // モンスターデータの初期化
                if (!gameState.monsters) {
                    gameState.monsters = JSON.parse(JSON.stringify(initialGameState.monsters));
                }

                // アドベンチャラーの初期化
                if (!Array.isArray(gameState.adventurers)) {
                    gameState.adventurers = JSON.parse(JSON.stringify(initialGameState.adventurers));
                }

                // 統計情報の初期化
                if (!gameState.statistics) {
                    gameState.statistics = {
                        startTime: Date.now(),
                        lastUpdate: Date.now(),
                        totalSourceGenerated: 0,
                        totalMiasmaGenerated: 0,
                        totalFollowersRecruited: 0,
                        peakFollowers: 0,
                        totalMonstersSummoned: 0,
                        totalMadnessAttempts: 0,
                        successfulMadness: 0
                    };
                }

                // 契約システムの初期化
                if (!gameState.pacts) {
                    gameState.pacts = {
                        active: [],
                        commonMultiplier: 1,
                        tickSpeedMultiplier: 1,
                        showingPactModal: false
                    };
                }

                debug("Game state initialization complete");
                return gameState;
            }

            document.addEventListener('DOMContentLoaded', function () {
                const topButtons = document.getElementById('top-buttons');
                const statsButton = document.getElementById('toggleStatistics');

                if (statsButton) {
                    statsButton.addEventListener('click', toggleStatisticsModal);
                }

                // Initialize modal
                const modal = document.getElementById('statisticsModal');
                if (modal) {
                    modal.style.display = 'none';
                    modal.classList.remove('active');
                }
            });

            // Statistics モーダルを開閉する関数
            function toggleStatisticsModal() {
                const modal = document.getElementById('statisticsModal');
                if (modal) {
                    if (modal.classList.contains('active')) {
                        modal.classList.remove('active');
                        modal.style.display = 'none';
                    } else {
                        modal.classList.add('active');
                        modal.style.display = 'block';
                        updateStatistics(); // 統計情報を更新
                    }
                }
            }

            // Modify existing game functions to track statistics
            const originalGameLoop = gameLoop;
            gameLoop = function () {
                const before = {
                    source: gameState.source,
                    miasma: gameState.miasma
                };

                originalGameLoop();

                if (gameState.statistics) {
                    gameState.statistics.totalSourceGenerated += Math.max(0, gameState.source - before.source);
                    gameState.statistics.totalMiasmaGenerated += Math.max(0, gameState.miasma - before.miasma);
                    gameState.statistics.peakFollowers = Math.max(gameState.statistics.peakFollowers, gameState.followers);
                }
            };

            const originalRecruitFollower = recruitFollower;
            recruitFollower = function () {
                const beforeCount = gameState.followers;
                originalRecruitFollower();
                if (gameState.followers > beforeCount && gameState.statistics) {
                    gameState.statistics.totalFollowersRecruited++;
                }
            };

            const originalSummonMonster = summonMonster;
            summonMonster = function (type) {
                const beforeCount = gameState.monsters[type].count;
                originalSummonMonster(type);
                if (gameState.monsters[type].count > beforeCount && gameState.statistics) {
                    gameState.statistics.totalMonstersSummoned++;
                }
            };

            const originalAttemptMadness = attemptMadness;
            attemptMadness = function (index) {
                if (!gameState.statistics) return originalAttemptMadness(index);

                const adventurer = gameState.adventurers[index];
                const wasMad = adventurer.isMad;
                gameState.statistics.totalMadnessAttempts++;

                originalAttemptMadness(index);

                if (!wasMad && adventurer.isMad) {
                    gameState.statistics.successfulMadness++;
                }
            };

            // DOMContentLoadedイベントリスナーを修正
            document.addEventListener('DOMContentLoaded', function () {
                debug("DOM fully loaded");

                try {
                    // 初期化処理の実行
                    initializeGame();

                    // ゲームループの開始
                    startGameLoop();

                    // 自動セーブの設定
                    setupAutoSave();

                    // バックアップの設定
                    setInterval(createBackup, 30 * 60 * 1000); // 30分ごと

                    debug("Initial setup complete");
                } catch (error) {
                    console.error("Error during initialization:", error);
                    handleInitializationError(error);
                }
            });

            // pauseGame関数を修正
            function pauseGame() {
                gamePaused = true;
                debug("Game paused");
                // 一時停止時の時刻を記録
                gameState.pauseStartTime = Date.now();
            }

            // resumeGame関数を修正
            function resumeGame() {
                const pauseDuration = Date.now() - (gameState.pauseStartTime || Date.now());

                // すべてのアドベンチャラーのクールダウンを調整
                gameState.adventurers.forEach(adventurer => {
                    if (adventurer.cooldownEndTime > gameState.pauseStartTime) {
                        adventurer.cooldownEndTime += pauseDuration;
                    }
                });

                gamePaused = false;
                lastFrameTime = Date.now();
                delete gameState.pauseStartTime;
                logAction("Game resumed");
            }

            // ページを離れる前のセーブ
            window.addEventListener('beforeunload', function () {
                debug("Saving game before unload");
                saveGame();
            });

            // エラー発生時のハンドリング
            window.addEventListener('error', function (event) {
                console.error("Game error:", event.error);
                handleGameError(event.error);
            });

            // エラーハンドリング関数を追加
            function handleInitializationError(error) {
                console.error("Initialization error:", error);

                // エラー通知を表示
                const notification = document.createElement('div');
                notification.className = 'error-notification';
                notification.innerHTML = `
        <h3>Initialization Error</h3>
        <p>An error occurred while loading the game: ${error.message}</p>
        <p>Please try refreshing the page. If the problem persists, you may need to reset the game.</p>
        <button onclick="resetGameAndClearSave()">Reset Game</button>
        <button onclick="this.parentElement.remove()">Close</button>
    `;
                document.body.appendChild(notification);

                // 基本的なゲーム状態の復旧を試みる
                try {
                    resetGameState();
                    rebuildUI();
                } catch (recoveryError) {
                    console.error("Recovery failed:", recoveryError);
                }
            }

            // Make sure all required functions are defined
            function updateStatistics() {
                if (!gameState.statistics) return;

                const stats = gameState.statistics;
                const now = Date.now();

                try {
                    // 基本的な時間統計
                    const timePlayed = Math.floor((now - stats.startTime) / 1000);
                    const activePlayTime = stats.activePlayTime || timePlayed; // アクティブプレイ時間
                    document.getElementById('timePlayed').textContent = formatTime(timePlayed);
                    document.getElementById('activePlayTime').textContent = formatTime(activePlayTime);

                    // リソース生産統計
                    const resourceStats = {
                        'totalSourceGenerated': stats.totalSourceGenerated,
                        'sourcePerSecond': stats.totalSourceGenerated / timePlayed,
                        'totalMiasmaGenerated': stats.totalMiasmaGenerated,
                        'miasmaPerSecond': stats.totalMiasmaGenerated / timePlayed,
                        'totalCultosGenerated': stats.totalCultosGenerated || 0,
                        'cultosPerSecond': (stats.totalCultosGenerated || 0) / timePlayed
                    };

                    // フォロワー関連統計
                    const followerStats = {
                        'totalFollowersRecruited': stats.totalFollowersRecruited,
                        'peakFollowers': stats.peakFollowers,
                        'currentFollowers': gameState.followers,
                        'currentFollowerEfficiency': gameState.followerEfficiency,
                        'averageFollowersPerSecond': stats.totalFollowersRecruited / timePlayed
                    };

                    // モンスター関連統計
                    const monsterStats = {
                        'totalMonstersSummoned': stats.totalMonstersSummoned,
                        'uniqueMonsterTypes': Object.values(gameState.monsters).filter(m => m.count > 0).length,
                        'mostCommonMonster': getMostCommonMonster(),
                        'totalMonsterCost': calculateTotalMonsterCost(),
                        'averageMonstersPerMinute': (stats.totalMonstersSummoned / timePlayed) * 60
                    };

                    // 狂気関連統計
                    const madnessStats = {
                        'totalMadnessAttempts': stats.totalMadnessAttempts,
                        'successfulMadness': stats.successfulMadness,
                        'madnessSuccessRate': calculateMadnessSuccessRate(stats),
                        'averageMadnessAttemptsPerHour': (stats.totalMadnessAttempts / timePlayed) * 3600
                    };

                    // 契約関連統計
                    const pactStats = {
                        'activePacts': gameState.pacts.active.length,
                        'totalPactsSealed': stats.totalPactsSealed || 0,
                        'currentPactMultiplier': gameState.pacts.commonMultiplier,
                        'currentTickSpeedMultiplier': gameState.pacts.tickSpeedMultiplier
                    };

                    // アップグレード関連統計
                    const upgradeStats = {
                        'totalUpgradesPurchased': gameState.upgrades.length,
                        'upgradeEfficiency': calculateUpgradeEfficiency(),
                        'totalUpgradeCost': calculateTotalUpgradeCost()
                    };

                    // 効率性指標
                    const efficiencyStats = {
                        'overallGameEfficiency': calculateOverallEfficiency(),
                        'resourceGenerationEfficiency': calculateResourceEfficiency(),
                        'followerRecruitmentEfficiency': calculateFollowerEfficiency()
                    };

                    // 統計情報の表示を更新
                    updateStatisticsDisplay({
                        resourceStats,
                        followerStats,
                        monsterStats,
                        madnessStats,
                        pactStats,
                        upgradeStats,
                        efficiencyStats
                    });

                    // 追加の統計情報の更新
                    updateAdvancedStatistics();
                    updateAchievementProgress();
                    updateHistoricalData();

                } catch (error) {
                    console.error("Error updating statistics:", error);
                    logAction(`Statistics update error: ${error.message}`);
                }
            }

            // 補助関数
            function calculateMadnessSuccessRate(stats) {
                return stats.totalMadnessAttempts > 0
                    ? (stats.successfulMadness / stats.totalMadnessAttempts * 100).toFixed(1)
                    : '0.0';
            }

            function calculateTotalMonsterCost() {
                return Object.values(gameState.monsters).reduce((total, monster) => {
                    return total + (monster.count * monster.baseFollowerCost);
                }, 0);
            }

            function calculateUpgradeEfficiency() {
                return gameState.upgrades.reduce((total, upgrade) => {
                    const upgradeData = upgradeDefinitions[upgrade];
                    return total + (upgradeData.efficiency || 1);
                }, 1);
            }

            function updateStatisticsDisplay(stats) {
                // 各統計カテゴリーの表示を更新
                Object.entries(stats).forEach(([category, categoryStats]) => {
                    Object.entries(categoryStats).forEach(([statName, value]) => {
                        const element = document.getElementById(statName);
                        if (element) {
                            element.textContent = typeof value === 'number'
                                ? formatNumber(value)
                                : value;
                        }
                    });
                });
            }

            function updateAdvancedStatistics() {
                // 高度な統計情報の更新（グラフ、チャートなど）
                updateResourceGraph();
                updateEfficiencyTrends();
                updateProgressionMetrics();
            }

            function updateAchievementProgress() {
                // 実績の進捗状況を更新
                const achievements = calculateAchievementProgress();
                displayAchievementProgress(achievements);
            }

            function updateHistoricalData() {
                // 履歴データの更新と表示
                const historicalData = getHistoricalGameData();
                displayHistoricalTrends(historicalData);
            }

            // 総アップグレードコストの計算
            function calculateTotalUpgradeCost() {
                return gameState.upgrades.reduce((total, upgradeId) => {
                    const upgrade = upgradeDefinitions[upgradeId];
                    return total + (upgrade ? upgrade.cost : 0);
                }, 0);
            }

            // 全体的な効率性の計算
            function calculateOverallEfficiency() {
                const baseEfficiency = 1;
                const followerBonus = gameState.followerEfficiency || 1;
                const upgradeBonus = calculateUpgradeEfficiency();
                const pactBonus = gameState.pacts?.commonMultiplier || 1;

                return (baseEfficiency * followerBonus * upgradeBonus * pactBonus).toFixed(2);
            }

            // リソース生成効率の計算
            function calculateResourceEfficiency() {
                const baseRate = gameState.sourcePerSecond || 0;
                const totalTime = (Date.now() - gameState.statistics.startTime) / 1000;
                const averageRate = gameState.statistics.totalSourceGenerated / totalTime;

                return (averageRate / baseRate || 1).toFixed(2);
            }

            // フォロワー募集効率の計算
            function calculateFollowerEfficiency() {
                const currentFollowers = gameState.followers;
                const totalRecruits = gameState.statistics.totalFollowersRecruited;
                const totalTime = (Date.now() - gameState.statistics.startTime) / 1000;

                return ((currentFollowers / totalRecruits) * (totalRecruits / totalTime)).toFixed(2);
            }

            function calculateFollowerProduction(adventurer) {
    // 基本生産量
    let production = adventurer.followerProduction;

    // 基本効率を適用（1未満の値の場合は加算に変更）
    const baseEfficiency = (gameState.followerEfficiency || 0.1);
    production *= (baseEfficiency >= 1 ? baseEfficiency : 1 + baseEfficiency);

    // レベルボーナスとその他のボーナスを計算
    let totalBonus = 0;
    
    // レベルボーナス（10%ずつ加算）
    totalBonus += (adventurer.level - 1) * 0.1;

    // 契約効果を加算
    if (gameState.pacts?.commonMultiplier) {
        // 契約乗数が1未満の場合は、ボーナスとして適切に変換
        const pactBonus = gameState.pacts.commonMultiplier - 1;
        totalBonus += Math.max(pactBonus, 0); // 負の値を防ぐ
    }

    // その他のボーナスを加算
    if (gameState.followerProductionBonus) {
        // 1未満の値の場合は適切にボーナスとして変換
        const productionBonus = gameState.followerProductionBonus;
        totalBonus += (productionBonus >= 1 ? productionBonus - 1 : productionBonus);
    }

    // 全てのボーナスを適用（ボーナスは必ず加算として扱う）
    production *= (1 + Math.max(totalBonus, 0));

    return production;
}

            // リソースグラフの更新
            function updateResourceGraph() {
                // グラフ機能が実装されている場合はここで更新
                // 現時点では空の実装
            }

            // 効率性トレンドの更新
            function updateEfficiencyTrends() {
                // 効率性トレンドの追跡が実装されている場合はここで更新
                // 現時点では空の実装
            }

            // 進行度メトリクスの更新
            function updateProgressionMetrics() {
                // 進行度の追跡が実装されている場合はここで更新
                // 現時点では空の実装
            }

            // 実績の進捗状況の計算
            function calculateAchievementProgress() {
                // 実績システムが実装されている場合はここで計算
                return {};
            }

            // 実績の進捗状況の表示
            function displayAchievementProgress(achievements) {
                // 実績の表示が実装されている場合はここで表示
                // 現時点では空の実装
            }

            // 履歴データの取得
            function getHistoricalGameData() {
                // 履歴データの追跡が実装されている場合はここでデータを取得
                return {};
            }

            // 履歴トレンドの表示
            function displayHistoricalTrends(historicalData) {
                // 履歴データの表示が実装されている場合はここで表示
                // 現時点では空の実装
            }

            // 最も一般的なモンスターの取得
            function getMostCommonMonster() {
                if (!gameState.monsters || Object.keys(gameState.monsters).length === 0) {
                    return 'None';
                }

                const monsterCounts = Object.entries(gameState.monsters)
                    .map(([id, monster]) => ({
                        id,
                        count: monster.count,
                        name: monster.name || id
                    }))
                    .filter(m => m.count > 0)
                    .sort((a, b) => b.count - a.count);

                return monsterCounts.length > 0 ? monsterCounts[0].name : 'None';
            }

            function getMostCommonMonster() {
                let maxCount = 0;
                let mostCommon = 'None';

                for (const [monster, data] of Object.entries(gameState.monsters)) {
                    if (data.count > maxCount) {
                        maxCount = data.count;
                        mostCommon = monster;
                    }
                }

                return maxCount > 0 ? `${mostCommon} (${formatNumber(maxCount)})` : 'None';
            }

            // ゲームロード時のPACT状態復元を改善
            const originalLoadGame = loadGame;
            loadGame = function () {
                const result = originalLoadGame();

                if (result) {
                    // PACTの状態を確認して初期化
                    if (!gameState.pacts) {
                        gameState.pacts = {
                            active: [],
                            currentFollowerArt: null,
                            commonMultiplier: 1,
                            tickSpeedMultiplier: 1,
                            showingPactModal: false
                        };
                    }

                    // アクティブなPACTに基づいてフォロワーの外観を更新
                    if (gameState.pacts.active.length > 0) {
                        const lastPactId = gameState.pacts.active[gameState.pacts.active.length - 1];
                        const lastPact = PACTS[lastPactId];
                        if (lastPact) {
                            gameState.pacts.currentFollowerArt = lastPact.followerAsciiArt;
                            gameState.pacts.currentTooltipText = lastPact.tooltipText;
                        }
                    }

                    // UI更新
                    updateFollowerAppearance();
                    updateAllDisplays();
                }
                initializeNotificationSystem(); // 通知システムを再確認
                return result;
            };

            // セーブ機能の改善
            const originalSaveGame = saveGame;
            saveGame = function () {
                // PACTの状態を確実に保存
                if (gameState.pacts?.active?.length > 0) {
                    const lastPactId = gameState.pacts.active[gameState.pacts.active.length - 1];
                    const lastPact = PACTS[lastPactId];
                    if (lastPact) {
                        gameState.pacts.currentFollowerArt = lastPact.followerAsciiArt;
                        gameState.pacts.currentTooltipText = lastPact.tooltipText;
                    }
                }

                originalSaveGame();
                initializeNotificationSystem(); // 通知システムを再確認
            };

            // フォロワーセクションの更新も改善
            const originalUpdateFollowerSection = updateFollowerSection;
            updateFollowerSection = function () {
                originalUpdateFollowerSection();
                updateFollowerAppearance();
            };

            // グローバル変数として初期化フラグを設定
            let isInitialized = false;

            document.addEventListener('DOMContentLoaded', function () {
                // 重複初期化を防ぐ
                if (isInitialized) return;
                isInitialized = true;

                // 初期化処理
                initializeGame();
                // その他の初期化処理...
            });

        </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/dist/tippy.css">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cultist's Complex.idle</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Creepster&family=Press+Start+2P&family=Orbitron:wght@400;700&family=Audiowide&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=UnifrakturMaguntia&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Indie+Flower&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        /* ã‚«ãƒ©ãƒ¼è¨­å®š */
        :root {
            --bg-color: #0a0a0a;
            --text-color: #e0e0e0;
            --panel-bg: #1a1a1a;
            --highlight-color: #c31515;
            --button-color: #4CAF50;
            --button-hover: #45a049;
            --button-disabled: #9a1e1e;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Webkit ãƒ–ãƒ©ã‚¦ã‚¶ (Chrome, Safari, newer versions of Edge) ç”¨ */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 6px;
            border: 3px solid #1a1a1a;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }

        /* Firefox ç”¨ (version 64 ä»¥é™) */
        * {
            scrollbar-width: thin;
            scrollbar-color: #4CAF50 #1a1a1a;
        }

        body {
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
            user-select: none;
            position: relative;
            /* ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³ç”¨ */
        }

        /* CRTã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤åŠ¹æœ */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                /* ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³ */
                repeating-linear-gradient(0deg,
                    rgba(124, 116, 116, 0.15),
                    rgba(19, 18, 18, 0.1) 1px,
                    transparent 1.5px,
                    transparent 4px),
                /* ç·‘ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ */
                linear-gradient(rgba(33, 222, 109, 0.05),
                    rgba(33, 222, 109, 0.05));
            pointer-events: none;
            z-index: 999999;
            mix-blend-mode: screen;
        }

        /* CRTæ›²é¢åŠ¹æœ */
        body::after {
            content: "";
            position: fixed;
            top: 0.5%;
            left: 0.5%;
            right: 0.5%;
            bottom: 0.5%;
            background: radial-gradient(circle at center,
                    transparent 50%,
                    rgba(0, 0, 0, 0.2) 100%);
            pointer-events: none;
            z-index: 999998;
        }

        /* ASCII ã‚¢ãƒ¼ãƒˆç”¨ã®ç‰¹åˆ¥ãªã‚¹ã‚¿ã‚¤ãƒ« */
        #ascii-title,
        .ascii-cultosminer,
        .ascii-art,
        .follower-ascii-art,
        .monster-ascii-art {
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 2px currentColor;
            position: relative;
            animation: textFlicker 0.3s infinite;
        }

        @keyframes textFlicker {
            0% {
                opacity: 0.97;
            }

            5% {
                opacity: 0.95;
            }

            10% {
                opacity: 0.9;
            }

            15% {
                opacity: 0.95;
            }

            20% {
                opacity: 0.98;
            }

            25% {
                opacity: 0.95;
            }

            30% {
                opacity: 0.9;
            }

            35% {
                opacity: 0.95;
            }

            40% {
                opacity: 0.98;
            }

            45% {
                opacity: 0.95;
            }

            50% {
                opacity: 0.9;
            }

            55% {
                opacity: 0.95;
            }

            60% {
                opacity: 0.98;
            }

            65% {
                opacity: 0.95;
            }

            70% {
                opacity: 0.9;
            }

            75% {
                opacity: 0.95;
            }

            80% {
                opacity: 0.98;
            }

            85% {
                opacity: 0.95;
            }

            90% {
                opacity: 0.9;
            }

            95% {
                opacity: 0.95;
            }

            100% {
                opacity: 0.98;
            }
        }

        /* ã‚¨ãƒ³ãƒ–ãƒ¬ãƒ å°‚ç”¨ã®CRTåŠ¹æœå¼·åŒ– */
        #cultosminer {
            position: relative;
            overflow: hidden;
        }

        #eldritchDrum {
            font-size: 12px;
            margin: 0;
            font-family: 'Courier New', monospace;
            white-space: pre;
            line-height: 1.1;
        }

        #cultosminer {
            font-family: 'Courier New', monospace;
            line-height: 1.1;
            white-space: pre;
            text-align: center;
            font-size: 9px;
            font-weight: bold;
            margin: 0;
            padding: 10px;
        }

        /* ãƒ‘ãƒãƒ«ã¨ã‚«ãƒ¼ãƒ‰ã®CRTåŠ¹æœå¼·åŒ– */
        .panel,
        .monster-card,
        .upgrade-card,
        .adventurer {
            position: relative;
            overflow: hidden;
            background-color: var(--panel-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1),
                inset 0 0 20px rgba(33, 222, 109, 0.05);
        }

        /* CRTãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ç„¡åŠ¹æ™‚ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .crt-filter-disabled::before,
        .crt-filter-disabled::after {
            display: none !important;
        }

        .crt-filter-disabled #cultosminer::before,
        .crt-filter-disabled .pact-modal .pact-content::before {
            display: none !important;
        }

        .crt-filter-disabled #ascii-title,
        .crt-filter-disabled .ascii-art,
        .crt-filter-disabled .follower-ascii-art,
        .crt-filter-disabled .monster-ascii-art {
            animation: none !important;
            text-shadow: none !important;
        }

        .crt-filter-disabled .panel,
        .crt-filter-disabled .monster-card,
        .crt-filter-disabled .upgrade-card,
        .crt-filter-disabled .adventurer {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
        }

        /* ãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #toggleCrtFilter {
            transition: all 0.3s ease;
            margin: 0 5px;
        }

        #toggleCrtFilter:hover {
            background-color: rgba(76, 175, 80, 0.2);
        }

        #toggleCrtFilter:active {
            background-color: rgba(76, 175, 80, 0.4);
        }

        /* ãƒ•ãƒ©ãƒƒã‚·ãƒ¥åŠ¹æœã®å¼·åŒ– */
        .white-flash {
            animation: enhanced-flash 0.5s;
        }

        @keyframes enhanced-flash {
            0% {
                filter: brightness(100%) sepia(0.2);
            }

            50% {
                filter: brightness(200%) sepia(0.3);
            }

            100% {
                filter: brightness(100%) sepia(0.2);
            }
        }

        /* å¥‘ç´„ãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ã®ç‰¹åˆ¥ãªCRTåŠ¹æœ */
        .pact-modal .pact-content {
            position: relative;
            overflow: hidden;
        }

        .pact-modal .pact-content::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(0deg,
                    rgba(124, 116, 116, 0.1),
                    rgba(19, 18, 18, 0.05) 1px,
                    transparent 2px,
                    transparent 4px);
            pointer-events: none;
            animation: scanline 10s linear infinite;
        }

        button {
            background-color: transparent;
            color: #e0e0e0;
            border: 1px solid #4CAF50;
            /* ç·šæ ã®è‰² */
            padding: 4px 8px;
            margin: 5px 0;
            cursor: pointer;
            border-radius: 3px;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 11px;
        }

        button:hover:not(:disabled) {
            background-color: rgba(76, 175, 80, 0.2);
            /* ãƒ›ãƒãƒ¼æ™‚ã®èƒŒæ™¯è‰² */
            color: #ffffff;
        }

        button:active:not(:disabled) {
            background-color: rgba(76, 175, 80, 0.4);
            /* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ã®èƒŒæ™¯è‰² */
        }

        button:disabled {
            background-color: transparent;
            /* ç„¡åŠ¹æ™‚ã‚‚é€æ˜ã« */
            border-color: #9a1e1e;
            /* ç„¡åŠ¹æ™‚ã®ç·šæ ã®è‰² */
            cursor: not-allowed;
            opacity: 0.7;
        }

        button:disabled:hover {
            background-color: transparent;
        }

        @keyframes white-flash {
            0% {
                filter: brightness(100%);
            }

            50% {
                filter: brightness(200%);
            }

            100% {
                filter: brightness(100%);
            }
        }

        .white-flash {
            animation: white-flash 0.5s;
        }

        .red-filter {
            filter: sepia(100%) saturate(300%) brightness(70%) hue-rotate(300deg);
        }

        .floating-buttons-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        .floating-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: block;
            font-size: 16px;
            margin: 4px 2px;
            margin-bottom: 10px;
            cursor: pointer;
            border-radius: 12px;
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
            transition: 0.3s;
        }

        .floating-button:hover {
            background-color: #45a049;
            box-shadow: 0 8px 16px 0 rgba(0, 0, 0, 0.2);
        }

        #backToTopBtn {
            display: none;
            /* åˆæœŸçŠ¶æ…‹ã§ã¯éè¡¨ç¤º */
        }

        #backToTopBtn:hover {
            background-color: #45a049;
        }

        /* ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒ†ãƒŠã®ä¸‹éƒ¨ã«ãƒãƒ¼ã‚¸ãƒ³ã‚’è¿½åŠ  */
        .floating-buttons-container {
            margin-bottom: 70px;
            /* Back to Topãƒœã‚¿ãƒ³ã®é«˜ã• + ä½™ç™½ */
        }


        #ascii-title-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0 0 0;
            /* ä¸‹éƒ¨ã®ãƒãƒ¼ã‚¸ãƒ³ã‚’å‰Šé™¤ */
            padding: 10px;
            background-color: var(--bg-color);
            border-radius: 10px 10px 0 0;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #text-title {
            display: none;
            font-size: 2.5em;
            text-align: center;
            color: #4CAF50;
            margin: 20px 0;
        }

        /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ã‚¯ãƒ©ã‚¹ */
        .fade-out {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .fade-in {
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        #ascii-title {
            font-family: 'Courier New', monospace;
            line-height: 1.1;
            white-space: pre;
            text-align: center;
            color: #1aff1a;
            text-shadow: 0 0 5px #1aff1a, 0 0 10px #1aff1a;
            margin-top: -15px;
            margin-bottom: 15px;
            font-size: 10px;
            font-weight: bold;
            margin: 0;
            padding: 0;
        }

        #version-display {
            font-family: 'Courier New', monospace;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            color: #1aff1a;
            background-color: var(--bg-color);
            padding: 5px;
            border-radius: 0 0 10px 10px;
        }

        @media (max-width: 768px) {
            #ascii-title {
                font-size: 8px;
            }

            #version-display {
                font-size: 12px;
            }
        }

        @media (max-width: 1200px) {
            #resourceDisplay {
                padding: 8px 10px;
                gap: 10px;
            }

            .resource-column {
                min-width: 150px;
            }
        }

        @media (max-width: 768px) {
            #resourceDisplay {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(3, auto);
            }

            .ascii-container {
                order: -1;
                margin-bottom: 10px;
            }

            .resource-column:first-child,
            .resource-column:last-child {
                justify-self: center;
                text-align: center;
            }

            .resource-value-container {
                justify-content: center;
            }

            .cultos-section {
                flex-direction: column;
                gap: 10px;
            }
        }


        .container {
            display: grid;
            grid-template-columns: 250px 1fr 300px;
            grid-template-rows: auto auto auto 1fr;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .panel {
            background-color: var(--panel-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        #debugControls button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 2px 2px;
            cursor: pointer;
            border-radius: 3px;
        }

        #debugControls span {
            font-size: 14px;
            margin-left: 10px;
        }

        h1 {
            grid-column: 1 / -1;
            grid-row: 1;
            text-align: center;
            color: #1aff1a;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(16, 209, 42, 0.5);
        }

        #resourceDisplay {
            position: sticky;
            top: 40px;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
            height: auto;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 255, 0, 0.2);
        }

        #cultosminer {
            grid-column: 2;
            grid-row: 1 / span 2;
        }

        /* å·¦å´ã®ãƒªã‚½ãƒ¼ã‚¹ï¼ˆSourceï¼‰ */
        .resource-column:first-child {
            justify-self: end;
            text-align: right;
        }

        /* å³å´ã®ãƒªã‚½ãƒ¼ã‚¹ï¼ˆMiasmaï¼‰ */
        .resource-column:last-child {
            justify-self: start;
            text-align: left;
        }

        #largeCultosCount {
            color: #42a5f5;
            text-shadow: 0 0 5px #42a5f5, 0 0 10px #42a5f5;
            font-family: 'Audiowide', cursive;
            font-size: 1.2em;
            margin: 0;
        }

        .cultos-section {
            grid-column: 1 / -1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px solid rgba(26, 255, 26, 0.2);
        }

        .cultos-value-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }


        .cultos-hidden {
            display: none !important;
        }

        .cultos-symbol {
            font-size: 1.2em;
            font-family: 'Press Start 2P', cursive;
        }

        .cultos-symbol.active {
            animation: rainbow-text 5s linear infinite;
        }

        @keyframes rainbow-text {
            0% {
                color: #ff0000;
            }

            17% {
                color: #ffa500;
            }

            33% {
                color: #ffff00;
            }

            50% {
                color: #008000;
            }

            67% {
                color: #0000ff;
            }

            83% {
                color: #4b0082;
            }

            100% {
                color: #ff0000;
            }
        }

        /* éã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .cultos-symbol.inactive {
            animation: none;
            background: none;
            text-shadow: none;
            color: #272626;
        }

        .resource-rates {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            /* å³æƒãˆ */
        }

        #cultosRate {
            min-width: 120px;
            /* Cultosãƒ¬ãƒ¼ãƒˆã®æœ€å°å¹…ã‚’è¨­å®š */
            text-align: right;
        }

        #cultosHashRate {
            font-size: 0.9em;
            display: inline-block;
            min-width: 50px;
            text-align: right !important;
            font-family: 'Audiowide', cursive;
        }

        .rate-display {
            font-family: 'Audiowide', cursive;
            font-size: 0.9em;
            color: rgba(26, 255, 26, 0.8);
            white-space: nowrap;
            display: inline-block;
            width: 100px;
            /* å›ºå®šå¹…ã‚’è¨­å®š */
            text-align: right !important;
        }

        /* ã‚«ãƒ«ãƒˆã‚¹ã‚«ã‚¦ãƒ³ãƒˆã®ã‚³ãƒ³ãƒ†ãƒŠ */
        .cultos-value-container {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: flex-end;
        }

        .consumption-rate-container {
            display: flex;
            gap: 15px;
            font-size: 0.8em;
        }

        .consumption-rate {
            display: flex;
            align-items: center;
            white-space: nowrap;
        }

        .consumption-rate span {
            margin-left: 4px;
            min-width: 80px;
            /* æ•°å€¤ã®æœ€å°å¹…ã‚’å¤§ãã‚ã«è¨­å®š */
            text-align: right;
            display: inline-block;
            /* ãƒ–ãƒ­ãƒƒã‚¯è¦ç´ ã¨ã—ã¦è¡¨ç¤º */
        }

        .consumption-rate .rate-value {
            margin-left: 4px;
            min-width: 80px;
            /* æ•°å€¤ã®æœ€å°å¹…ã‚’å¤§ãã‚ã«è¨­å®š */
            text-align: right;
            display: inline-block;
            /* ãƒ–ãƒ­ãƒƒã‚¯è¦ç´ ã¨ã—ã¦è¡¨ç¤º */
        }

        .consumption-rate .rate-value.active {
            color: #4CAF50;
            /* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ã¯ç·‘è‰² */
        }

        .consumption-rate .rate-value.inactive {
            color: #ff4444;
            /* éã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ã¯èµ¤è‰² */
        }

        #upgradeSymbols {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            align-items: center;
        }

        #upgradeSymbols {
            overflow: visible !important;
            position: relative;
        }

        .upgrade-symbol {
            overflow: visible !important;
        }

        .upgrade-symbol {
            cursor: pointer;
            margin: 0 5px;
            position: relative;
            display: inline-block;
        }

        .upgrade-tooltip {
            visibility: hidden;
            position: absolute;
            background-color: rgba(0, 0, 0, 0.95);
            color: #e0e0e0;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #4CAF50;
            font-size: 12px;
            white-space: nowrap;
            z-index: 5000;
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 5px;
            width: max-content;
            max-width: 300px;
        }

        .upgrade-symbol:hover .upgrade-tooltip {
            visibility: visible;
        }

        /* ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®ãƒ™ãƒ¼ã‚¹ã‚¹ã‚¿ã‚¤ãƒ« */
        .tooltip-container {
            position: relative;
        }

        /* ãƒªã‚½ãƒ¼ã‚¹å€¤è‡ªä½“ã®å›ºå®šå¹…è¨­å®š */
        .resource-value {
            min-width: 120px;
            /* ãƒªã‚½ãƒ¼ã‚¹å€¤ã®æœ€å°å¹…ã‚’è¨­å®š */
            text-align: right;
            display: inline-block;
        }

        .resource-rate {
            font-family: 'Courier New', monospace;
            font-size: 1em;
            width: 120px;
            display: inline-block;
            text-align: right;
            color: #1aff1a;
        }

        .resource-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            text-align: center;
        }


        .resource-column h2 {
            /*font-size: 1.2em;  /* Press Start 2P ã®å ´åˆ */
            font-size: 1.2em;
            /* Orbitron ã¾ãŸã¯ Audiowide ã®å ´åˆ */
            margin-bottom: 5px;
            color: #1aff1a;
            text-shadow: 0 0 5px #1aff1a, 0 0 10px #1aff1a;
        }

        .resource-column:last-child h2 {
            color: #42a5f5;
            /* ã‚«ãƒ«ãƒˆã‚¹ç”¨ã®é’è‰² */
            text-shadow: 0 0 5px #42a5f5, 0 0 10px #42a5f5;
            /* é’ã„ç™ºå…‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
        }

        #largeSourceCount,
        #largeMiasmaCount {
            font-family: 'Audiowide', cursive;
            font-size: 1.2em;
            color: #1aff1a;
            text-shadow: 0 0 5px #1aff1a;
            margin: 0;
        }

        #largeSourcePerSecond,
        #largeMiasmaPerSecond {
            font-family: 'Audiowide', monospace;
            font-size: 1em;
            color: #1aff1a;
            min-width: 60px;
            /* å›ºå®šå¹…ã‚’è¨­å®š */
            text-align: right;
            /* å³å¯„ã› */
            display: inline-block;
            /* ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ–ãƒ­ãƒƒã‚¯è¦ç´ ã« */
        }

        .resource-value-container {
            display: flex;
            align-items: baseline;
            gap: 10px;
            justify-content: flex-end;
        }


        .resource-column:last-child .resource-value-container {
            justify-content: flex-start;
        }

        .ascii-cultosminer {
            font-family: 'Courier New', monospace;
            font-size: 8px;
            line-height: 1.1;
            white-space: pre;
            text-align: center;
            margin: 0 20px;
            padding: 10px;
        }

        .ascii-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
        }

        .cultosminer-flash {
            animation: cultosminer-flash 1s ease-out;
        }

        /* ç„¡åŠ¹çŠ¶æ…‹ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .cultosminer-disabled {
            filter: grayscale(100%) opacity(0.5) !important;
            pointer-events: none !important;
        }

        /* ã‚«ãƒ«ãƒˆã‚¹ã‚·ãƒ³ãƒœãƒ«ã®ç„¡åŠ¹åŒ–çŠ¶æ…‹ã®å¼·åŒ– */
        .cultosminer-disabled .cultos-symbol,
        .cultosminer-disabled .cultos-symbol.active {
            animation: none !important;
            color: #666666 !important;
            text-shadow: none !important;
            -webkit-text-fill-color: #666666 !important;
            background: none !important;
            opacity: 0.5 !important;
        }

        /* cultosminerãŒç„¡åŠ¹æ™‚ã®ã‚·ãƒ³ãƒœãƒ«ã‚¹ã‚¿ã‚¤ãƒ« */
        .cultos-symbol.inactive {
            animation: none !important;
            color: #666666 !important;
            text-shadow: none !important;
            -webkit-text-fill-color: #666666 !important;
            background: none !important;
            opacity: 0.5 !important;
        }

        /* ã‚«ãƒ«ãƒˆã‚¹ã‚·ãƒ³ãƒœãƒ«ã®ç„¡åŠ¹åŒ–çŠ¶æ…‹ã®å¼·åŒ– */
        .cultosminer-disabled .cultos-symbol,
        .cultosminer-disabled .cultos-symbol.active {
            animation: none !important;
            color: #666666 !important;
            text-shadow: none !important;
            -webkit-text-fill-color: #666666 !important;
            background: none !important;
            opacity: 0.5 !important;
        }



        @keyframes pulse {
            0% {
                box-shadow: 0 0 5px var(--glow-color);
            }

            50% {
                box-shadow: 0 0 15px var(--glow-color);
            }

            100% {
                box-shadow: 0 0 5px var(--glow-color);
            }
        }

        /* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .active {
            filter: none !important;
            pointer-events: auto !important;
        }

        /* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã§ã®è‰²ã®ç¶­æŒ */
        .active .cultosminer-color1 {
            color: #1aff1a !important;
            text-shadow: 0 0 5px #1aff1a !important;
        }

        .active .cultosminer-color2 {
            color: #118011 !important;
        }

        .active .cultosminer-color3 {
            color: #ff1a1a !important;
            text-shadow: 0 0 5px #ff1a1a !important;
        }

        .active .cultosminer-color4 {
            color: #ffff1a !important;
            text-shadow: 0 0 5px #ffff1a !important;
        }

        /* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã®å®šç¾© */
        #cultosminer:not(.cultosminer-disabled) {
            filter: none;
            pointer-events: auto;
        }

        /* ã‚«ãƒ«ãƒˆã‚¹ã‚·ãƒ³ãƒœãƒ«ã®ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼åŠ¹æœã®ç„¡åŠ¹åŒ– */
        .cultosminer-disabled .cultos-symbol {
            animation: none !important;
            background: none !important;
            color: #666666 !important;
            -webkit-text-fill-color: #666666 !important;
        }

        @keyframes cultosminer-flash {
            0% {
                color: #FFFFFF;
                text-shadow: 0 0 10px #FFFFFF;
            }

            100% {
                color: inherit;
                text-shadow: none;
            }
        }

        /* ãƒã‚¤ãƒ‹ãƒ³ã‚°çŠ¶æ…‹è¡¨ç¤ºã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .mining-status {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            margin: 5px 0;
        }

        .mining-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #666;
            transition: all 0.3s ease;
        }

        .mining-indicator.active {
            background-color: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .cultosminer-color1 {
            color: #1aff1a;
            text-shadow: 0 0 5px #1aff1a;
        }

        .cultosminer-color2 {
            color: #118011;
        }

        .cultosminer-color3 {
            color: #ff1a1a;
            text-shadow: 0 0 5px #ff1a1a;
        }

        .cultosminer-color4 {
            color: #ffff1a;
            text-shadow: 0 0 5px #ffff1a;
        }

        .sidebar {
            grid-column: 1 / 2;
            grid-row: 3 / 5;
        }

        .main-content {
            grid-column: 2 / 3;
            grid-row: 3 / 4;
        }

        .upgrades {
            grid-column: 3 / 4;
            grid-row: 3 / 5;
        }

        .madness-table {
            grid-column: 2 / 3;
            grid-row: 4 / 5;
        }

        .stat-line {
            margin: 5px 0;
            text-align: left;
        }

        #monsterGridContainer {
            scroll-behavior: smooth;
            scroll-snap-type: y mandatory;
            overflow-y: auto;
            height: 730px;
            /* ãƒ‡ãƒãƒƒã‚°ç”¨ã®èƒŒæ™¯è‰²ã‚’è¿½åŠ  */
            background: rgba(0, 0, 0, 0.1);
        }

        /* Webkitï¼ˆChrome, Safariç­‰ï¼‰ç”¨ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚¹ã‚¿ã‚¤ãƒ« */
        #monsterGridContainer::-webkit-scrollbar {
            width: 8px;
        }

        #monsterGridContainer::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }

        #monsterGridContainer::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 4px;
        }

        #monsterGridContainer::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }

        .monster-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            /* ã‚³ãƒ³ãƒ†ãƒŠå†…ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‹•ä½œã‚’æ”¹å–„ */
            min-height: min-content;
            padding-bottom: 20px;
            /* ä¸‹éƒ¨ã«ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿½åŠ  */
        }

        .monster-card {
            position: relative;
            background-color: #192320;
            padding: 15px;
            border-radius: 8px;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .monster-card-header {
            position: relative;
        }

        #toggleAllMonsterCards {
            margin-bottom: 10px;
            /* å¿…è¦ã«å¿œã˜ã¦ä»–ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ  */
        }

        .monster-card-details {
            display: none;
            margin-top: 10px;
        }

        .monster-card-details.expanded {
            display: block;
        }

        .summon-monster-btn {
            transition: background-color 0.3s, opacity 0.3s;
        }

        .toggle-details {
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            font-size: 1.5em;
        }

        #adventurers {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
        }

        .adventurer {
            flex: 0 1 calc(33.333% - 20px);
            margin: 10px;
            text-align: center;
        }

        .madness-btn {
            cursor: pointer;
            transition: background-color 0.3s, opacity 0.3s;
            min-width: 120px;
            /* æœ€å°å¹…ã‚’è¨­å®š */
            height: 36px;
            /* é«˜ã•ã‚’å›ºå®š */
            line-height: 36px;
            /* ãƒ†ã‚­ã‚¹ãƒˆã‚’å‚ç›´ä¸­å¤®æƒãˆ */
            padding: 0 10px;
            /* å·¦å³ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿½åŠ  */
            white-space: nowrap;
            /* ãƒ†ã‚­ã‚¹ãƒˆã‚’1è¡Œã« */
            overflow: hidden;
            /* ã¯ã¿å‡ºã—ãŸéƒ¨åˆ†ã‚’éš ã™ */
            text-overflow: ellipsis;
            /* ã¯ã¿å‡ºã—ãŸéƒ¨åˆ†ã‚’...ã§è¡¨ç¤º */
        }

        .madness-btn:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        #log {
            height: 150px;
            overflow-y: auto;
            background-color: #222;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            margin-top: 20px;
        }

        #log p {
            margin: 5px 0;
            padding: 5px;
            background-color: #2a2a2a;
            border-radius: 3px;
        }

        .ascii-art {
            font-family: 'Courier New', monospace;
            line-height: 1.1;
            white-space: pre;
            text-align: center;
            font-size: 10px;
            font-weight: bold;
            margin: 0;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto auto auto 1fr;
            }

            .sidebar,
            .upgrades {
                grid-column: auto;
                grid-row: auto;
            }

            .main-content,
            .madness-table {
                grid-column: 1 / -1;
            }
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto auto auto auto;
            }

            .sidebar,
            .main-content,
            .upgrades,
            .madness-table {
                grid-column: 1 / -1;
                grid-row: auto;
            }
        }

        .tooltip-container .tooltip {
            visibility: hidden;
            width: 200px;
            background-color: rgba(0, 0, 0, 0.95);
            color: #fff;
            text-align: center;
            border-radius: 5px;
            padding: 8px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease;
            border: 1px solid #4CAF50;
            font-size: 12px;
            white-space: pre-wrap;
            pointer-events: none;
        }

        /* ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®çŸ¢å° */
        .tooltip-container .tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #4CAF50 transparent transparent transparent;
        }

        /* ãƒ›ãƒãƒ¼æ™‚ã®ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—è¡¨ç¤º */
        .tooltip-container:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        /* ã‚·ãƒ³ãƒœãƒ«ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .upgrade-symbol span {
            font-size: 16px;
            padding: 2px 5px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        #game-header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background-color: var(--bg-color);
            padding: 5px 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            /* ãƒ˜ãƒƒãƒ€ãƒ¼å†…ã®è¦ç´ ãŒç¢ºå®Ÿã«è¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã« */
            display: flex;
            flex-direction: column;
        }

        #top-buttons {
            position: sticky;
            /* stickyã«å¤‰æ›´ */
            top: 0;
            z-index: 1001;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            padding: 5px;
            flex-wrap: wrap;
            background-color: var(--bg-color);
            height: 40px;
        }

        #top-buttons button {
            font-size: 11px;
            padding: 4px 8px;
            background-color: transparent;
            color: #e0e0e0;
            border: 1px solid #4CAF50;
            border-radius: 3px;
            transition: all 0.3s ease;
            cursor: pointer;
            margin: 2px 0;
            /* ã™ã¹ã¦ã®ãƒœã‚¿ãƒ³ã«ä¸Šä¸‹ã®ãƒãƒ¼ã‚¸ãƒ³ã‚’è¿½åŠ  */
        }

        #top-buttons button:hover {
            background-color: rgba(76, 175, 80, 0.2);
            color: #ffffff;
        }

        #top-buttons button:active {
            background-color: rgba(76, 175, 80, 0.4);
        }

        #top-buttons button#resetButton {
            border-color: #ff0000;
            color: #ff0000;
        }

        #top-buttons button#resetButton:hover {
            background-color: rgba(255, 0, 0, 0.2);
            color: #ffffff;
        }

        #top-buttons button#resetButton:active {
            background-color: rgba(255, 0, 0, 0.4);
        }

        /* æŠ˜ã‚ŠãŸãŸã¿ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä»–ã®ãƒœã‚¿ãƒ³ã¨æƒãˆã‚‹ */
        #toggleAllMonsterCards {
            margin: 2px 0;
        }

        .rate-display {
            font-size: 0.9em;
            color: rgba(26, 255, 26, 0.8);
            white-space: nowrap;
        }

        #resourceDisplay.simple {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 5px 20px;
            gap: 10px;
            height: auto;
        }

        #resourceDisplay.simple .resource-column {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
            width: auto;
        }

        #resourceDisplay.simple .resource-value-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #resourceDisplay.simple .cultos-symbol {
            font-size: 1em;
            margin-right: 10px;
            background: none;
            /* ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç„¡åŠ¹åŒ– */
            -webkit-background-clip: initial;
            background-clip: initial;
            color: #42a5f5;
            animation: none;
            /* ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç„¡åŠ¹åŒ– */
        }

        #resourceDisplay.simple .cultos-symbol.active {
            animation: rainbow-text 5s linear infinite;
        }

        #resourceDisplay.simple .cultos-symbol.inactive {
            animation: none;
            color: #353434;
        }

        #resourceDisplay.simple .cultos-count {
            font-size: 1em;
            margin-left: 10px;
            color: #42a5f5;
            text-shadow: none;
            /* ç™ºå…‰åŠ¹æœã‚’ç„¡åŠ¹åŒ– */
        }

        #resourceDisplay.simple .rate-display {
            font-size: 0.8em;
            min-width: auto;
            margin-left: 5px;
        }

        /* ã‚·ãƒ³ãƒ—ãƒ«è¡¨ç¤ºæ™‚ã«éè¡¨ç¤ºã«ã™ã‚‹è¦ç´  */
        #resourceDisplay.simple .resource-column h2,
        #resourceDisplay.simple #cultosminer,
        #resourceDisplay.simple #upgradeSymbols {
            display: none;
        }


        #resourceDisplay.simple {
            padding: 5px 20px;
            gap: 10px;
        }

        #resourceDisplay.simple .resource-column {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            /* è¦ç´ é–“ã®é–“éš”ã‚’è¿½åŠ  */
        }

        #resourceDisplay.simple #largeSourceCount,
        #resourceDisplay.simple #largeMiasmaCount,
        #resourceDisplay.simple #largeCultosCount {
            font-size: 1em;
            /* ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å°ã•ã */
            margin: 0;
            display: block !important;
            text-shadow: none;
            /* ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤ */
        }

        /* ã‚·ãƒ³ãƒ—ãƒ«è¡¨ç¤ºæ™‚ã®ãƒ©ãƒ™ãƒ«ã‚¹ã‚¿ã‚¤ãƒ« */
        #resourceDisplay.simple .resource-column::before {
            content: attr(data-label);
            /* data-labelå±æ€§ã‹ã‚‰è¡¨ç¤ºã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾— */
            font-size: 0.8em;
            color: #888;
            margin-right: 5px;
        }

        /* ã‚·ãƒ³ãƒ—ãƒ«ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ãƒ˜ãƒƒãƒ€ãƒ¼ */
        #resourceDisplay.simple .resource-column h2 {
            font-size: 0.9em;
            margin: 0;
            display: block;
            /* æ˜ç¤ºçš„ã«è¡¨ç¤ºã‚’æŒ‡å®š */
        }

        .modal {
            position: fixed !important;
            /* ä»–ã®positionã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä¸Šæ›¸ã */
            top: 0 !important;
            left: 0 !important;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 9999999 !important;
            /* ã‚ˆã‚Šé«˜ã„å€¤ã«è¨­å®š */
            display: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
            display: block;
        }

        .modal-content {
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            background-color: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            color: #e0e0e0;
            border: 1px solid #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
            z-index: 10000 !important;
            /* overlayã‚ˆã‚Šæ›´ã«ä¸Šã« */
        }

        .modal.active .modal-content {
            transform: translate(-50%, -50%) scale(1);
        }

        /* ScrollBar Styling */
        .modal-content::-webkit-scrollbar {
            width: 10px;
        }

        .modal-content::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 5px;
        }

        .modal-content::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 5px;
        }

        .modal-content::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }

        /* ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’å›ºå®š */
        .modal-header {
            position: sticky;
            top: 0;
            background-color: #1a1a1a;
            padding: 10px 0;
            margin-bottom: 15px;
            border-bottom: 1px solid #4CAF50;
            z-index: 1;
        }

        /* ã‚³ãƒ³ãƒ†ãƒŠã«ãƒãƒ¼ã‚¸ãƒ³ã‚’è¿½åŠ  */
        .container {
            margin-top: 20px;
            /* Adjust as needed */
        }

        .stats-section {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 4px;
        }

        .stats-section h3 {
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .stats-section p {
            margin: 5px 0;
        }

        .modal-content button {
            background-color: #4CAF50;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        .modal-content button:hover {
            background-color: #45a049;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #4CAF50;
            position: sticky;
            top: 0;
            background-color: #1a1a1a;
            z-index: 1;
        }

        .modal-title {
            font-size: 1.5em;
            color: #4CAF50;
            margin: 0;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
        }

        .close-button {
            background: none;
            border: none;
            color: #e0e0e0;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px 10px;
            margin: -5px -10px;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .close-button:hover {
            color: #4CAF50;
            background-color: rgba(76, 175, 80, 0.1);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            padding: 10px;
        }

        .stats-section {
            background-color: #222;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .stats-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.2);
        }

        .stats-section h3 {
            color: #4CAF50;
            margin-top: 0;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 4px 0;
        }

        .stat-label {
            color: #aaa;
        }

        .stat-value {
            color: #fff;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
        }

        /* ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #statisticsButton.active {
            background-color: rgba(76, 175, 80, 0.2);
            border-color: #4CAF50;
        }

        .buy-upgrade-btn {
            /* åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
            transition: all 0.2s ease;
        }

        .buy-upgrade-btn.affordable {
            opacity: 1;
            cursor: pointer;
            /* åˆ©ç”¨å¯èƒ½ãªæ™‚ã®ä»–ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        }

        .buy-upgrade-btn.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            /* ç„¡åŠ¹æ™‚ã®ä»–ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        }

        /* ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ã‚«ãƒ¼ãƒ‰ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .monster-card.locked {
            opacity: 0.7;
            filter: grayscale(100%);
            position: relative;
        }

        .locked::before {
            content: 'ğŸ”’';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
            z-index: 1;
        }

        .unlock-requirement {
            background-color: rgba(0, 0, 0, 0.8);
            color: #ff6b6b;
            padding: 8px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            display: none;
        }

        .locked .unlock-requirement {
            display: block;
        }

        /* ãƒ›ãƒãƒ¼æ™‚ã®ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—è¡¨ç¤º */
        .locked:hover .unlock-requirement {
            background-color: rgba(0, 0, 0, 0.9);
        }

        /* ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ™‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes unlock-flash {
            0% {
                filter: grayscale(100%);
            }

            50% {
                filter: grayscale(0%) brightness(1.5);
            }

            100% {
                filter: grayscale(0%);
            }
        }

        .unlocking {
            animation: unlock-flash 1s ease-out;
        }

        .follower-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 50000;
            pointer-events: none;
            /* ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç„¡è¦– */
            will-change: opacity;
            /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æœ€é©åŒ– */
            transition: opacity 0.15s ease;
            white-space: nowrap;
            border: 1px solid #444;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ¶å¾¡ */
        .follower-tooltip.hidden {
            opacity: 0;
            visibility: hidden;
            /* display: noneã®ä»£ã‚ã‚Šã«visibilityã‚’ä½¿ç”¨ */
        }

        .follower-tooltip.visible {
            opacity: 1;
            visibility: visible;
        }

        .upgrade-card {
            position: relative;
            /* ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®ä½ç½®æ±ºã‚ã®ãŸã‚ */
        }

        /* ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®çŸ¢å° */
        .upgrade-tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #4CAF50 transparent transparent transparent;
        }

        .upgrade-card {
            position: relative;
            background-color: #192320;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            z-index: 1;
            pointer-events: auto;
        }

        .buy-upgrade-btn {
            width: 100%;
            margin-top: 10px;
            padding: 4px 8px;
            background-color: transparent;
            color: #e0e0e0;
            border: 1px solid #4CAF50;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 2;
            pointer-events: auto;
        }

        .buy-upgrade-btn:not(:disabled) {
            cursor: pointer;
            pointer-events: auto;
        }

        .buy-upgrade-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .upgrade-card h3 {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            color: #4CAF50;
            font-size: 1em;
        }

        .upgrade-card.locked {
            opacity: 0.7;
            filter: grayscale(70%);
        }

        .upgrade-card.locked::before {
            content: 'ğŸ”’';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
        }

        .upgrade-card .unlock-requirement {
            background-color: rgba(0, 0, 0, 0.8);
            color: #ff6b6b;
            padding: 8px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        /* ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ™‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes unlock-flash {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.05);
                filter: brightness(1.5);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        .upgrade-card.unlocking {
            animation: unlock-flash 0.5s ease-out;
        }

        .adventurer {
            position: relative;
            background-color: #192320;
            padding: 15px;
            border-radius: 8px;
            margin: 10px;
            transition: all 0.3s ease;
        }

        /* ãƒ˜ãƒƒãƒ€ãƒ¼éƒ¨åˆ†ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .adventurer h3 {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-right: 30px;
            /* éµãƒãƒ¼ã‚¯ã®ãŸã‚ã®ã‚¹ãƒšãƒ¼ã‚¹ */
        }

        /* ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ã‚«ãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ« */
        .adventurer.locked {
            opacity: 0.7;
            filter: grayscale(70%);
        }

        /* ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®è¦ä»¶è¡¨ç¤º */
        .unlock-requirement {
            background-color: rgba(0, 0, 0, 0.8);
            color: #ff6b6b;
            padding: 8px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            display: none;
        }

        .adventurer.locked .unlock-requirement {
            display: block;
        }

        /* ASCII ã‚¢ãƒ¼ãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´ */
        .adventurer .ascii-art {
            margin: 10px 0;
            opacity: 1;
            transition: all 0.3s ease;
        }

        .adventurer.locked .ascii-art {
            opacity: 0.5;
        }

        /* ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´ */
        .adventurer .madness-btn {
            width: 100%;
            margin-top: 10px;
            opacity: 1;
            transition: all 0.3s ease;
        }

        .adventurer.locked .madness-btn {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ãƒ›ãƒãƒ¼æ™‚ã®è¦ä»¶è¡¨ç¤ºå¼·èª¿ */
        .adventurer.locked:hover .unlock-requirement {
            background-color: rgba(0, 0, 0, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(255, 107, 107, 0.2);
        }

        /* ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ™‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes unlock-flash {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.02);
                filter: brightness(1.5);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        .adventurer.unlocking {
            animation: unlock-flash 0.5s ease-out;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #1a1a1a;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #333;
            max-width: 500px;
            width: 90%;
        }

        /* Pact Modal Styles */
        .pact-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.5s ease;
        }

        .pact-content {
            background: #1a1a1a url('path/to/parchment-texture.jpg');
            border: 2px solid #998f6b;
            border-radius: 3px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            position: relative;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
            transform: translateY(0);
            transition: transform 0.5s ease;
        }

        /* accept-pactã¨decline-pactã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤ã—ã€æ¨™æº–ã®ãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«ã«çµ±ä¸€ */
        .pact-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .pact-content button {
            font-size: 11px;
            padding: 4px 8px;
            background-color: transparent;
            color: #e0e0e0;
            border: 1px solid #4CAF50;
            border-radius: 3px;
            transition: all 0.3s ease;
            cursor: pointer;
            margin: 2px 0;
            font-family: inherit;
        }

        /* æ‹’å¦ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆresetButtonã¨å®Œå…¨ã«åŒã˜ï¼‰ */
        .pact-content button.decline-btn {
            border-color: #ff0000;
            /* èµ¤ã„æ ç·š */
            color: #ff0000;
            /* èµ¤ã„ãƒ†ã‚­ã‚¹ãƒˆ */
        }

        .pact-content button:hover:not(:disabled) {
            background-color: rgba(76, 175, 80, 0.2);
            color: #ffffff;
        }

        /* æ‹’å¦ãƒœã‚¿ãƒ³ã®ãƒ›ãƒãƒ¼æ™‚ */
        .pact-content button.decline-btn:hover:not(:disabled) {
            background-color: rgba(255, 0, 0, 0.2);
            /* èµ¤ã„èƒŒæ™¯ */
            color: #ffffff;
        }

        .pact-content button:active:not(:disabled) {
            background-color: rgba(76, 175, 80, 0.4);
        }

        /* æ‹’å¦ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ */
        .pact-content button.decline-btn:active:not(:disabled) {
            background-color: rgba(255, 0, 0, 0.4);
            /* ã‚ˆã‚Šæ¿ƒã„èµ¤ã„èƒŒæ™¯ */
        }

        .pact-content button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pact-title {
            font-family: 'UnifrakturMaguntia', 'Cinzel Decorative', 'Luminari', serif;
            font-size: 3em;
            text-align: center;
            margin-bottom: 1em;
            color: #ba1206;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 2px;
        }

        .pact-scroll {
            max-height: 60vh;
            overflow-y: auto;
            padding: 20px;
            margin: 20px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .pact-description {
            color: #e0e0e0;
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .pact-flavor {
            color: #888;
            font-style: italic;
            margin-bottom: 20px;
            padding: 10px;
            border-left: 3px solid #ba1206;
        }

        .pact-effects {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }

        .pact-effect {
            color: #ff4444;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 0, 0, 0.1);
            border-radius: 5px;
        }

        .pact-warning {
            color: #ff4444;
            text-align: center;
            font-weight: bold;
            margin: 20px 0;
        }

        .pact-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .accept-pact,
        .decline-pact {
            padding: 4px 8px;
            font-size: 11px;
            border: 1px solid #4CAF50;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Press Start 2P', cursive;
            text-transform: uppercase;
        }

        .accept-pact {
            background-color: transparent;
            color: #4CAF50;
        }

        .accept-pact:hover {
            background-color: rgba(76, 175, 80, 0.2);
            color: #ffffff;
        }

        .decline-pact {
            background-color: transparent;
            color: #ff4444;
            border-color: #ff4444;
        }

        .decline-pact:hover {
            background-color: rgba(255, 68, 68, 0.2);
            color: #ffffff;
        }

        .pact-description,
        .pact-flavor,
        .pact-warning {
            font-style: italic;
        }

        /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .pact-scroll::-webkit-scrollbar {
            width: 8px;
        }

        .pact-scroll::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .pact-scroll::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 4px;
        }

        .pact-scroll::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }

        /* PACTãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .pact-tooltip-container {
            position: relative;
            display: inline-block;
            font-family: monospace;
            white-space: pre;
        }

        .pact-tooltip-container[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            background-color: rgba(0, 0, 0, 0.9);
            color: #fff;
            border-radius: 4px;
            font-size: 12px;
            font-family: inherit;
            /* ã‚²ãƒ¼ãƒ ã®æ¨™æº–ãƒ•ã‚©ãƒ³ãƒˆã‚’ä½¿ç”¨ */
            white-space: pre-line;
            /* æ”¹è¡Œã‚’ç¶­æŒ */
            z-index: 1000;
            pointer-events: none;
            text-align: left;
            min-width: 200px;
            border: 1px solid #4CAF50;
        }

        .pact-tooltip-container[data-tooltip]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
            pointer-events: none;
        }

        @keyframes unlock-flash {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.05);
                filter: brightness(1.5);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        .unlocking {
            animation: unlock-flash 0.5s ease-out;
        }

        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .unlock-notification {
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 15px;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideIn 0.5s ease-out, fadeOut 0.5s ease-in 4.5s;
            width: 300px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .notification-content {
            flex-grow: 1;
        }

        .notification-content h4 {
            margin: 0 0 5px 0;
            color: #4CAF50;
        }

        .notification-content p {
            margin: 0;
        }

        .unlock-notification .notification-icon {
            width: 32px;
            height: 32px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .unlock-notification .monsters-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%234CAF50" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>');
        }

        .unlock-notification .adventurers-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23FFC107" d="M12 2L4 7v10l8 5 8-5V7l-8-5zm6 14.18l-6 3.82-6-3.82V8.82l6-3.82 6 3.82v7.36z"/></svg>');
        }

        .unlock-notification .upgrades-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%239C27B0" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"/></svg>');
        }

        .unlock-notification .resources-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23F44336" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>');
        }

        .unlock-notification .special-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23FFD700" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>');
        }

        /* ã‚¢ãƒ³ãƒ­ãƒƒã‚¯é€šçŸ¥ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }

        /* ãƒšãƒŠãƒ«ãƒ†ã‚£çŠ¶æ…‹ã®è¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ« */
        .penalty {
            color: #ff4444 !important;
            text-shadow: 0 0 5px #ff0000 !important;
        }

        .warning {
            color: #ff8800;
            font-weight: bold;
        }

        .penalty-warning {
            color: #ff4444;
            font-size: 0.9em;
            font-style: italic;
        }

        .follower-info {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border-left: 3px solid #4CAF50;
        }

        .follower-info p {
            margin: 5px 0;
        }

        .follower-info .warning {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <div id="debugControls" style="position: fixed; top: 10px; left: 10px; z-index: 1000;"></div>
    <button id="toggleTimeAcceleration">Toggle Time Acceleration</button>
    <span id="timeAccelerationDisplay">x1</span>
    </div>
    <div id="ascii-title-container">
        <pre id="ascii-title">
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•
â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ•â•â•â•â–ˆâ–ˆâ•‘
â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
    â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•   â•šâ•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•
â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â•šâ–ˆâ–ˆâ–ˆâ•”â• 
â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•   â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— 
â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—
    â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•šâ•â•     â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•
â–‘â–’â–“â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–“â–’â–‘
â–‘â–’â–“â–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–“â–’â–‘
â–‘â–’â–“â–ˆâ•‘ â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–“â–’â–‘
â–‘â–’â–“â–ˆâ•‘ â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–“â–’â–‘
â–‘â–’â–“â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–“â–’â–‘
â–‘â–’â–“ â•šâ•â•â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â–“â–’â–‘
â˜½ â™† â™„ Summon. Corrupt. Conquer. Idle. â™ƒ â™‡ â˜¾
    </pre>
    </div>
    <h1 id="text-title" style="font-family: 'Audiowide', cursive; font-size: 1.5em;">CULTIST'S COMPLEX IDLE</h1>
    <div id="version-display">v0.1.2</div>
    <div id="upgradeSymbols" style="
    margin: 3px 0;
    padding: 5px;
    position: relative;
    overflow: visible;
"></div>
    <div id="game-header">
        <div style="text-align: center; margin: 5px 0;">
            <span style="margin-left: 15px;">Tick Speed: <span id="tickSpeedDisplay"
                    style="color: #4CAF50;"></span></span>
        </div>
        <p>
        <div id="top-buttons">
            <button id="toggleCrtEffect">CRT Effect: ON</button>
            <button id="toggleStatistics">Statistics</button>
            <button id="toggleAllMonsterCards">Collapse All Cards</button>
            <button id="jumpToSummonOldOne" title="Press 'S' to jump">Jump to Summon Old One</button>
            <button id="jumpToMadnessTable" title="Press 'A' to jump">Jump to Madness Table</button>
            <button id="backToTopBtn">Back to Top</button>
            <button id="pauseGameBtn">Pause Game</button>
            <button onclick="saveGame()">Save Game</button>
            <button onclick="loadGame()">Load Game</button>
            <button id="resetButton" onclick="resetGameAndClearSave()">Reset Game</button>
        </div>
        </p>
        <div id="resourceDisplay" class="panel">
            <!-- å·¦å´: Source & Miasma -->
            <div class="resource-column">
                <h2>Source Collected</h2>
                <div class="resource-value-container">
                    <p id="largeSourceCount" class="resource-value">0</p>
                    <span class="rate-display">(+<span id="largeSourcePerSecond">0</span>/sec)</span>
                </div>
                <h2>Miasma Accumulated</h2>
                <div class="resource-value-container">
                    <p id="largeMiasmaCount" class="resource-value">0</p>
                    <span class="rate-display">(+<span id="largeMiasmaPerSecond">0</span>/sec)</span>
                </div>
            </div>

            <!-- ä¸­å¤®: ASCII ã‚¢ãƒ¼ãƒˆ -->
            <div id="cultosminer" class="ascii-container">
                <!-- ASCII ã‚¢ãƒ¼ãƒˆãŒã“ã“ã«å…¥ã‚Šã¾ã™ -->
            </div>

            <!-- å³å´: Cultos -->
            <div class="resource-column" id="cultosColumn">
                <h2>Cultos Mined</h2>
                <div class="resource-value-container">
                    <p id="largeCultosCount" class="resource-value">
                        <span class="cultos-symbol">Â©ï¸</span>
                        <span class="cultos-count">0</span>
                        <span class="rate-display">(<span id="cultosHashRate">0</span> H/s)</span>
                    <div class="mining-status"></div>
                    <div class="mining-indicator" id="miningIndicator"></div>
                    <button id="toggleMining" class="small-button">Start Mining</button>
                </div>
                <div class="consumption-rates">
                    <div class="consumption-rate-container">
                        <p class="consumption-rate">Source:âš¡ï¸ <span id="sourceConsumptionRate"
                                class="rate-value inactive">0/s</span></p>
                        <p class="consumption-rate">Miasma:âš¡ï¸ <span id="miasmaConsumptionRate"
                                class="rate-value inactive">0/s</span></p>
                    </div>
                </div>
            </div>

        </div>
    </div>
    <div class="container">
        <div class="sidebar panel">
            <div id="followerSection">
                <h2>Followers</h2>
                <div class="ascii-art" id="followerAsciiArt">
                    ${asciiArt['Follower']}
                </div>
                <p>Count: <span id="followerCount">0</span></p>
                <p>Efficiency: <span id="followerEfficiency">0.1</span></p>
                <p>Production: <span id="followerPerSecond">0</span>/sec</p>
                <p>Next Recruit Cost: <span id="nextFollowerCost">10</span> source</p>
            </div>
            <h2>Resources</h2>
            <button onclick="collectSource()">Collect Source</button>
            <P><button id="recruitFollowerBtn">Recruit Follower</button></P>

            <div id="gameDetails">
                <h2>Game Details</h2>
                <p><strong>Follower Efficiency:</strong> <span id="followerEfficiencyDetail">0.1</span></p>
                <p><strong>Follower Boost:</strong> <span id="followerBoost">1.00</span>x</p>
                <p><strong>Monster Synergy Boost:</strong> <span id="monsterSynergyBoost">1.00</span>x</p>
                <p><strong>Active Upgrades:</strong> <span id="activeUpgrades">None</span></p>
                <h3>Monster Production:</h3>
                <div id="monsterProductionDetails">
                    <!-- Monster production details will be dynamically added here -->
                </div>
            </div>

            <div id="log">
                <h2>Actions Log</h2>
                <div id="logEntries">
                    <!-- Log entries will be dynamically added here -->
                </div>
            </div>
        </div>
        <div class="main-content panel">
            <div id="statisticsModal" class="modal">
                <div class="modal-content">
                    <h2>Game Statistics</h2>

                    <!-- æ™‚é–“çµ±è¨ˆ -->
                    <div class="stats-section">
                        <h3>Time Statistics</h3>
                        <p>Total Time Played: <span id="timePlayed">0</span></p>
                        <p>Active Play Time: <span id="activePlayTime">0</span></p>
                    </div>

                    <!-- ãƒªã‚½ãƒ¼ã‚¹çµ±è¨ˆ -->
                    <div class="stats-section">
                        <h3>Resource Statistics</h3>
                        <p>Total Source Generated: <span id="totalSourceGenerated">0</span></p>
                        <p>Source per Second: <span id="sourcePerSecond">0</span></p>
                        <p>Total Miasma Generated: <span id="totalMiasmaGenerated">0</span></p>
                        <p>Miasma per Second: <span id="miasmaPerSecond">0</span></p>
                        <p>Total Cultos Generated: <span id="totalCultosGenerated">0</span></p>
                        <p>Cultos per Second: <span id="cultosPerSecond">0</span></p>
                    </div>

                    <!-- ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼çµ±è¨ˆ -->
                    <div class="stats-section">
                        <h3>Follower Statistics</h3>
                        <p>Total Followers Recruited: <span id="totalFollowersRecruited">0</span></p>
                        <p>Peak Followers: <span id="peakFollowers">0</span></p>
                        <p>Current Followers: <span id="currentFollowers">0</span></p>
                        <p>Current Efficiency: <span id="currentFollowerEfficiency">0</span></p>
                        <p>Average Followers/Second: <span id="averageFollowersPerSecond">0</span></p>
                    </div>

                    <!-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼çµ±è¨ˆ -->
                    <div class="stats-section">
                        <h3>Monster Statistics</h3>
                        <p>Total Monsters Summoned: <span id="totalMonstersSummoned">0</span></p>
                        <p>Unique Monster Types: <span id="uniqueMonsterTypes">0</span></p>
                        <p>Most Common Monster: <span id="mostCommonMonster">None</span></p>
                        <p>Total Monster Cost: <span id="totalMonsterCost">0</span></p>
                        <p>Monsters per Minute: <span id="averageMonstersPerMinute">0</span></p>
                    </div>

                    <!-- ç‹‚æ°—çµ±è¨ˆ -->
                    <div class="stats-section">
                        <h3>Madness Statistics</h3>
                        <p>Total Madness Attempts: <span id="totalMadnessAttempts">0</span></p>
                        <p>Successful Madness: <span id="successfulMadness">0</span></p>
                        <p>Success Rate: <span id="madnessSuccessRate">0%</span></p>
                        <p>Attempts per Hour: <span id="averageMadnessAttemptsPerHour">0</span></p>
                    </div>

                    <!-- å¥‘ç´„çµ±è¨ˆ -->
                    <div class="stats-section">
                        <h3>Pact Statistics</h3>
                        <p>Active Pacts: <span id="activePacts">0</span></p>
                        <p>Total Pacts Sealed: <span id="totalPactsSealed">0</span></p>
                        <p>Current Pact Multiplier: <span id="currentPactMultiplier">1</span></p>
                        <p>Tick Speed Multiplier: <span id="currentTickSpeedMultiplier">1</span></p>
                    </div>

                    <!-- ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰çµ±è¨ˆ -->
                    <div class="stats-section">
                        <h3>Upgrade Statistics</h3>
                        <p>Total Upgrades Purchased: <span id="totalUpgradesPurchased">0</span></p>
                        <p>Upgrade Efficiency: <span id="upgradeEfficiency">1</span></p>
                        <p>Total Upgrade Cost: <span id="totalUpgradeCost">0</span></p>
                    </div>

                    <!-- åŠ¹ç‡æ€§æŒ‡æ¨™ -->
                    <div class="stats-section">
                        <h3>Efficiency Metrics</h3>
                        <p>Overall Efficiency: <span id="overallGameEfficiency">1</span></p>
                        <p>Resource Generation: <span id="resourceGenerationEfficiency">1</span></p>
                        <p>Follower Recruitment: <span id="followerRecruitmentEfficiency">1</span></p>
                    </div>

                    <button onclick="toggleStatisticsModal()">Close</button>
                </div>
            </div>
            <h2>Summon Old Ones</h2>
            <div id="monsterGridContainer">
                <div id="monsterGrid" class="monster-grid">

                </div>
            </div>
        </div>


        <div class="upgrades panel">
            <h2>Upgrades</h2>
            <div id="upgradeGrid" class="upgrade-grid">

                <!-- Additional upgrade cards will be dynamically added here -->
            </div>
        </div>

        <div class="madness-table panel" id="madnessTable">
            <h2>Madness Table</h2>
            <div id="adventurers">
            </div>
        </div>


        <script>
            const gameVersion = '0.1.2';
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ­ãƒƒã‚¯ã¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å›ºæœ‰ã®ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ 
            let globalLock = false;
            const actionLocks = {
                recruitFollower: false,
                summonMonster: {}
            };

            let gamePaused = false;

            // CRTãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®çŠ¶æ…‹ç®¡ç†ç”¨ã®ã‚³ãƒ¼ãƒ‰
            let isCrtFilterEnabled = true; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã‚ªãƒ³

            function toggleCrtFilter() {
                const crtButton = document.getElementById('toggleCrtEffect');
                if (!crtButton) {
                    console.warn('CRT toggle button not found');
                    return;
                }

                isCrtEnabled = !isCrtEnabled;

                // CRTåŠ¹æœã®åˆ‡ã‚Šæ›¿ãˆ
                if (isCrtEnabled) {
                    document.body.classList.remove('crt-filter-disabled');
                } else {
                    document.body.classList.add('crt-filter-disabled');
                }

                // ãƒœã‚¿ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
                crtButton.textContent = isCrtEnabled ? 'CRT Effect: ON' : 'CRT Effect: OFF';

                // è¨­å®šã‚’ä¿å­˜
                localStorage.setItem('crtEnabled', isCrtEnabled);

                // ãƒ‡ãƒãƒƒã‚°ç”¨ã®ãƒ­ã‚°
                console.log('CRT Effect:', isCrtEnabled ? 'ON' : 'OFF');
                console.log('Body classes:', document.body.classList.toString());
            }

            // åˆæœŸåŒ–æ™‚ã®CRTåŠ¹æœã®è¨­å®š
            document.addEventListener('DOMContentLoaded', function () {
                const crtButton = document.getElementById('toggleCrtEffect');
                if (!crtButton) {
                    console.warn('CRT toggle button not found');
                    return;
                }

                // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                crtButton.addEventListener('click', toggleCrtFilter);

                // ä¿å­˜ã•ã‚ŒãŸè¨­å®šã‚’å¾©å…ƒ
                const savedCrtState = localStorage.getItem('crtEnabled');
                isCrtEnabled = savedCrtState === null ? true : savedCrtState === 'true';

                // åˆæœŸçŠ¶æ…‹ã®è¨­å®š
                if (!isCrtEnabled) {
                    document.body.classList.add('crt-filter-disabled');
                }

                crtButton.textContent = isCrtEnabled ? 'CRT Effect: ON' : 'CRT Effect: OFF';
            });

            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã®è¿½åŠ 
            document.addEventListener('keydown', function (event) {
                // Sã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸå ´åˆï¼ˆå°æ–‡å­—ã®sã¨å¤§æ–‡å­—ã®Sã®ä¸¡æ–¹ã«å¯¾å¿œï¼‰
                if (event.key.toLowerCase() === 's' && !event.ctrlKey && !event.altKey &&
                    document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    event.preventDefault(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œã‚’é˜²æ­¢
                    document.getElementById('jumpToSummonOldOne').click();
                }
                if (event.key.toLowerCase() === 'a' && !event.ctrlKey && !event.altKey &&
                    document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    event.preventDefault(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œã‚’é˜²æ­¢
                    document.getElementById('jumpToMadnessTable').click();
                }
                if (event.code === 'Space' && !event.repeat) {
                    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                        return;
                    }

                    event.preventDefault();

                    const pauseButton = document.getElementById('pauseGameBtn');

                    // ã‚²ãƒ¼ãƒ ã®ä¸€æ™‚åœæ­¢çŠ¶æ…‹ã‚’åˆ‡ã‚Šæ›¿ãˆ
                    if (gamePaused) {
                        resumeGame();
                        pauseButton.textContent = 'Pause Game';
                        pauseButton.style.borderColor = '#4CAF50';  // ç·‘è‰²ã®æ 
                        pauseButton.style.color = '#e0e0e0';        // é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆè‰²
                    } else {
                        pauseGame();
                        pauseButton.textContent = 'Resume Game';
                        pauseButton.style.borderColor = '#ff0000';  // èµ¤è‰²ã®æ 
                        pauseButton.style.color = '#ff0000';        // èµ¤è‰²ã®ãƒ†ã‚­ã‚¹ãƒˆ
                    }
                }
                if (event.key === '[' || event.key === ']') {
                    // è³¼å…¥å¯èƒ½ãªã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
                    const allAvailableItems = getAvailableItems();
                    if (allAvailableItems.length === 0) return;

                    // å®Ÿéš›ã«è³¼å…¥ã§ãã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                    const purchasableItems = allAvailableItems.filter(item => {
                        switch (item.type) {
                            case 'monster':
                                const monster = gameState.monsters[item.id];
                                const followerCost = Math.floor(monster.baseFollowerCost *
                                    Math.pow(monster.followerCostGrowth, monster.count));
                                return gameState.source >= item.cost && gameState.followers >= followerCost;

                            case 'upgrade':
                                return gameState.source >= item.cost;

                            case 'follower':
                                return gameState.source >= item.cost;

                            default:
                                return false;
                        }
                    });

                    if (purchasableItems.length === 0) return;

                    // ã‚³ã‚¹ãƒˆã§ã‚½ãƒ¼ãƒˆ
                    purchasableItems.sort((a, b) => b.cost - a.cost); // é«˜ã„é †

                    // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ä»¥å¤–ã®è³¼å…¥å¯èƒ½ãªã‚¢ã‚¤ãƒ†ãƒ 
                    const nonFollowerItems = purchasableItems.filter(item => item.type !== 'follower');

                    // '[' ã¯æœ€ã‚‚é«˜ã„ã‚³ã‚¹ãƒˆã€']' ã¯æœ€ã‚‚ä½ã„ã‚³ã‚¹ãƒˆã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’è³¼å…¥
                    const itemToBuy = event.key === '['
                        ? (nonFollowerItems.length > 0 ? nonFollowerItems[0] : purchasableItems[0])
                        : purchasableItems[purchasableItems.length - 1];

                    // ã‚¢ã‚¤ãƒ†ãƒ ã®ç¨®é¡ã«å¿œã˜ã¦è³¼å…¥å‡¦ç†ã‚’å®Ÿè¡Œ
                    switch (itemToBuy.type) {
                        case 'monster':
                            summonMonster(itemToBuy.id);
                            break;
                        case 'upgrade':
                            buyUpgrade(itemToBuy.id);
                            break;
                        case 'follower':
                            recruitFollower();
                            break;
                    }
                }
            });

            // è³¼å…¥å¯èƒ½ãªã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—ã™ã‚‹é–¢æ•°
            function getAvailableItems() {
                const items = [];
                const sourceCount = gameState.source;

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ - å¥‘ç´„ã«ã‚ˆã‚‹å°å°ã‚’ãƒã‚§ãƒƒã‚¯
                const followerCost = getCost('follower');
                const isFollowerRecruitmentSealed = gameState.pacts?.active?.some(pact =>
                    PACTS[pact]?.effects?.some(effect => effect.type === 'sealManualRecruits')
                ) ?? false;

                // æœ€å°ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã®åŠ¹æœã‚’ãƒã‚§ãƒƒã‚¯
                const minimumFollowersEffect = gameState.pacts?.active?.reduce((min, pact) => {
                    const effect = PACTS[pact]?.effects?.find(e => e.type === 'minimumFollowers');
                    return effect ? Math.max(min, effect.value) : min;
                }, 0) ?? 0;

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ãŒæœ€å°å€¤ä»¥ä¸‹ã®å ´åˆã€ã‚³ã‚¹ãƒˆã‚’0ã«
                const actualFollowerCost = gameState.followers < minimumFollowersEffect ? 0 : followerCost;

                if ((sourceCount >= actualFollowerCost || actualFollowerCost === 0) && !isFollowerRecruitmentSealed) {
                    items.push({
                        type: 'follower',
                        id: 'follower',
                        cost: actualFollowerCost
                    });
                }

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ãƒã‚§ãƒƒã‚¯
                for (const [monsterType, monster] of Object.entries(gameState.monsters)) {
                    if (!checkUnlockCondition('monsters', monsterType)) continue;

                    const sourceCost = getCost(monsterType);
                    const followerCost = Math.floor(monster.baseFollowerCost *
                        Math.pow(monster.followerCostGrowth, monster.count));

                    if (sourceCount >= sourceCost && gameState.followers >= followerCost) {
                        items.push({
                            type: 'monster',
                            id: monsterType,
                            cost: sourceCost
                        });
                    }
                }

                // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ãƒã‚§ãƒƒã‚¯
                for (const upgrade of upgradeOrder) {
                    if (gameState.upgrades.includes(upgrade)) continue;
                    if (!checkUnlockCondition('upgrades', upgrade)) continue;

                    const cost = Math.floor(baseCosts[upgrade] * (gameState.upgradeCostMultiplier || 1));
                    if (sourceCount >= cost) {
                        items.push({
                            type: 'upgrade',
                            id: upgrade,
                            cost: cost
                        });
                    }
                }

                return items;
            }

            // ã‚¿ã‚¤ãƒˆãƒ«ã®åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½
            let isAscii = true;
            const asciiContainer = document.getElementById('ascii-title-container');
            const textTitle = document.getElementById('text-title');

            asciiContainer.addEventListener('click', function () {
                if (isAscii) {
                    // ASCIIã‚¢ãƒ¼ãƒˆã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã¸
                    asciiContainer.classList.add('fade-out');
                    setTimeout(() => {
                        asciiContainer.style.display = 'none';
                        textTitle.style.display = 'block';
                        setTimeout(() => {
                            textTitle.classList.add('fade-in');
                        }, 50);
                    }, 300);
                }
                isAscii = !isAscii;
            });

            textTitle.addEventListener('click', function () {
                if (!isAscii) {
                    // ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ASCIIã‚¢ãƒ¼ãƒˆã¸
                    textTitle.classList.remove('fade-in');
                    setTimeout(() => {
                        textTitle.style.display = 'none';
                        asciiContainer.style.display = 'block';
                        asciiContainer.classList.remove('fade-out');
                    }, 300);
                }
                isAscii = !isAscii;
            });

            document.addEventListener('DOMContentLoaded', function () {
                const resourceDisplay = document.getElementById('resourceDisplay');
                if (!resourceDisplay) return;

                // topãƒœã‚¿ãƒ³ã«æ–°ã—ã„ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
                const topButtons = document.getElementById('top-buttons');
                if (topButtons) {
                    const toggleDisplayButton = document.createElement('button');
                    toggleDisplayButton.id = 'toggleResourceDisplay';
                    toggleDisplayButton.textContent = 'Simple View: OFF';

                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ normal ãƒ¢ãƒ¼ãƒ‰ã«è¨­å®š
                    resourceDisplay.classList.remove('simple');
                    localStorage.setItem('resourceDisplayMode', 'normal');

                    // æ–°ã—ã„ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
                    toggleDisplayButton.addEventListener('click', function () {
                        const isSimple = resourceDisplay.classList.toggle('simple');
                        toggleDisplayButton.textContent = `Simple View: ${isSimple ? 'ON' : 'OFF'}`;
                        localStorage.setItem('resourceDisplayMode', isSimple ? 'simple' : 'normal');
                    });

                    // CRT Effect ãƒœã‚¿ãƒ³ã®å¾Œã«æŒ¿å…¥
                    const crtButton = document.getElementById('toggleCrtEffect');
                    if (crtButton && crtButton.parentNode) {
                        crtButton.parentNode.insertBefore(toggleDisplayButton, crtButton.nextSibling);
                    } else {
                        topButtons.appendChild(toggleDisplayButton);
                    }
                }
            });

            let timeAcceleration = 1; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯é€šå¸¸é€Ÿåº¦
            // Game state
            let gameState = {

                source: 0,
                miasma: 0,
                cultos: 0,
                cultosRate: 0,
                followers: 0,
                followerEfficiency: 0.1,
                followerAccumulator: 0,
                monsters: {
                    'Shoggoth': {
                        count: 0,
                        sourceEfficiency: 0.5,
                        miasmaEfficiency: 0.1,
                        baseFollowerCost: 1,
                        followerCostGrowth: 1.1,
                        synergy: { partner: 'Deep One', effect: 0.09 },
                        specialAbility: { trigger: 100, effect: { type: 'allMonsterEfficiency', value: 0.005 } }
                    },
                    'This Man': {
                        count: 0,
                        sourceEfficiency: 1.8,
                        miasmaEfficiency: 0.36,
                        baseFollowerCost: 2,
                        followerCostGrowth: 1.12,
                        synergy: { partner: 'Byakhee', effect: 0.135, type: 'miasma' },
                        specialAbility: { trigger: 10, effect: { type: 'madnessChance', value: 0.05 } }
                    },
                    'Deep One': {
                        count: 0,
                        sourceEfficiency: 3.0,
                        miasmaEfficiency: 0.5,
                        baseFollowerCost: 3,
                        followerCostGrowth: 1.15,
                        synergy: { partner: 'Shoggoth', effect: 0.09 },
                        specialAbility: {
                            trigger: 25,
                            effect: {
                                type: 'miasmaEfficiency',
                                value: 0.025
                            }
                        }
                    },
                    'Byakhee': {
                        count: 0,
                        sourceEfficiency: 6.5,
                        miasmaEfficiency: 1.1,
                        baseFollowerCost: 4,
                        followerCostGrowth: 1.17,
                        synergy: { partner: 'This Man', effect: 0.135, type: 'miasma' },
                        specialAbility: { trigger: 30, effect: { type: 'sourceProduction', value: 0.027 } }
                    },
                    'Elder Thing': {
                        count: 0,
                        sourceEfficiency: 10.0,
                        miasmaEfficiency: 2.0,
                        baseFollowerCost: 5,
                        followerCostGrowth: 1.2,
                        synergy: { partner: 'Mi-go', effect: 0.18, type: 'source' },
                        specialAbility: { trigger: 20, effect: { type: 'upgradeEffect', value: 0.009 } }
                    },
                    'Mossman': {
                        count: 0,
                        sourceEfficiency: 16.0,
                        miasmaEfficiency: 3.2,
                        baseFollowerCost: 7,
                        followerCostGrowth: 1.22,
                        synergy: { partner: 'Nightgaunt', effect: 0.225, type: 'miasma' },
                        specialAbility: { trigger: 15, effect: { type: 'followerProduction', value: 0.09 } }
                    },
                    'Star Spawn': {
                        count: 0,
                        sourceEfficiency: 25.0,
                        miasmaEfficiency: 5.0,
                        baseFollowerCost: 10,
                        followerCostGrowth: 1.25,
                        synergy: { partner: 'Uroboros', effect: 0.27 },
                        specialAbility: { trigger: 10, effect: { type: 'cosmicResonance', value: 0.01 } }
                    },
                    'Mi-go': {
                        count: 0,
                        sourceEfficiency: 75.0,
                        miasmaEfficiency: 15.0,
                        baseFollowerCost: 20,
                        followerCostGrowth: 1.3,
                        synergy: { partner: 'Elder Thing', effect: 0.18, type: 'source' },
                        specialAbility: {
                            trigger: 5,
                            effect: {
                                type: 'upgradeCost',
                                value: 0.0025,
                                maxDiscount: 0.4
                            }
                        }
                    },
                    'Nightgaunt': {
                        count: 0,
                        sourceEfficiency: 250.0,
                        miasmaEfficiency: 50.0,
                        baseFollowerCost: 50,
                        followerCostGrowth: 1.35,
                        synergy: {
                            partner: 'Mossman',
                            effect: 0.225,
                            type: 'miasma'
                        },
                        specialAbility: {
                            trigger: 10,
                            effect: {
                                type: 'adventurerResistanceRecoveryTime',
                                value: 1000  // 1ç§’ï¼ˆ1000ãƒŸãƒªç§’ï¼‰ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³å‰Šæ¸›
                            }
                        }
                    },
                    'Uroboros': {
                        count: 0,
                        sourceEfficiency: 900.0,
                        miasmaEfficiency: 180.0,
                        baseFollowerCost: 100,
                        followerCostGrowth: 1.4,
                        synergy: { partner: 'Star Spawn', effect: 0.27 },
                        specialAbility: { trigger: 10, effect: { type: 'allMonsterEfficiency', value: 0.0009 } }
                    }
                },
                upgrades: [],
                followerEfficiency: 0.1,
                adventurers: [
                    { name: "Novice Explorer", miasmaRequired: 100, followerReward: 1, followerProduction: 0.1, madnessChance: 0.7, level: 0, isMad: false, cooldownEndTime: 0, baseCooldown: 16000 },
                    { name: "Seasoned Investigator", miasmaRequired: 500, followerReward: 4, followerProduction: 0.5, madnessChance: 0.5, level: 0, isMad: false, cooldownEndTime: 0, baseCooldown: 33000 },
                    { name: "Arcane Scholar", miasmaRequired: 2000, followerReward: 18, followerProduction: 2.0, madnessChance: 0.3, level: 0, isMad: false, cooldownEndTime: 0, baseCooldown: 70000 },
                    { name: "Occult Detective", miasmaRequired: 5000, followerReward: 45, followerProduction: 5.0, madnessChance: 0.2, level: 0, isMad: false, cooldownEndTime: 0, baseCooldown: 12000 },
                    { name: "Eldritch Archaeologist", miasmaRequired: 10000, followerReward: 90, followerProduction: 10.0, madnessChance: 0.01, level: 0, isMad: false, cooldownEndTime: 0, baseCooldown: 210000 },
                    { name: "Cosmic Voyager", miasmaRequired: 20000, followerReward: 180, followerProduction: 20.0, madnessChance: 0.005, level: 0, isMad: false, cooldownEndTime: 0, baseCooldown: 330000 }
                ],

                // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ¸ˆã¿ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è¿½è·¡ç”¨
                unlockedContent: {
                    monsters: new Set(['Shoggoth']),
                    adventurers: new Set(['Novice Explorer']),
                    upgrades: new Set(['Ritual Knowledge']),
                    resources: new Set()
                },
                pacts: {
                    active: [],              // ç™ºå‹•ä¸­ã®å¥‘ç´„
                    commonMultiplier: 1,     // å…±é€šã®å€ç‡åŠ¹æœ (1.125^å¥‘ç´„æ•°)
                    tickSpeedMultiplier: 1,  // Tick speedå€ç‡ (1.125^å¥‘ç´„æ•°)
                    showingPactModal: false, // å¥‘ç´„ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºçŠ¶æ…‹
                },
            };

            const initialGameState = {
                source: 0,
                miasma: 0,
                cultos: 0,
                cultosRate: 0,
                followers: 0,
                monsters: {
                    'Shoggoth': {
                        count: 0,
                        sourceEfficiency: 0.5,
                        miasmaEfficiency: 0.1,
                        baseFollowerCost: 1,
                        followerCostGrowth: 1.15,
                        synergy: { partner: 'Deep One', effect: 0.09 },
                        specialAbility: { trigger: 100, effect: { type: 'allMonsterEfficiency', value: 0.005 } }
                    },
                    'This Man': {
                        count: 0,
                        sourceEfficiency: 2.0,
                        miasmaEfficiency: 0.4,
                        baseFollowerCost: 2,
                        followerCostGrowth: 1.18,
                        synergy: { partner: 'Byakhee', effect: 0.135, type: 'miasma' },
                        specialAbility: { trigger: 10, effect: { type: 'madnessChance', value: 0.05 } }
                    },
                    'Deep One': {
                        count: 0,
                        sourceEfficiency: 5.0,
                        miasmaEfficiency: 1.0,
                        baseFollowerCost: 3,
                        followerCostGrowth: 1.21,
                        synergy: { partner: 'Shoggoth', effect: 0.09 },
                        specialAbility: {
                            trigger: 25,
                            effect: { type: 'miasmaEfficiency', value: 0.025 }
                        }
                    },
                    'Byakhee': {
                        count: 0,
                        sourceEfficiency: 12.0,
                        miasmaEfficiency: 2.4,
                        baseFollowerCost: 4,
                        followerCostGrowth: 1.24,
                        synergy: { partner: 'This Man', effect: 0.135, type: 'miasma' },
                        specialAbility: { trigger: 30, effect: { type: 'sourceProduction', value: 0.027 } }
                    },
                    'Elder Thing': {
                        count: 0,
                        sourceEfficiency: 30.0,
                        miasmaEfficiency: 6.0,
                        baseFollowerCost: 5,
                        followerCostGrowth: 1.27,
                        synergy: { partner: 'Mi-go', effect: 0.18, type: 'source' },
                        specialAbility: { trigger: 20, effect: { type: 'upgradeEffect', value: 0.009 } }
                    },
                    'Mossman': {
                        count: 0,
                        sourceEfficiency: 75.0,
                        miasmaEfficiency: 15.0,
                        baseFollowerCost: 7,
                        followerCostGrowth: 1.30,
                        synergy: { partner: 'Nightgaunt', effect: 0.225, type: 'miasma' },
                        specialAbility: { trigger: 15, effect: { type: 'followerProduction', value: 0.09 } }
                    },
                    'Star Spawn': {
                        count: 0,
                        sourceEfficiency: 200.0,
                        miasmaEfficiency: 40.0,
                        baseFollowerCost: 10,
                        followerCostGrowth: 1.33,
                        synergy: { partner: 'Uroboros', effect: 0.27 },
                        specialAbility: { trigger: 10, effect: { type: 'cosmicResonance', value: 0.01 } }
                    },
                    'Mi-go': {
                        count: 0,
                        sourceEfficiency: 500.0,
                        miasmaEfficiency: 100.0,
                        baseFollowerCost: 20,
                        followerCostGrowth: 1.36,
                        synergy: { partner: 'Elder Thing', effect: 0.18, type: 'source' },
                        specialAbility: {
                            trigger: 5,
                            effect: {
                                type: 'upgradeCost',
                                value: 0.0025,
                                maxDiscount: 0.4
                            }
                        }
                    },
                    'Nightgaunt': {
                        count: 0,
                        sourceEfficiency: 1250.0,
                        miasmaEfficiency: 250.0,
                        baseFollowerCost: 50,
                        followerCostGrowth: 1.39,
                        synergy: {
                            partner: 'Mossman',
                            effect: 0.225,
                            type: 'miasma'
                        },
                        specialAbility: {
                            trigger: 10,
                            effect: {
                                type: 'adventurerResistanceRecoveryTime',
                                value: 1000
                            }
                        }
                    },
                    'Uroboros': {
                        count: 0,
                        sourceEfficiency: 3000.0,
                        miasmaEfficiency: 600.0,
                        baseFollowerCost: 100,
                        followerCostGrowth: 1.42,
                        synergy: { partner: 'Star Spawn', effect: 0.27 },
                        specialAbility: { trigger: 10, effect: { type: 'allMonsterEfficiency', value: 0.0009 } }
                    }
                },
                upgrades: [],
                followerEfficiency: 0.1,

                cosmicAlignmentBonus: 1,
                astralProjectionRate: 0,
                quantumEntanglementBonus: 0,
                temporalManipulationBonus: 1,
                eldritchEvolutionRate: 0,
                upgradeCostMultiplier: 1,

                adventurers: [
                    {
                        name: "Novice Explorer",
                        miasmaRequired: 100,
                        followerReward: 1,
                        followerProduction: 0.1,
                        madnessChance: 0.7,    // æ˜ç¤ºçš„ã«åˆæœŸå€¤ã‚’è¨­å®š
                        level: 0,
                        isMad: false,
                        cooldownEndTime: 0,
                        baseCooldown: 16000
                    },
                    {
                        name: "Seasoned Investigator",
                        miasmaRequired: 500,
                        followerReward: 4,
                        followerProduction: 0.5,
                        madnessChance: 0.5,
                        level: 0,
                        isMad: false,
                        cooldownEndTime: 0,
                        baseCooldown: 33000
                    },
                    {
                        name: "Arcane Scholar",
                        miasmaRequired: 2000,
                        followerReward: 18,
                        followerProduction: 2.0,
                        madnessChance: 0.3,
                        level: 0,
                        isMad: false,
                        cooldownEndTime: 0,
                        baseCooldown: 70000
                    },
                    {
                        name: "Occult Detective",
                        miasmaRequired: 5000,
                        followerReward: 45,
                        followerProduction: 5.0,
                        madnessChance: 0.2,
                        level: 0,
                        isMad: false,
                        cooldownEndTime: 0,
                        baseCooldown: 120000
                    },
                    {
                        name: "Eldritch Archaeologist",
                        miasmaRequired: 10000,
                        followerReward: 90,
                        followerProduction: 10.0,
                        madnessChance: 0.1,
                        level: 0,
                        isMad: false,
                        cooldownEndTime: 0,
                        baseCooldown: 210000
                    },
                    {
                        name: "Cosmic Voyager",
                        miasmaRequired: 20000,
                        followerReward: 180,
                        followerProduction: 20.0,
                        madnessChance: 0.05,
                        level: 0,
                        isMad: false,
                        cooldownEndTime: 0,
                        baseCooldown: 330000
                    }
                ],
                // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®åˆæœŸå€¤
                unlockedContent: {
                    monsters: new Set(),
                    adventurers: new Set(),
                    upgrades: new Set(),
                    resources: new Set()
                },
                // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰çŠ¶æ…‹
                upgrades: [],

                // å¥‘ç´„ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸçŠ¶æ…‹
                pacts: {
                    active: [],
                    commonMultiplier: 1,
                    tickSpeedMultiplier: 1,
                    showingPactModal: false
                },

                // çµ±è¨ˆæƒ…å ±ã®åˆæœŸçŠ¶æ…‹
                statistics: {
                    startTime: Date.now(),
                    lastUpdate: Date.now(),
                    totalSourceGenerated: 0,
                    totalMiasmaGenerated: 0,
                    totalFollowersRecruited: 0,
                    peakFollowers: 0,
                    totalMonstersSummoned: 0,
                    totalMadnessAttempts: 0,
                    successfulMadness: 0
                },
            };

            const monsterOrder = [
                'Shoggoth',
                'This Man',
                'Deep One',
                'Byakhee',
                'Elder Thing',
                'Mossman',
                'Star Spawn',
                'Mi-go',
                'Nightgaunt',
                'Uroboros'
            ];

            const baseCosts = {
                follower: 10,
                'Shoggoth': 100,
                'This Man': 800,      // 8å€
                'Deep One': 4000,     // 5å€
                'Byakhee': 15000,     // 3.75å€
                'Elder Thing': 50000,  // 3.33å€
                'Mossman': 150000,    // 3å€
                'Star Spawn': 400000, // 2.67å€
                'Mi-go': 1000000,     // 2.5å€
                'Nightgaunt': 2500000, // 2.5å€
                'Uroboros': 6000000,  // 2.4å€

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã‚³ã‚¹ãƒˆæˆé•·ç‡ã‚‚èª¿æ•´
                followerCostGrowth: {
                    'Shoggoth': 1.15,
                    'This Man': 1.18,
                    'Deep One': 1.21,
                    'Byakhee': 1.24,
                    'Elder Thing': 1.27,
                    'Mossman': 1.30,
                    'Star Spawn': 1.33,
                    'Mi-go': 1.36,
                    'Nightgaunt': 1.39,
                    'Uroboros': 1.42
                },
                // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ä¾¡æ ¼ã‚’èª¿æ•´
                follower: 10,
                'Ritual Knowledge': 150,        // æœ€åˆã®åŸºæœ¬çš„ãªã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰
                'Eldritch Tome': 500,          // æ—©æœŸã«å–å¾—å¯èƒ½ãªå¼·åŒ–
                'Hiroshi Sakamoto`s Paper': 2000, // ç‰¹æ®Šãªã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰
                'Cosmic Alignment': 3000,      // ä¸­ç›¤ã®é‡è¦ãªå¼·åŒ–
                'Forbidden Ritual': 8000,            // ä¸­ç›¤å¾ŒåŠã®å¼·åŠ›ãªå¼·åŒ–
                'Hermetic Teachings': 35000,   // å¾ŒåŠã®é‡è¦ãªã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰
                'Cosmic Insight': 80000,      // ã‚¨ãƒ³ãƒ‰ã‚²ãƒ¼ãƒ ã®å¼·åŠ›ãªå¼·åŒ–
                'Astral Projection': 300000,   // ç‰¹æ®Šãªç”Ÿç”£ãƒœãƒ¼ãƒŠã‚¹
                'Dimensional Rift': 500000,    // éå¸¸ã«å¼·åŠ›ãªç›¸ä¹—åŠ¹æœ
                'Necronomicon Fragment': 1200000, // è¶…å¾ŒæœŸã®å¼·åŒ–
                'Psychic Attunement': 2500000,    // ç‰¹æ®Šãªå¼·åŒ–åŠ¹æœ
                'Quantum Entanglement': 6000000,  // æœ€çµ‚æ®µéšã®å¼·åŒ–
                'Temporal Manipulation': 8000000, // ç©¶æ¥µã®æ™‚é–“æ“ä½œ
                'Eldritch Evolution': 30000000
            };

            const monsterEfficiencies = {
                'Shoggoth': {
                    sourceEfficiency: 0.5,
                    miasmaEfficiency: 0.1
                },
                'This Man': {
                    sourceEfficiency: 2.0,
                    miasmaEfficiency: 0.4
                },
                'Deep One': {
                    sourceEfficiency: 5.0,
                    miasmaEfficiency: 1.0
                },
                'Byakhee': {
                    sourceEfficiency: 12.0,
                    miasmaEfficiency: 2.4
                },
                'Elder Thing': {
                    sourceEfficiency: 30.0,
                    miasmaEfficiency: 6.0
                },
                'Mossman': {
                    sourceEfficiency: 75.0,
                    miasmaEfficiency: 15.0
                },
                'Star Spawn': {
                    sourceEfficiency: 200.0,
                    miasmaEfficiency: 40.0
                },
                'Mi-go': {
                    sourceEfficiency: 500.0,
                    miasmaEfficiency: 100.0
                },
                'Nightgaunt': {
                    sourceEfficiency: 1250.0,
                    miasmaEfficiency: 250.0
                },
                'Uroboros': {
                    sourceEfficiency: 3000.0,
                    miasmaEfficiency: 600.0
                }
            };

            // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®é †åºé…åˆ—ã‚‚æ›´æ–°
            const upgradeOrder = [
                'Ritual Knowledge',
                'Eldritch Tome',
                'Hiroshi Sakamoto`s Paper',
                'Cosmic Alignment',
                'Forbidden Ritual',
                'Hermetic Teachings',
                'Cosmic Insight',
                'Astral Projection',
                'Dimensional Rift',
                'Necronomicon Fragment',
                'Psychic Attunement',
                'Quantum Entanglement',
                'Temporal Manipulation',
                'Eldritch Evolution'
            ];

            const upgradeEffects = {
                'Ritual Knowledge': 'Increases follower efficiency by 25%',
                'Eldritch Tome': 'Increases all monster efficiencies by 25%',
                'Hiroshi Sakamoto`s Paper': 'Unlocks the ability to use Cultos Miner',
                'Cosmic Alignment': 'Improves overall production by 10% when followers and monsters are balanced',
                'Forbidden Ritual': 'Increases source production by 40%',
                'Hermetic Teachings': 'Increases follower efficiency by 30%',
                'Cosmic Insight': 'Increases follower and monster efficiencies by 35%',
                'Astral Projection': 'Adds 3% of your total source to production every second',
                'Necronomicon Fragment': 'Boosts monster production by 50%',
                'Psychic Attunement': 'Increases miasma production by 30%',
                'Quantum Entanglement': 'Each monster type boosts the efficiency of another by 5%',
                'Temporal Manipulation': 'Speeds up resource generation by 20%',
                'Eldritch Evolution': 'Monsters gain 1% efficiency for every 10 levels',
                'Dimensional Rift': 'Increases the effect of all other upgrades by 50%'
            };

            const upgradeSymbols = {
                'Ritual Knowledge': 'ğŸ“š',
                'Eldritch Tome': 'ğŸ“œ',
                'Hiroshi Sakamoto`s Paper': 'ğŸ“„',
                'Cosmic Alignment': 'ğŸŒŒ',
                'Forbidden Ritual': 'ğŸ”®',
                'Hermetic Teachings': 'ğŸŒ¿',
                'Cosmic Insight': 'ğŸ‘ï¸',
                'Astral Projection': 'ğŸª',
                'Necronomicon Fragment': 'ğŸ“–',
                'Psychic Attunement': 'ğŸ§ ',
                'Quantum Entanglement': 'ğŸ”—',
                'Temporal Manipulation': 'â³',
                'Eldritch Evolution': 'ğŸ§¬',
                'Dimensional Rift': 'ğŸ•³ï¸'
            };

            const PACTS = {
                1: {
                    name: "The Awakening Pact",
                    condition: { source: 1e6 },
                    description: "The time of your awakening has come. Through this contract, you shall gain new powers, but at the cost of your current progress.",
                    flavorText: "As you sign the contract, ancient symbols begin to glow with an ethereal light...",
                    effects: [
                        {
                            type: "sealManualRecruits",
                            description: "Manual recruitment is sealed, granting access to automatic powers"
                        },
                        {
                            type: "minimumFollowers",
                            value: 1,
                            description: "Maintain a minimum of 1 followers"
                        },
                        {
                            type: "followerEfficiency",
                            value: 0.25,
                            description: "Follower efficiency increased by 25%"
                        },
                        {
                            type: "globalMultiplier",
                            value: 0.25,
                            description: "All resource gains increased by 25%"
                        },
                        {
                            type: "tickSpeed",
                            value: 0.25,
                            description: "Time flows 25% faster"
                        }
                    ],
                    warning: "* Accepting this contract will halt current progress and reset everything except permanent effects",
                    followerAsciiArt: `
<span style="color:#4B0082">      â–„â–„â–ˆâ–€â–€â–ˆâ–„â–„      </span>
<span style="color:#4B0082">    â–„â–ˆâ–€</span><span style="color:#6A0DAD">â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#4B0082">â–€â–ˆâ–„    </span>
<span style="color:#4B0082">   â–ˆâ–€â–‘</span><span style="color:#8A2BE2">â–„â–„â–ˆâ–ˆâ–ˆâ–„â–„</span><span style="color:#4B0082">â–‘â–€â–ˆ   </span>
<span style="color:#4B0082">  â–ˆâ–‘</span><span style="color:#8A2BE2">â–ˆ</span><span style="color:#4B0082">â–’</span><span style="color:#9400D3">â—ˆâ—ˆâ—ˆâ—ˆ</span><span style="color:#4B0082">â–’</span><span style="color:#8A2BE2">â–ˆ</span><span style="color:#4B0082">â–‘â–ˆ  </span>
<span style="color:#4B0082"> â–ˆâ–‘</span><span style="color:#8A2BE2">â–ˆâ–€â–„</span><span style="color:#4B0082">â–’</span><span style="color:#9400D3">â–‘â–‘â–‘</span><span style="color:#4B0082">â–’</span><span style="color:#8A2BE2">â–„â–€â–ˆ</span><span style="color:#4B0082">â–‘â–ˆ </span>
<span style="color:#4B0082">â–ˆâ–‘</span><span style="color:#8A2BE2">â–„â–ˆâ–€â–‘</span><span style="color:#4B0082">â–’</span><span style="color:#9400D3">âˆ´âˆ´âˆ´</span><span style="color:#4B0082">â–’</span><span style="color:#8A2BE2">â–‘â–€â–ˆâ–„</span><span style="color:#4B0082">â–‘â–ˆ</span>
<span style="color:#4B0082">â–ˆâ–‘</span><span style="color:#9932CC">â–ˆâ–„â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„â–„â–ˆ</span><span style="color:#4B0082">â–‘â–ˆ</span>
<span style="color:#4B0082">â–ˆâ–‘</span><span style="color:#9932CC">â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</span><span style="color:#4B0082">â–‘â–ˆ</span>
<span style="color:#4B0082">â–ˆâ–‘</span><span style="color:#BA55D3">â–ˆâ–ˆâ–ˆ</span><span style="color:#DDA0DD">â–’â–’â–’â–’â–’</span><span style="color:#BA55D3">â–ˆâ–ˆâ–ˆ</span><span style="color:#4B0082">â–‘â–ˆ</span>
<span style="color:#4B0082">â–ˆâ–‘â–‘</span><span style="color:#BA55D3">â–ˆâ–ˆ</span><span style="color:#DDA0DD">â–’</span><span style="color:#FF1493">âœ§</span><span style="color:#DDA0DD">â–’</span><span style="color:#FF1493">âœ§</span><span style="color:#DDA0DD">â–’</span><span style="color:#BA55D3">â–ˆâ–ˆ</span><span style="color:#4B0082">â–‘â–‘â–ˆ</span>
<span style="color:#4B0082">â–ˆâ–„â–‘â–‘</span><span style="color:#BA55D3">â–ˆ</span><span style="color:#DDA0DD">â–’â–’â–’â–’â–’â–’â–’</span><span style="color:#BA55D3">â–ˆ</span><span style="color:#4B0082">â–‘â–‘â–„â–ˆ</span>
<span style="color:#4B0082"> â–ˆâ–€â–„â–„â–‘</span><span style="color:#DDA0DD">â–’â–’â–’â–’â–’</span><span style="color:#4B0082">â–‘â–„â–„â–€â–ˆ </span>
<span style="color:#4B0082"> â–€â–ˆâ–‘â–‘â–€</span><span style="color:#DDA0DD">â–’â–’â–’â–’â–’</span><span style="color:#4B0082">â–€â–‘â–‘â–ˆâ–€ </span>
<span style="color:#4B0082">  â–€â–ˆâ–„â–‘â–‘</span><span style="color:#DDA0DD">â–’â–’â–’</span><span style="color:#4B0082">â–‘â–‘â–„â–ˆâ–€  </span>
<span style="color:#4B0082">    â–€â–€â–ˆâ–„â–„â–„â–ˆâ–€â–€    </span>
    `,
                    tooltipText: "Awakened Follower - Bound by the First Contract"
                },
                2: {
                    name: "The Void Pact",
                    condition: {
                        source: 1e28 // 1000å…†ã®source
                    },
                    description: "A contract with the void itself. The darkness beckons, offering greater power at a steeper cost.",
                    flavorText: "As you sign the contract, shadows seem to dance at the edges of your vision...",
                    effects: [
                        {
                            type: "minimumFollowers",
                            value: 3,
                            description: "Maintain a minimum of 3 followers"
                        },
                        {
                            type: "followerEfficiency",
                            value: 0.5,
                            description: "Follower efficiency increased by 50%"
                        },
                        {
                            type: "globalMultiplier",
                            value: 0.5,
                            description: "All resource gains increased by 50%"
                        },
                        {
                            type: "tickSpeed",
                            value: 0.5,
                            description: "Time flows 50% faster"
                        }
                    ],
                    warning: "* Accepting this contract will reset your current progress but maintain permanent effects",
                    followerAsciiArt: `
<span style="color:#0a000a">       â–„âˆ¿â–ˆâ–€â–€â–ˆâˆ¿â–„       </span>
<span style="color:#0a000a">     â–„â–ˆâ–€</span><span style="color:#1a001a">â–‘â—  â—â–‘</span><span style="color:#0a000a">â–€â–ˆâ–„     </span>
<span style="color:#0a000a">   â–„â–ˆâ–€â–‘</span><span style="color:#2a002a">â–„â–‘â–ˆâ–ˆâ–ˆâ–‘â–„</span><span style="color:#0a000a">â–‘â–€â–ˆâ–„   </span>
<span style="color:#0a000a">  â–ˆâ–€â–‘</span><span style="color:#2a002a">â–ˆâ–€</span><span style="color:#0a000a">â–’</span><span style="color:#4d004d">â—ˆâ—†â—†â—ˆ</span><span style="color:#0a000a">â–’</span><span style="color:#2a002a">â–€â–ˆ</span><span style="color:#0a000a">â–‘â–€â–ˆ  </span>
<span style="color:#0a000a"> â–ˆâˆ¿</span><span style="color:#2a002a">â–ˆâ–€â–‘â–„</span><span style="color:#0a000a">â–’</span><span style="color:#4d004d">âˆµâˆ´âˆµ</span><span style="color:#0a000a">â–’</span><span style="color:#2a002a">â–„â–‘â–€â–ˆ</span><span style="color:#0a000a">âˆ¿â–ˆ </span>
<span style="color:#0a000a">â–ˆâˆ¿</span><span style="color:#2a002a">â–„â–ˆâ–€â–‘</span><span style="color:#0a000a">â–’</span><span style="color:#4d004d">âˆ·âˆâˆ·</span><span style="color:#0a000a">â–’</span><span style="color:#2a002a">â–‘â–€â–ˆâ–„</span><span style="color:#0a000a">âˆ¿â–ˆ</span>
<span style="color:#0a000a">â–ˆâ–‘</span><span style="color:#400040">â–ˆâˆ¿â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„âˆ¿â–ˆ</span><span style="color:#0a000a">â–‘â–ˆ</span>
<span style="color:#0a000a">â–ˆâˆ¿</span><span style="color:#400040">â–ˆâ–ˆâˆ¿â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâˆ¿â–ˆâ–ˆ</span><span style="color:#0a000a">âˆ¿â–ˆ</span>
<span style="color:#0a000a">â–ˆâ–„</span><span style="color:#600060">â–ˆâ–ˆâ–€</span><span style="color:#800080">â–’â–“â–’â–“â–’</span><span style="color:#600060">â–€â–ˆâ–ˆ</span><span style="color:#0a000a">â–„â–ˆ</span>
<span style="color:#0a000a">â–ˆâ–‘âˆ¿</span><span style="color:#600060">â–ˆâ–ˆ</span><span style="color:#800080">â–’</span><span style="color:#cc00cc">âœ§</span><span style="color:#800080">â–’</span><span style="color:#cc00cc">âœ§</span><span style="color:#800080">â–’</span><span style="color:#600060">â–ˆâ–ˆ</span><span style="color:#0a000a">âˆ¿â–‘â–ˆ</span>
<span style="color:#0a000a">â–ˆâ–„âˆ¿â–‘</span><span style="color:#600060">â–ˆ</span><span style="color:#800080">â–“â–’âˆ¿â–’âˆ¿â–“</span><span style="color:#600060">â–ˆ</span><span style="color:#0a000a">â–‘âˆ¿â–„â–ˆ</span>
<span style="color:#0a000a"> â–ˆâ–€â–„âˆ¿â–‘</span><span style="color:#800080">â–“â–’âˆ¿â–’â–“</span><span style="color:#0a000a">â–‘âˆ¿â–„â–€â–ˆ </span>
<span style="color:#0a000a"> â–€â–ˆâ–‘âˆ¿â–€</span><span style="color:#800080">â–’â–“âˆ¿â–“â–’</span><span style="color:#0a000a">â–€âˆ¿â–‘â–ˆâ–€ </span>
<span style="color:#0a000a">  â–€â–ˆâ–„âˆ¿â–‘</span><span style="color:#800080">â–’â–“â–’</span><span style="color:#0a000a">â–‘âˆ¿â–„â–ˆâ–€  </span>
<span style="color:#0a000a">    â–€â–€â–ˆâˆ¿âˆ¿âˆ¿â–ˆâ–€â–€    </span>`,

                    tooltipText: `Void Touched Follower - Transformed by the Second Contract`,
                }
            };

            const unlockConditions = {
                monsters: {
                    'Shoggoth': { // æœ€åˆã‹ã‚‰è§£æ”¾
                        isUnlocked: true
                    },
                    'This Man': {
                        requirement: {
                            monsters: { 'Shoggoth': 5 },
                        },
                        description: "Requires 5 Shoggoths"
                    },
                    'Deep One': {
                        requirement: {
                            monsters: { 'This Man': 4, 'Shoggoth': 8 },
                        },
                        description: "Requires 4 This Man, 8 Shoggoths"
                    },
                    'Byakhee': {
                        requirement: {
                            monsters: { 'Deep One': 4, 'This Man': 6 },
                        },
                        description: "Requires 4 Deep Ones, 6 This Man"
                    },
                    'Elder Thing': {
                        requirement: {
                            monsters: { 'Byakhee': 3, 'Deep One': 8 },
                            upgrades: ['Forbidden Ritual']
                        },
                        description: "Requires 3 Byakhee, 8 Deep Ones and Forbidden Ritual upgrade"
                    },
                    'Mossman': {
                        requirement: {
                            monsters: { 'Elder Thing': 3, 'Byakhee': 6, 'Deep One': 10 },
                            upgrades: ['Hermetic Teachings']
                        },
                        description: "Requires 3 Elder Things, 6 Byakhee, 10 Deep Ones and Hermetic Teachings upgrade"
                    },
                    'Star Spawn': {
                        requirement: {
                            monsters: { 'Mossman': 3, 'Elder Thing': 5 },
                            upgrades: ['Cosmic Insight']
                        },
                        description: "Requires 3 Mossman, 5 Elder Things and Cosmic Insight upgrade"
                    },
                    'Mi-go': {
                        requirement: {
                            monsters: { 'Star Spawn': 2, 'Mossman': 4, 'Elder Thing': 8 },
                            upgrades: ['Astral Projection']
                        },
                        description: "Requires 2 Star Spawns, 4 Mossman, 8 Elder Things and Astral Projection upgrade"
                    },
                    'Nightgaunt': {
                        requirement: {
                            monsters: { 'Mi-go': 2, 'Star Spawn': 4, 'Mossman': 6 },
                            upgrades: ['Forbidden Ritual', 'Dimensional Rift']
                        },
                        description: "Requires 2 Mi-go, 4 Star Spawns, 6 Mossman, Forbidden Ritual and Dimensional Rift upgrades"
                    },
                    'Uroboros': {
                        requirement: {
                            monsters: { 'Nightgaunt': 2, 'Mi-go': 4, 'Star Spawn': 6 },
                            upgrades: ['Dimensional Rift', 'Necronomicon Fragment']
                        },
                        description: "Requires 2 Nightgaunts, 4 Mi-go, 6 Star Spawns, Dimensional Rift and Necronomicon Fragment upgrades"
                    }
                },

                adventurers: {
                    'Novice Explorer': { // æœ€åˆã‹ã‚‰è§£æ”¾
                        isUnlocked: true
                    },
                    'Seasoned Investigator': {
                        requirement: {
                            adventurers: {
                                'Novice Explorer': { level: 3 }  // Novice ExplorerãŒãƒ¬ãƒ™ãƒ«3å¿…è¦
                            }
                        },
                        description: "Requires Level 3 Novice Explorer"
                    },
                    'Arcane Scholar': {
                        requirement: {
                            adventurers: {
                                'Seasoned Investigator': { level: 3 }
                            },
                            monsters: { 'Deep One': 2 }
                        },
                        description: "Requires Level 3 Seasoned Investigator and 2 Deep Ones"
                    },
                    'Occult Detective': {
                        requirement: {
                            adventurers: {
                                'Arcane Scholar': { level: 2 }
                            },
                            monsters: { 'Elder Thing': 1 },
                            upgrades: ['Forbidden Ritual']
                        },
                        description: "Requires Level 2 Arcane Scholar, 1 Elder Thing and Forbidden Ritual upgrade"
                    },
                    'Eldritch Archaeologist': {
                        requirement: {
                            adventurers: {
                                'Occult Detective': { level: 2 }
                            },
                            monsters: {
                                'Star Spawn': 1,
                                'Mi-go': 1
                            }
                        },
                        description: "Requires Level 2 Occult Detective, 1 Star Spawn and 1 Mi-go"
                    },
                    'Cosmic Voyager': {
                        requirement: {
                            adventurers: {
                                'Eldritch Archaeologist': { level: 2 }
                            },
                            monsters: {
                                'Nightgaunt': 1
                            },
                            upgrades: ['Cosmic Insight', 'Astral Projection']
                        },
                        description: "Requires Level 2 Eldritch Archaeologist, 1 Nightgaunt, Cosmic Insight and Astral Projection upgrades"
                    }
                },

                upgrades: {
                    'Ritual Knowledge': {
                        isUnlocked: true,
                        requirement: null,
                        description: 'Always available'
                    },

                    'Eldritch Tome': {
                        requirement: {
                            monsters: { 'Shoggoth': 3 }
                        },
                        description: 'Requires 3 Shoggoths'
                    },

                    'Hiroshi Sakamoto`s Paper': {
                        requirement: {
                            monsters: { 'Shoggoth': 10, 'This Man': 5 }
                        },
                        description: 'Requires 10 Shoggoths and 5 This Man'
                    },

                    'Cosmic Alignment': {
                        requirement: {
                            monsters: { 'Shoggoth': 15, 'This Man': 8 }
                        },
                        description: 'Requires 15 Shoggoths and 8 This Man'
                    },

                    'Forbidden Ritual': {
                        requirement: {
                            monsters: { 'Deep One': 3, 'This Man': 10 },
                            upgrades: ['Cosmic Alignment']
                        },
                        description: 'Requires 3 Deep Ones, 10 This Man and Cosmic Alignment upgrade'
                    },

                    'Hermetic Teachings': {
                        requirement: {
                            monsters: { 'Deep One': 6, 'Byakhee': 3 },
                            upgrades: ['Forbidden Ritual']
                        },
                        description: 'Requires 6 Deep Ones, 3 Byakhee and Forbidden Ritual upgrade'
                    },

                    'Cosmic Insight': {
                        requirement: {
                            monsters: { 'Elder Thing': 2, 'Byakhee': 5 },
                            upgrades: ['Hermetic Teachings']
                        },
                        description: 'Requires 2 Elder Things, 5 Byakhee and Hermetic Teachings upgrade'
                    },

                    'Astral Projection': {
                        requirement: {
                            monsters: { 'Elder Thing': 3, 'Mossman': 2 },
                            upgrades: ['Cosmic Insight'],
                        },
                        description: 'Requires 3 Elder Things, 2 Mossman, Cosmic Insight upgrade'
                    },

                    'Dimensional Rift': {
                        requirement: {
                            monsters: { 'Star Spawn': 1, 'Mossman': 4 },
                            upgrades: ['Astral Projection'],
                        },
                        description: 'Requires 1 Star Spawn, 4 Mossman, Astral Projection upgrade'
                    },

                    'Necronomicon Fragment': {
                        requirement: {
                            monsters: { 'Mi-go': 1, 'Star Spawn': 2 },
                            upgrades: ['Dimensional Rift'],
                        },
                        description: 'Requires 1 Mi-go, 2 Star Spawn, Dimensional Rift upgrade'
                    },

                    'Psychic Attunement': {
                        requirement: {
                            monsters: { 'Nightgaunt': 1, 'Mi-go': 2 },
                            upgrades: ['Necronomicon Fragment'],
                        },
                        description: 'Requires 1 Nightgaunt, 2 Mi-go, Necronomicon Fragment upgrade'
                    },

                    'Quantum Entanglement': {
                        requirement: {
                            monsters: { 'Uroboros': 1, 'Nightgaunt': 2 },
                            upgrades: ['Psychic Attunement'],
                        },
                        description: 'Requires 1 Uroboros, 2 Nightgaunts, Psychic Attunement upgrade'
                    },

                    'Temporal Manipulation': {
                        requirement: {
                            monsters: { 'Uroboros': 2 },
                            upgrades: ['Quantum Entanglement'],
                            monsterTypes: 8 // 8ç¨®é¡ä»¥ä¸Šã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’æ‰€æŒ
                        },
                        description: 'Requires 2 Uroboros, 8 different monster types and Quantum Entanglement upgrade'
                    },

                    'Eldritch Evolution': {
                        requirement: {
                            monsters: { 'Uroboros': 3 },
                            upgrades: ['Temporal Manipulation'],
                            monsterTypes: 10, // ã™ã¹ã¦ã®ç¨®é¡ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼
                            monsterLevel: 10 // ã„ãšã‚Œã‹ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒãƒ¬ãƒ™ãƒ«10ä»¥ä¸Š
                        },
                        description: 'Requires 3 Uroboros, Level 8 Cosmic Voyager, all monster types and any monster at level 10'
                    }
                },
                resources: {
                    'cultos': {
                        requirement: {
                            upgrades: ['Hiroshi Sakamoto`s Paper'],
                            monsters: {
                                'Shoggoth': 10,
                                'This Man': 5
                            }
                        },
                        description: "Requires Hiroshi Sakamoto's Paper upgrade, 10 Shoggoths and 5 This Man"
                    }
                }
            };

            const config = {
                cardPrefix: 'card-',
                conditions: {
                    monsters: unlockConditions.monsters,
                    adventurers: unlockConditions.adventurers,
                    upgrades: unlockConditions.upgrades
                }
            };

            const upgradeDefinitions = {
                'Ritual Knowledge': {
                    cost: 150,
                    type: 'sourceEfficiency',
                    effect: 0.1,
                    description: 'Basic ritual knowledge increases source production'
                },
                'Eldritch Tome': {
                    cost: 500,
                    type: 'miasmaEfficiency',
                    effect: 0.2,
                    description: 'Ancient tome increases miasma production'
                },
                'Hiroshi Sakamoto`s Paper': {
                    cost: 2000,
                    type: 'cultosMining',
                    effect: 1,
                    description: 'A mysterious paper describing the principles of Cultos mining'
                },

                'Cosmic Alignment': {
                    cost: 3000,
                    type: 'cosmicAlignment',
                    effect: 0.5,
                    description: 'Align with cosmic forces for enhanced production'
                },
                'Forbidden Ritual': {
                    cost: 8000,
                    type: 'followerEfficiency',
                    effect: 0.3,
                    description: 'Increase follower efficiency through dark rituals'
                },
                'Hermetic Teachings': {
                    cost: 35000,
                    type: 'monsterEfficiency',
                    effect: 0.25,
                    description: 'Ancient hermetic wisdom enhances monster efficiency'
                },
                'Cosmic Insight': {
                    cost: 80000,
                    type: 'productionMultiplier',
                    effect: 0.4,
                    description: 'Gain deeper understanding of cosmic forces'
                },
                'Astral Projection': {
                    cost: 300000,
                    type: 'astralProjection',
                    effect: 0.01,
                    description: 'Project into astral plane for bonus source'
                },
                'Dimensional Rift': {
                    cost: 500000,
                    type: 'dimensionalRift',
                    effect: 0.75,
                    description: 'Open rifts to other dimensions for massive bonuses'
                },
                'Necronomicon Fragment': {
                    cost: 1200000,
                    type: 'madnessResistance',
                    effect: 0.2,
                    description: 'Reduce madness chance for all entities'
                },
                'Psychic Attunement': {
                    cost: 3000000,
                    type: 'followerGain',
                    effect: 0.3,
                    description: 'Increase follower gain from all sources'
                },
                'Quantum Entanglement': {
                    cost: 6000000,
                    type: 'quantumEntanglement',
                    effect: 0.5,
                    description: 'Link monsters for enhanced efficiency'
                },
                'Temporal Manipulation': {
                    cost: 8000000,
                    type: 'temporalManipulation',
                    effect: 2.0,
                    description: 'Bend time to multiply all production'
                },
                'Eldritch Evolution': {
                    cost: 30000000,
                    type: 'eldritchEvolution',
                    effect: 0.01,
                    description: 'Monsters slowly gain efficiency over time'
                }
            };

            const asciiArt = {
                'Follower': `
<span style="color:#2E1A47">      â–„â–„â–ˆâ–€â–€â–ˆâ–„â–„      </span>
<span style="color:#2E1A47">    â–„â–ˆâ–€</span><span style="color:#3D2A56">â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#2E1A47">â–€â–ˆâ–„    </span>
<span style="color:#2E1A47">   â–ˆâ–€â–‘</span><span style="color:#4B0082">â–„â–„â–ˆâ–ˆâ–ˆâ–„â–„</span><span style="color:#2E1A47">â–‘â–€â–ˆ   </span>
<span style="color:#2E1A47">  â–ˆâ–‘</span><span style="color:#4B0082">â–ˆ</span><span style="color:#2E1A47">â–’</span><span style="color:#1E1E1E">â–‘â–‘â–‘â–‘</span><span style="color:#2E1A47">â–’</span><span style="color:#4B0082">â–ˆ</span><span style="color:#2E1A47">â–‘â–ˆ  </span>
<span style="color:#2E1A47"> â–ˆâ–‘</span><span style="color:#4B0082">â–ˆâ–€â–„</span><span style="color:#2E1A47">â–’</span><span style="color:#1E1E1E">â–‘â–‘â–‘</span><span style="color:#2E1A47">â–’</span><span style="color:#4B0082">â–„â–€â–ˆ</span><span style="color:#2E1A47">â–‘â–ˆ </span>
<span style="color:#2E1A47">â–ˆâ–‘</span><span style="color:#4B0082">â–„â–ˆâ–€â–‘</span><span style="color:#2E1A47">â–’</span><span style="color:#1E1E1E">â–‘â–‘â–‘</span><span style="color:#2E1A47">â–’</span><span style="color:#4B0082">â–‘â–€â–ˆâ–„</span><span style="color:#2E1A47">â–‘â–ˆ</span>
<span style="color:#2E1A47">â–ˆâ–‘</span><span style="color:#4B0082">â–ˆâ–„â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„â–„â–ˆ</span><span style="color:#2E1A47">â–‘â–ˆ</span>
<span style="color:#2E1A47">â–ˆâ–‘</span><span style="color:#4B0082">â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</span><span style="color:#2E1A47">â–‘â–ˆ</span>
<span style="color:#2E1A47">â–ˆâ–‘</span><span style="color:#6A0DAD">â–ˆâ–ˆâ–ˆ</span><span style="color:#D2691E">â–’â–’â–’â–’â–’</span><span style="color:#6A0DAD">â–ˆâ–ˆâ–ˆ</span><span style="color:#2E1A47">â–‘â–ˆ</span>
<span style="color:#2E1A47">â–ˆâ–‘â–‘</span><span style="color:#6A0DAD">â–ˆâ–ˆ</span><span style="color:#D2691E">â–’</span><span style="color:#FF1493">(@)</span><span style="color:#D2691E">â–’</span><span style="color:#FF1493">(@)</span><span style="color:#D2691E">â–’</span><span style="color:#6A0DAD">â–ˆâ–ˆ</span><span style="color:#2E1A47">â–‘â–‘â–ˆ</span>
<span style="color:#2E1A47">â–ˆâ–„â–‘â–‘</span><span style="color:#6A0DAD">â–ˆ</span><span style="color:#D2691E">â–’â–’â–’â–’â–’â–’â–’</span><span style="color:#6A0DAD">â–ˆ</span><span style="color:#2E1A47">â–‘â–‘â–„â–ˆ</span>
<span style="color:#2E1A47"> â–ˆâ–€â–„â–„â–‘</span><span style="color:#D2691E">â–’â–’â–’â–’â–’</span><span style="color:#2E1A47">â–‘â–„â–„â–€â–ˆ </span>
<span style="color:#2E1A47"> â–€â–ˆâ–‘â–‘â–€</span><span style="color:#D2691E">â–’â–’â–’â–’â–’</span><span style="color:#2E1A47">â–€â–‘â–‘â–ˆâ–€ </span>
<span style="color:#2E1A47">  â–€â–ˆâ–„â–‘â–‘</span><span style="color:#D2691E">â–’â–’â–’</span><span style="color:#2E1A47">â–‘â–‘â–„â–ˆâ–€  </span>
<span style="color:#2E1A47">    â–€â–€â–ˆâ–„â–„â–„â–ˆâ–€â–€    </span>
    `,
                'Shoggoth': `
<span style="color:#004000">â–„â–„â–„â”€â”€â”€â”€â”€â”€â–„â–„â–„</span>
    <span style="color:#004000">â–„â–ˆâ–ˆâ–€â–‘</span><span style="color:#006000">â–’â–’â–’</span><span style="color:#004000">â–‘â–‘â–‘</span><span style="color:#006000">â–’â–’â–’</span><span style="color:#004000">â–‘â–€â–ˆâ–ˆâ–„</span>
  <span style="color:#004000">â–ˆâ–ˆâ–€â–‘</span><span style="color:#006000">â–’</span><span style="color:#008000">â–„â–„</span><span style="color:#006000">â–’â–’â–’â–’â–’â–’â–’â–’</span><span style="color:#008000">â–„â–„</span><span style="color:#006000">â–’</span><span style="color:#004000">â–‘â–€â–ˆâ–ˆ</span>
 <span style="color:#004000">â–ˆâ–€â–‘</span><span style="color:#006000">â–’</span><span style="color:#00A000">â–„â–ˆâ–€â–€â–ˆ <span style="color:#FF0000"> + </span>  â–ˆâ–€â–€â–ˆâ–„</span><span style="color:#006000">â–’</span><span style="color:#004000">â–‘â–€â–ˆ</span>
<span style="color:#004000">â–ˆâ–€â–‘</span><span style="color:#006000">â–’</span><span style="color:#00C000">â–„â–ˆâ–€</span><span style="color:#FF0000"> + </span><span style="color:#00C000">â–‘â–‘</span><span style="color:#FF0000"> + </span><span style="color:#00C000">â–€â–ˆâ–„</span><span style="color:#006000">â–’</span><span style="color:#004000">â–‘â–€â–ˆ</span>
<span style="color:#004000">â–ˆâ–‘</span><span style="color:#006000">â–’</span><span style="color:#00E000">â–ˆâ–€</span><span style="color:#FF0000"> + </span><span style="color:#00E000">â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#FF0000"> Ã· </span><span style="color:#00E000">â–€â–ˆ</span><span style="color:#006000">â–’</span><span style="color:#004000">â–‘â–ˆ</span>
<span style="color:#004000">â–ˆâ–‘</span><span style="color:#006000">â–’</span><span style="color:#00FF00">â–ˆâ–‘â–„â–€â–€</span><span style="color:#FF0000">\\--/</span><span style="color:#00FF00">â–€â–€â–„â–‘â–‘â–ˆ</span><span style="color:#006000">â–’</span><span style="color:#004000">â–‘â–ˆ</span>
<span style="color:#004000">â–ˆâ–‘</span><span style="color:#006000">â–’</span><span style="color:#00E000">â–ˆâ–‘â–ˆâ–‘â–‘</span><span style="color:#FF0000">_\\/_</span><span style="color:#00E000">â–‘â–‘â–ˆâ–‘â–ˆ</span><span style="color:#006000">â–’</span><span style="color:#004000">â–‘â–ˆ</span>
<span style="color:#004000">â–ˆâ–‘</span><span style="color:#006000">â–’</span><span style="color:#00C000">â–€â–ˆâ–„â–€</span><span style="color:#FF0000">/,\\,\\</span><span style="color:#00C000">â–€â–„â–ˆâ–€</span><span style="color:#006000">â–’</span><span style="color:#004000">â–‘â–ˆ</span>
<span style="color:#004000">â–ˆâ–„â–‘</span><span style="color:#006000">â–’â–’</span><span style="color:#00A000">â–€â–„</span><span style="color:#FF0000">'-'</span><span style="color:#00A000">â–„â–€</span><span style="color:#006000">â–’â–’</span><span style="color:#004000">â–‘â–„â–ˆ</span>
 <span style="color:#004000">â–ˆâ–ˆâ–„â–‘â–‘</span><span style="color:#006000">â–’â–’â–’â–’â–’â–’</span><span style="color:#004000">â–‘â–‘â–„â–ˆâ–ˆ</span>
  <span style="color:#004000">â–€â–ˆâ–ˆâ–„â–„â–‘â–‘â–‘â–‘â–‘â–‘â–„â–„â–ˆâ–ˆâ–€</span>
    <span style="color:#004000">â–€â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€â–€</span>
  <span style="color:#004000">â–„â–ˆâ–€</span><span style="color:#006000">â–’</span><span style="color:#00A000">â–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–ˆ</span><span style="color:#006000">â–’</span><span style="color:#004000">â–€â–ˆâ–„</span>
 <span style="color:#004000">â–ˆâ–€</span><span style="color:#006000">â–’</span><span style="color:#00C000">â–ˆâ–’â–ˆâ–’â–’â–’â–’â–’â–’â–ˆâ–’â–ˆ</span><span style="color:#006000">â–’</span><span style="color:#004000">â–€â–ˆ</span>
<span style="color:#004000">â–ˆ</span><span style="color:#00FF00">â–„â–ˆâ–’â–ˆâ–’â–ˆâ–’â–ˆâ–’â–ˆâ–’â–ˆâ–’â–ˆâ–’â–ˆâ–„</span><span style="color:#004000">â–ˆ</span>
<span style="color:#004000">â–€â–ˆâ–„</span><span style="color:#00E000">â–ˆâ–’â–ˆâ–’â–’â–ˆâ–’â–ˆâ–’â–’â–ˆâ–’â–ˆ</span><span style="color:#004000">â–„â–ˆâ–€</span>
    `,

                'This Man': `
<span style="color:#FFFFFF">       â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„       </span>
<span style="color:#FFFFFF">     â–„â–ˆâ–€</span><span style="color:#F0F0F0">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#FFFFFF">â–€â–ˆâ–„     </span>
<span style="color:#FFFFFF">   â–„â–ˆâ–€   </span><span style="color:#E0E0E0">â–„â–„â–„â–„     â–„â–„â–„â–„</span><span style="color:#FFFFFF">   â–€â–ˆâ–„   </span>
<span style="color:#FFFFFF">  â–ˆâ–€  </span><span style="color:#D0D0D0">â–„â–ˆâ–€â–€â–€â–€â–€â–ˆ   â–ˆâ–€â–€â–€â–€â–€â–ˆâ–„</span><span style="color:#FFFFFF">  â–€â–ˆ  </span>
<span style="color:#FFFFFF"> â–ˆâ–€  </span><span style="color:#C0C0C0">â–ˆâ–€       â–€ â–€       â–€â–ˆ</span><span style="color:#FFFFFF">  â–€â–ˆ </span>
<span style="color:#FFFFFF">â–ˆâ–€ </span><span style="color:#B0B0B0">â–„â–€                     â–€â–„</span><span style="color:#FFFFFF"> â–€â–ˆ</span>
<span style="color:#FFFFFF">â–ˆ  </span><span style="color:#A0A0A0">  â–â–â–“â–“â–Œâ–        â–â–â–“â–“â–Œâ–   </span><span style="color:#FFFFFF"> â–ˆ</span>
<span style="color:#FFFFFF">â–ˆ  </span><span style="color:#909090">   â–â–“â–“â–Œ          â–â–“â–“â–Œ    </span><span style="color:#FFFFFF">â–ˆ</span>
<span style="color:#FFFFFF">â–ˆ  </span><span style="color:#808080">    â–€â–€    â–â–“â–“â–Œ    â–€â–€     </span><span style="color:#FFFFFF">â–ˆ</span>
<span style="color:#FFFFFF">â–ˆ  </span><span style="color:#707070">          â–  â–Œ           </span><span style="color:#FFFFFF">â–ˆ</span>
<span style="color:#FFFFFF">â–ˆ  </span><span style="color:#606060">                          </span><span style="color:#FFFFFF">â–ˆ</span>
<span style="color:#FFFFFF">â–ˆâ–„ </span><span style="color:#505050">                        </span><span style="color:#FFFFFF">â–„â–ˆ</span>
<span style="color:#FFFFFF">â–€â–ˆ  </span><span style="color:#404040"> â–â–“â–“              â–“â–“â–Œ </span><span style="color:#FFFFFF"> â–ˆâ–€</span>
<span style="color:#FFFFFF"> â–€â–ˆ  </span><span style="color:#303030">  â–€â–“â–“â–“â–€â–€â–€â–€â–€â–€â–€â–€â–“â–“â–“â–€  </span><span style="color:#FFFFFF"> â–ˆâ–€ </span>
<span style="color:#FFFFFF">  â–€â–ˆâ–„ </span><span style="color:#202020">                  </span><span style="color:#FFFFFF">â–„â–ˆâ–€  </span>
<span style="color:#FFFFFF">    â–€â–ˆâ–„ </span><span style="color:#101010">              </span><span style="color:#FFFFFF">â–„â–ˆâ–€    </span>
<span style="color:#FFFFFF">      â–€â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€â–€      </span>
    `,
                'Deep One': `
<span style="color:#005959">        â–„â–„â–„â–„â–„â–„        </span>
<span style="color:#005959">      â–„â–ˆâ–€â–€â–€â–€â–€â–€â–ˆâ–„      </span>
<span style="color:#005959">    â–„â–ˆâ–€â–‘â–‘</span><span style="color:#008080">â–’â–’â–’â–’</span><span style="color:#005959">â–‘â–‘â–€â–ˆâ–„    </span>
<span style="color:#005959">  â–„â–ˆâ–€â–‘</span><span style="color:#008080">â–’â–’</span><span style="color:#00A0A0">â–„â–„â–„â–„â–„â–„</span><span style="color:#008080">â–’â–’</span><span style="color:#005959">â–‘â–€â–ˆâ–„  </span>
</span><span style="color:#008080">â–’</span><span style="color:#00A0A0">â–„</span><span style="color:#FF0000">(@@)</span><span style="color:#00A0A0">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#FF0000">(@@)</span><span style="color:#00A0A0">â–„</span><span style="color:#008080">â–’</span></span>
<span style="color:#005959">â–ˆâ–€â–‘</span><span style="color:#008080">â–’</span><span style="color:#00BFBF">â–ˆâ–€â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–€â–ˆ</span><span style="color:#008080">â–’</span><span style="color:#005959">â–‘â–€â–ˆ</span>
<span style="color:#005959">â–ˆâ–‘</span><span style="color:#008080">â–’</span><span style="color:#00DFDF">â–ˆâ–‘â–„â–€â–€â–€â–€â–€â–€â–„â–‘â–ˆ</span><span style="color:#008080">â–’</span><span style="color:#005959">â–‘â–ˆ</span>
<span style="color:#005959">â–ˆâ–‘</span><span style="color:#008080">â–’</span><span style="color:#00FFFF">â–ˆâ–‘â–ˆâ–‘</span><span style="color:#40E0D0">_\\/_</span><span style="color:#00FFFF">â–‘â–ˆâ–‘â–ˆ</span><span style="color:#008080">â–’</span><span style="color:#005959">â–‘â–ˆ</span>
<span style="color:#005959">â–ˆâ–‘</span><span style="color:#008080">â–’</span><span style="color:#00DFDF">â–€â–ˆâ–„â–€</span><span style="color:#40E0D0">/,\\,\\</span><span style="color:#00DFDF">â–€â–„â–ˆâ–€</span><span style="color:#008080">â–’</span><span style="color:#005959">â–‘â–ˆ</span>
<span style="color:#005959">â–ˆâ–„â–‘</span><span style="color:#008080">â–’â–’</span><span style="color:#00BFBF">â–€â–„</span><span style="color:#40E0D0">'-'</span><span style="color:#00BFBF">â–„â–€</span><span style="color:#008080">â–’â–’</span><span style="color:#005959">â–‘â–„â–ˆ</span>
<span style="color:#005959"> â–ˆâ–ˆâ–„â–‘â–‘</span><span style="color:#008080">â–’â–’â–’â–’â–’â–’</span><span style="color:#005959">â–‘â–‘â–„â–ˆâ–ˆ </span>
<span style="color:#005959">  â–€â–ˆâ–ˆâ–„â–„â–‘â–‘â–‘â–‘â–‘â–‘â–„â–„â–ˆâ–ˆâ–€  </span>
<span style="color:#005959">    â–€â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€â–€    </span>
<span style="color:#008080">  â–„â–ˆâ–€â–€â–„</span><span style="color:#00A0A0">â–“â–“â–“â–“â–“â–“â–“â–“</span><span style="color:#008080">â–„â–€â–€â–ˆâ–„  </span>
<span style="color:#008080"> â–ˆâ–€ </span><span style="color:#00BFBF">â–„â–“â–“â–“â–€â–€â–€â–€â–“â–“â–“â–„</span><span style="color:#008080"> â–€â–ˆ </span>
<span style="color:#008080">â–ˆ  </span><span style="color:#00DFDF">â–“â–“â–“â–€â–„â–„â–„â–„â–€â–“â–“â–“</span><span style="color:#008080">  â–ˆ</span>
    `,
                'Byakhee': `
<span style="color:#8B4513">               â–„â–ˆâ–€â–€â–‘â–‘â–‘â–‘â–€â–€â–ˆâ–„           </span>
<span style="color:#8B4513">           â–„â–ˆâ–€â–‘â–’â–’</span><span style="color:#FF0000">â—‰</span><span style="color:#8B4513">â–’â–’â–„â–„â–‘â–‘â–‘â–‘â–€â–ˆ         </span>
<span style="color:#8B4513">         â–„â–ˆâ–€â–‘â–’â–’â–’â–„â–ˆâ–€â–€â–ˆ â–’â–’â–‘â–‘â–€â–„   </span>
<span style="color:#8B4513">       â–„â–ˆâ–€â–‘â–’â–’â–’â–„â–ˆâ–€â–‘â–‘â–‘â–„ â–‘â–‘â–‘â–‘â–‘ â–„   </span>
<span style="color:#8B4513">     â–„â–ˆâ–€â–‘â–’â–’â–’â–„â–ˆâ–€â–‘â–‘â–‘â–’ â–„â–€â–‘â–„â–„â–‘â–‘â–€  </span>
<span style="color:#A0522D">   â–„â–ˆâ–€â–‘â–„â–„â–„â–ˆâ–ˆâ–€â–‘â–‘â–’â–’  â–€â–„â–€â–‘â–€â–€â–‘â–‘â–€ </span>
<span style="color:#A0522D"> â–„â–ˆâ–€â–„â–ˆâ–€â–€â–€â–‘â–‘â–‘â–’â–’â–’â–‘   â–€â–„â–‘â–‘â–‘â–‘â–‘â–„â–€  </span>
<span style="color:#A0522D">â–ˆâ–€â–„â–ˆâ–€â–‘â–‘â–’â–’â–’â–’â–’â–’â–’â–‘â–‘â–‘   â–€â–„â–‘â–‘â–„â–€    </span>
<span style="color:#CD853F"> â–ˆâ–€â–ˆâ–‘â–’â–’â–’â–’â–’â–’â–‘â–‘â–‘       â–€â–€      </span>
<span style="color:#CD853F"> â–ˆâ–ˆâ–‘â–’â–’â–’â–’â–’â–‘â–‘â–‘                    </span>
<span style="color:#CD853F"> â–ˆâ–„â–‘â–’â–’â–’â–’                     </span>
<span style="color:#CD853F">  â–ˆâ–„â–‘â–‘â–’â–’â–’â–„â–„â–‘                      </span>
<span style="color:#DEB887">   â–ˆâ–„â–‘â–‘â–„â–ˆâ–€â–’                       </span>
<span style="color:#DEB887">    â–ˆâ–„â–ˆâ–€â–‘â–’                        </span>
<span style="color:#DEB887">     â–ˆâ–„â–‘                         </span>
<span style="color:#DEB887">      â–€â–ˆâ–„â–„â–„â–„â–ˆâ–€                        </span>
    `,
                'Elder Thing': `
<span style="color:#8B4513">     </span><span style="color:#FF4500">(@)</span><span style="color:#A0522D">â•šâ•â•—</span><span style="color:#FF4500">(@)</span><span style="color:#A0522D">â•”â•â•</span><span style="color:#FF4500">(@)</span><span style="color:#8B4513">     </span>
<span style="color:#8B4513">      </span><span style="color:#A0522D">â•š  â•‘  â•</span><span style="color:#8B4513">      </span>
<span style="color:#8B4513">       </span><span style="color:#A0522D">â•š â•‘ â•</span><span style="color:#8B4513">       </span>
<span style="color:#8B4513">    </span><span style="color:#FF4500">(@)</span><span style="color:#CD853F">â•—â•š â•‘ â•â•”</span><span style="color:#FF4500">(@)</span><span style="color:#8B4513">    </span>
<span style="color:#8B4513">      </span><span style="color:#CD853F">â•” â•šâ•¦â• â•—</span><span style="color:#8B4513">      </span>
<span style="color:#704214">     â–„â–„</span><span style="color:#8B4513">â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</span><span style="color:#704214">â–„â–„     </span>
<span style="color:#704214">    â–ˆâ–ˆ</span><span style="color:#8B4513">â–’â–ˆ</span><span style="color:#FF4500">(@)</span><span style="color:#8B4513">â–ˆâ–’</span><span style="color:#704214">â–ˆâ–ˆ    </span>
<span style="color:#704214">   â–ˆâ–ˆ</span><span style="color:#8B4513">â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’</span><span style="color:#704214">â–ˆâ–ˆ   </span>
<span style="color:#36648B"> â–„â–ˆ</span><span style="color:#704214">â–ˆ</span><span style="color:#8B4513">â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’</span><span style="color:#704214">â–ˆ</span><span style="color:#36648B">â–ˆâ–„ </span>
<span style="color:#36648B">â–ˆâ–€</span><span style="color:#704214">â–ˆâ–ˆ</span><span style="color:#8B4513">â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’</span><span style="color:#704214">â–ˆâ–ˆ</span><span style="color:#36648B">â–€â–ˆ</span>
<span style="color:#36648B">â–€â–ˆâ–„</span><span style="color:#704214">â–ˆâ–ˆ</span><span style="color:#8B4513">â–’â–ˆâ–ˆâ–ˆâ–’</span><span style="color:#704214">â–ˆâ–ˆ</span><span style="color:#36648B">â–„â–ˆâ–€</span>
<span style="color:#36648B">  â–€â–ˆâ–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„â–ˆâ–€  </span>
<span style="color:#36648B">    â–€â–€â–ˆâ–„â–„â–„â–„â–„â–ˆâ–€â–€    </span>
<span style="color:#4682B4">  â–„â–„â–ˆâ–ˆâ–€     â–€â–ˆâ–ˆâ–„â–„  </span>
<span style="color:#4682B4"> â–ˆâ–ˆâ–€           â–€â–ˆâ–ˆ </span>
<span style="color:#4682B4">â–ˆâ–€               â–€â–ˆ</span>
<span style="color:#4682B4"> â–€â–ˆâ–ˆâ–€ â–€     â–€ â–€â–ˆâ–ˆâ–€ </span>
    `,
                'Star Spawn': `
<span style="color:#2A0A29">    â–„â–ˆâ–€</span><span style="color:#FF1493">â—‰</span><span style="color:#2A0A29">â–€â–ˆâ–ˆâ–€</span><span style="color:#FF1493">â—‰</span><span style="color:#2A0A29">â–€â–ˆâ–„    </span>
<span style="color:#2A0A29">   â–ˆâ–€ </span><span style="color:#4B0082">â–„â–„â–ˆâ–ˆâ–„â–„</span><span style="color:#2A0A29"> â–€â–ˆ   </span>
<span style="color:#2A0A29">  â–ˆâ–€ </span><span style="color:#4B0082">â–ˆ</span><span style="color:#FF1493">â—‰</span><span style="color:#4B0082">â–ˆ</span><span style="color:#2A0A29">â–€â–€</span><span style="color:#4B0082">â–ˆ</span><span style="color:#FF1493">â—‰</span><span style="color:#4B0082">â–ˆ</span><span style="color:#2A0A29"> â–€â–ˆ  </span>
<span style="color:#2A0A29"> â–ˆâ–€ </span><span style="color:#6A0DAD">â–ˆâ–„â–€â–€â–€â–€â–„â–ˆ</span><span style="color:#2A0A29"> â–€â–ˆ </span>
<span style="color:#2A0A29">â–ˆâ–€ </span><span style="color:#8A2BE2">â–ˆâ–€â–„</span><span style="color:#FF1493">â—‰</span><span style="color:#8A2BE2">â–„</span><span style="color:#FF1493">â—‰</span><span style="color:#8A2BE2">â–„â–€â–ˆ</span><span style="color:#2A0A29"> â–€â–ˆ</span>
<span style="color:#2A0A29">â–ˆ </span><span style="color:#9370DB">â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„</span><span style="color:#2A0A29"> â–ˆ</span>
<span style="color:#2A0A29">â–ˆ </span><span style="color:#BA55D3">â–ˆâ–ˆâ–ˆâ–€â–€â–€â–€â–€â–ˆâ–ˆâ–ˆ</span><span style="color:#2A0A29"> â–ˆ</span>
<span style="color:#2A0A29">â–ˆ </span><span style="color:#DA70D6">â–ˆâ–ˆâ–€  â–„  â–€â–ˆâ–ˆ</span><span style="color:#2A0A29"> â–ˆ</span>
<span style="color:#2A0A29">â–ˆ </span><span style="color:#EE82EE">â–ˆâ–ˆ  </span><span style="color:#FF1493"> â—‰</span><span style="color:#EE82EE">   â–ˆâ–ˆ</span><span style="color:#2A0A29"> â–ˆ</span>
<span style="color:#2A0A29">â–ˆâ–„ </span><span style="color:#DA70D6">â–ˆâ–ˆâ–„   â–„â–ˆâ–ˆ</span><span style="color:#2A0A29"> â–„â–ˆ</span>
<span style="color:#2A0A29">â–€â–ˆâ–„ </span><span style="color:#BA55D3">â–€â–ˆâ–ˆâ–„â–„â–„â–ˆâ–ˆâ–€</span><span style="color:#2A0A29"> â–„â–ˆâ–€</span>
<span style="color:#2A0A29"> â–€â–ˆâ–„â–„ </span><span style="color:#9370DB">â–€â–€â–€â–€â–€</span><span style="color:#2A0A29"> â–„â–„â–ˆâ–€ </span>
<span style="color:#2A0A29">   â–€â–€â–ˆâ–„â–„â–„â–„â–„â–ˆâ–€â–€   </span>
<span style="color:#4B0082"> â–„â–„â–ˆâ–ˆâ–€â–€â–€â–€â–€â–€â–€â–ˆâ–ˆâ–„â–„ </span>
<span style="color:#8A2BE2">â–ˆ â–„â–€       â–€â–„ â–ˆ</span>
<span style="color:#9370DB">â–€â–ˆâ–€         â–€â–ˆâ–€</span>
    `,
                'Mossman': `
    <span style="color:#004400">      â–„â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„â–„      </span>
<span style="color:#006600">    â–„â–ˆâ–€â–€â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–€â–€â–ˆâ–„    </span>
<span style="color:#008800">   â–ˆâ–€ â–„</span><span style="color:#FF0000">â–“â–“</span><span style="color:#008800">â–„â–‘â–‘â–‘â–‘â–„</span><span style="color:#FF0000">â–“â–“</span><span style="color:#008800">â–„ â–€â–ˆ   </span>
<span style="color:#00AA00">  â–ˆâ–‘ â–ˆâ–€â–€â–€â–€â–‘â–‘â–‘â–‘â–€â–€â–€â–€â–ˆ â–‘â–ˆ  </span>
<span style="color:#00CC00">  â–ˆâ–‘ â–ˆâ–‘â–‘</span><span style="color:#008800">â–„â–„â–ˆâ–ˆâ–„â–„</span><span style="color:#00CC00">â–‘â–‘â–ˆ â–‘â–ˆ  </span>
<span style="color:#00EE00"> â–„â–€â–‘ â–ˆâ–‘</span><span style="color:#008800">â–ˆâ–„â–„â–ˆâ–ˆâ–„â–„â–ˆ</span><span style="color:#00EE00">â–‘â–ˆ â–‘â–€â–„ </span>
<span style="color:#00FF00"> â–ˆâ–‘â–‘ â–ˆâ–‘â–ˆ â–‘â–‘â–€â–‘â–‘ â–ˆâ–‘â–ˆ â–‘â–‘â–ˆ </span>
<span style="color:#22FF22"> â–ˆâ–‘â–‘ â–ˆâ–‘â–ˆâ–ˆâ–ˆâ–„â–‘â–‘â–„â–ˆâ–ˆâ–ˆâ–‘â–ˆ â–‘â–‘â–ˆ </span>
<span style="color:#44FF44"> â–ˆâ–‘â–‘ â–€â–‘â–ˆâ–ˆâ–€â–€â–‘â–‘â–€â–€â–ˆâ–ˆâ–‘â–€ â–‘â–‘â–ˆ </span>
<span style="color:#66FF66"> â–ˆâ–‘â–‘â–‘ â–‘â–ˆâ–ˆâ–ˆâ–„â–„â–„â–„â–ˆâ–ˆâ–ˆâ–‘ â–‘â–‘â–‘â–ˆ </span>
<span style="color:#88FF88"> â–€â–„â–‘â–‘â–‘â–‘â–€â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€â–€â–‘â–‘â–‘â–„â–€ </span>
<span style="color:#AAFFAA">  â–€â–„â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–„â–€  </span>
<span style="color:#CCFFCC">   â–€â–„â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–„â–€   </span>
<span style="color:#EEFFEE">    â–€â–ˆâ–„â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–„â–ˆâ–€    </span>
<span style="color:#FFFFFF">      â–€â–ˆâ–„â–„â–‘â–‘â–‘â–‘â–„â–„â–ˆâ–€      </span>
<span style="color:#EEFFEE">     â–„â–ˆâ–€   â–€â–€â–€â–€    â–€â–ˆâ–„     </span>
<span style="color:#CCFFCC">   â–ˆâ–€   â–„â–ˆâ–€â–€â–€â–€â–€â–€â–ˆâ–„  â–€â–ˆ    </span>
    `,
                'Mi-go': `
<span style="color:#8B0000">        â–„â–„â–ˆâ–ˆâ–ˆâ–ˆâ–„â–„        </span>
<span style="color:#8B0000">      â–„â–ˆâ–€</span><span style="color:#00FF00">â—‰</span><span style="color:#8B0000">â–€â–€â–€â–€â–€</span><span style="color:#00FF00">â—‰</span><span style="color:#8B0000">â–€â–ˆâ–„      </span>
<span style="color:#8B0000">    â–„â–ˆâ–€â–€â–ˆâ–„â–„â–„â–„â–„â–„â–„â–ˆâ–€â–€â–ˆâ–„    </span>
<span style="color:#8B0000">  â–„â–ˆâ–€  â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„ â–€â–ˆâ–„  </span>
<span style="color:#8B0000">â–„â–ˆâ–€ â–„â–ˆâ–ˆâ–ˆâ–€â–€â–€â–€â–€â–€â–€â–€â–€â–ˆâ–ˆâ–ˆâ–„ â–€â–ˆâ–„</span>
<span style="color:#A52A2A">â–ˆâ–„â–„â–ˆâ–ˆâ–ˆâ–€  </span><span style="color:#228B22">â–„â–„â–„â–„â–„â–„</span><span style="color:#A52A2A">  â–€â–ˆâ–ˆâ–ˆâ–„â–„â–ˆ</span>
<span style="color:#A52A2A">â–ˆâ–€â–ˆâ–ˆâ–€   </span><span style="color:#32CD32">â–„â–€</span><span style="color:#B22222">â–ˆ</span><span style="color:#32CD32">â–‘â–‘â–‘â–€â–„</span><span style="color:#A52A2A">   â–€â–ˆâ–ˆâ–€â–ˆ</span>
<span style="color:#B22222">â–ˆ â–€â–ˆ   </span><span style="color:#3CB371">â–ˆ â–„â–„â–ˆâ–„â–„ â–ˆ</span><span style="color:#B22222">   â–ˆâ–€ â–ˆ</span>
<span style="color:#CD5C5C">â–ˆ  â–€   </span><span style="color:#66CDAA">â–€â–„â–€â–ˆâ–ˆâ–€â–„â–€</span><span style="color:#CD5C5C">   â–€  â–ˆ</span>
<span style="color:#FF6347">â–ˆâ–„   â–„â–„â–„â–€â–€â–„â–„â–„â–„â–€â–€â–„â–„â–„   â–„â–ˆ</span>
<span style="color:#FF6347">â–€â–ˆâ–„â–„â–ˆâ–€â–€â–ˆâ–„â–„  â–„â–„â–ˆâ–€â–€â–ˆâ–„â–„â–ˆâ–€</span>
<span style="color:#FF7F50"> â–€â–ˆâ–„  â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€  â–„â–ˆâ–€ </span>
<span style="color:#FF7F50">   â–€â–ˆâ–„â–„ â–€â–€â–€â–€â–€â–€ â–„â–„â–ˆâ–€   </span>
<span style="color:#FFA07A">     â–€â–ˆ â–ˆ â–„â–„ â–ˆ â–ˆâ–€     </span>
<span style="color:#FFB6C1">      â–€â–„â–€    â–€â–„â–€      </span>
<span style="color:#FFC0CB">       â–€      â–€       </span>
    `,
                'Nightgaunt': `
<span style="color:#000080">  â–„â–„</span><span style="color:#0000CD">â–€â–€</span><span style="color:#000080">â–„â–„    â–„â–„</span><span style="color:#0000CD">â–€â–€</span><span style="color:#000080">â–„â–„  </span>
<span style="color:#000080"> â–„</span><span style="color:#0000CD">â–€</span><span style="color:#000080">â–ˆ </span><span style="color:#0000CD">â–„â–„â–„â–„</span><span style="color:#000080"> â–ˆ</span><span style="color:#0000CD">â–€</span><span style="color:#000080">â–„ </span>
<span style="color:#000080">â–ˆâ–€ </span><span style="color:#0000CD">â–ˆâ–€â–€â–€â–€â–€â–€â–ˆ</span><span style="color:#000080"> â–€â–ˆ</span>
<span style="color:#000080">â–ˆ  </span><span style="color:#4169E1">â–ˆ â–„â–„â–„â–„ â–ˆ</span><span style="color:#000080">  â–ˆ</span>
<span style="color:#000080">â–ˆ </span><span style="color:#4169E1">â–ˆâ–€â–„â–€â–€â–€â–„â–€â–ˆ</span><span style="color:#000080"> â–ˆ</span>
<span style="color:#000080">â–ˆ </span><span style="color:#6495ED">â–ˆ â–€â–„â–„â–„â–€ â–ˆ</span><span style="color:#000080"> â–ˆ</span>
<span style="color:#000080">â–ˆ </span><span style="color:#6495ED">â–€â–ˆâ–„â–„â–„â–„â–„â–ˆâ–€</span><span style="color:#000080"> â–ˆ</span>
<span style="color:#000080">â–ˆ </span><span style="color:#87CEFA">â–ˆâ–ˆâ–ˆâ–€â–€â–€â–ˆâ–ˆâ–ˆ</span><span style="color:#000080"> â–ˆ</span>
<span style="color:#000080">â–ˆ </span><span style="color:#87CEFA">â–ˆâ–ˆâ–€   â–€â–ˆâ–ˆ</span><span style="color:#000080"> â–ˆ</span>
<span style="color:#000080">â–ˆ </span><span style="color:#ADD8E6">â–ˆâ–ˆ  â–„  â–ˆâ–ˆ</span><span style="color:#000080"> â–ˆ</span>
<span style="color:#000080">â–€â–ˆâ–„ </span><span style="color:#E6E6FA">â–€â–ˆâ–„â–„â–„â–ˆâ–€</span><span style="color:#000080"> â–„â–ˆâ–€</span>
<span style="color:#000080"> â–€â–ˆâ–„â–„ </span><span style="color:#E6E6FA">â–€â–€â–€</span><span style="color:#000080"> â–„â–„â–ˆâ–€ </span>
<span style="color:#000080">   â–€â–ˆâ–„â–„   â–„â–„â–ˆâ–€   </span>
<span style="color:#191970">     â–€â–ˆ   â–ˆâ–€     </span>
<span style="color:#191970">      â–ˆâ–„ â–„â–ˆ      </span>
<span style="color:#191970">       â–€â–€â–€       </span>
<span style="color:#191970">       â–€â–€â–€       </span>
    `,
                'Uroboros': `
<span style="color:#004000">     â–„â–„â–ˆâ–€</span><span style="color:#008000">â–€â–€â–€â–€â–€</span><span style="color:#004000">â–€â–€â–ˆâ–„â–„     </span>
<span style="color:#004000">   â–„â–ˆâ–€</span><span style="color:#008000">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#004000">â–€â–ˆâ–„   </span>
<span style="color:#004000"> â–„â–ˆ</span><span style="color:#008000">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#004000">â–ˆâ–„ </span>
<span style="color:#004000">â–ˆâ–€</span><span style="color:#008000">â–‘â–‘â–‘â–‘â–„â–„â–ˆâ–€â–€</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#008000">â–€â–€â–ˆâ–„â–„â–‘â–‘â–‘â–‘</span><span style="color:#004000">â–€â–ˆ</span>
<span style="color:#004000">â–ˆ</span><span style="color:#008000">â–‘â–‘â–„â–ˆâ–€â–‘</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#008000">â–€â–ˆâ–„â–‘â–‘</span><span style="color:#004000">â–ˆ</span>
<span style="color:#004000">â–ˆ</span><span style="color:#008000">â–‘â–ˆâ–€</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#FFD700">â–„â–„â–„â–„â–„â–„â–„</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#008000">â–€â–ˆâ–‘</span><span style="color:#004000">â–ˆ</span>
<span style="color:#004000">â–ˆ</span><span style="color:#008000">â–ˆâ–‘</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#FFD700">â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#008000">â–‘â–ˆ</span><span style="color:#004000">â–ˆ</span>
<span style="color:#004000">â–ˆ</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#FFD700">â–ˆâ–ˆâ–€â–‘</span><span style="color:#FFD700">ã€€â–‘â–€â–ˆâ–ˆ</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#004000">â–ˆ</span>
<span style="color:#004000">â–ˆ</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#FFD700">â–ˆâ–ˆâ–‘â–‘â–‘â–‘ã€€ã€€ã€€â–‘â–‘â–‘â–‘â–ˆâ–ˆ</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#004000">â–ˆ</span>
<span style="color:#004000">â–ˆ</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#FFD700">â–ˆâ–ˆâ–„â–‘â–‘â–‘ã€€â–‘â–‘â–‘â–„â–ˆâ–ˆ</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#004000">â–ˆ</span>
<span style="color:#004000">â–ˆ</span><span style="color:#008000">â–ˆ</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#FFD700">â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#008000">â–ˆ</span><span style="color:#004000">â–ˆ</span>
<span style="color:#004000">â–ˆ</span><span style="color:#008000">â–‘â–ˆâ–„</span><span style="color:#00FF00">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#008000">â–„â–ˆâ–‘</span><span style="color:#004000">â–ˆ</span>
<span style="color:#004000">â–ˆ</span><span style="color:#008000">â–‘â–‘â–‘â–€â–ˆâ–„â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–„â–ˆâ–€â–‘â–‘</span><span style="color:#004000">â–ˆ</span>
<span style="color:#004000">â–„</span><span style="color:#008000">â–‘â–‘â–‘â–‘â–‘â–€â–€â–ˆâ–„â–„â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–„â–„â–ˆâ–€â–€â–‘â–‘â–‘â–‘</span><span style="color:#004000">â–„â–ˆ</span>
<span style="color:#004000"> â–€â–ˆâ–„</span><span style="color:#008000">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–€â–€â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€â–€â–€â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#004000">â–„â–ˆâ–€ </span>
<span style="color:#004000">   â–€â–ˆâ–„â–„</span><span style="color:#008000">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#004000">â–„â–„â–ˆâ–€   </span>
<span style="color:#004000">     â–€â–€â–ˆâ–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–ˆâ–€â–€     </span>
    `,

                'Novice Explorer': `


<span style="color:#8B4513">     â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„     </span>
<span style="color:#8B4513">   â–„â–ˆâ–€</span><span style="color:#A0522D">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#8B4513">â–€â–ˆâ–„   </span>
<span style="color:#8B4513">  â–ˆâ–€</span><span style="color:#CD853F">â–‘â–‘</span><span style="color:#FFD700">â–„â–„â–„â–„â–„â–„â–„â–„</span><span style="color:#CD853F">â–‘â–‘</span><span style="color:#8B4513">â–€â–ˆ  </span>
<span style="color:#8B4513"> â–ˆ</span><span style="color:#CD853F">â–‘â–‘</span><span style="color:#FFD700">â–„â–ˆ</span><span style="color:#000000">â—</span><span style="color:#FFD700">â–ˆâ–‘â–‘â–ˆ</span><span style="color:#000000">â—</span><span style="color:#FFD700">â–ˆâ–„</span><span style="color:#CD853F">â–‘â–‘</span><span style="color:#8B4513">â–ˆ </span>
<span style="color:#8B4513"> â–ˆ</span><span style="color:#CD853F">â–‘</span><span style="color:#FFD700">â–ˆâ–‘</span><span style="color:#DEB887">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#FFD700">â–‘â–ˆ</span><span style="color:#CD853F">â–‘</span><span style="color:#8B4513">â–ˆ </span>
<span style="color:#8B4513"> â–ˆ</span><span style="color:#CD853F">â–‘</span><span style="color:#FFD700">â–ˆâ–‘â–‘â–‘</span><span style="color:#B8860B">\___/</span><span style="color:#FFD700">â–‘â–‘â–‘â–ˆ</span><span style="color:#CD853F">â–‘</span><span style="color:#8B4513">â–ˆ </span>
<span style="color:#8B4513"> â–ˆ</span><span style="color:#CD853F">â–‘â–‘</span><span style="color:#FFD700">â–€â–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–€</span><span style="color:#CD853F">â–‘â–‘</span><span style="color:#8B4513">â–ˆ </span>
<span style="color:#8B4513"> â–ˆâ–„â–‘â–‘</span><span style="color:#FFD700">â–€â–€â–ˆâ–„â–„â–„â–ˆâ–€â–€</span><span style="color:#CD853F">â–‘â–‘â–„â–ˆ </span>
<span style="color:#8B4513">  â–€â–ˆâ–„â–‘â–‘</span><span style="color:#DAA520">â–€â–€â–€â–€â–€</span><span style="color:#CD853F">â–‘â–‘â–„â–ˆâ–€  </span>
<span style="color:#8B4513">    â–€â–ˆâ–„â–„â–‘â–‘â–‘â–‘â–‘â–„â–„â–ˆâ–€    </span>


    `,
                'Seasoned Investigator': `
<span style="color:#8B4513">     â–„â–„â–„â–„â–„â–„â–„â–„     </span>
<span style="color:#8B4513">   â–„â–ˆâ–€</span><span style="color:#A0522D">â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#8B4513">â–€â–ˆâ–„   </span>
<span style="color:#8B4513">  â–ˆâ–€ </span><span style="color:#B8860B">â–„â–„â–„â–„â–„â–„â–„â–„</span><span style="color:#8B4513"> â–€â–ˆ  </span>
<span style="color:#8B4513"> â–ˆâ–€ </span><span style="color:#B8860B">â–ˆ</span><span style="color:#000000">â—</span><span style="color:#B8860B">â–€â–€â–€â–€</span><span style="color:#000000">â—</span><span style="color:#B8860B">â–ˆ</span><span style="color:#8B4513"> â–€â–ˆ </span>
<span style="color:#8B4513">â–ˆâ–€ </span><span style="color:#B8860B">â–ˆ  â–„â–ˆâ–ˆâ–„  â–ˆ</span><span style="color:#8B4513"> â–€â–ˆ</span>
<span style="color:#8B4513">â–ˆ </span><span style="color:#B8860B">â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„</span><span style="color:#8B4513"> â–ˆ</span>
<span style="color:#8B4513">â–ˆ </span><span style="color:#DAA520">â–ˆâ–ˆâ–ˆâ–€â–€â–€â–€â–€â–ˆâ–ˆâ–ˆ</span><span style="color:#8B4513"> â–ˆ</span>
<span style="color:#8B4513">â–ˆ </span><span style="color:#DAA520">â–ˆâ–ˆâ–€ </span><span style="color:#CD853F">â•±â•²</span><span style="color:#DAA520"> â–€â–ˆâ–ˆ</span><span style="color:#8B4513"> â–ˆ</span>
<span style="color:#8B4513">â–ˆ </span><span style="color:#DAA520">â–ˆâ–ˆ  </span><span style="color:#CD853F">â”‚â”‚</span><span style="color:#DAA520">  â–ˆâ–ˆ</span><span style="color:#8B4513"> â–ˆ</span>
<span style="color:#8B4513">â–ˆâ–„ </span><span style="color:#DAA520">â–ˆâ–ˆâ–„ </span><span style="color:#CD853F">â•²â•±</span><span style="color:#DAA520"> â–„â–ˆâ–ˆ</span><span style="color:#8B4513"> â–„â–ˆ</span>
<span style="color:#8B4513">â–€â–ˆâ–„ </span><span style="color:#B8860B">â–€â–ˆâ–ˆâ–„â–„â–„â–ˆâ–ˆâ–€</span><span style="color:#8B4513"> â–„â–ˆâ–€</span>
<span style="color:#8B4513"> â–€â–ˆâ–„â–„ </span><span style="color:#B8860B">â–€â–€â–€â–€â–€</span><span style="color:#8B4513"> â–„â–„â–ˆâ–€ </span>
<span style="color:#8B4513">   â–€â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€â–€   </span>

    `,
                'Arcane Scholar': `
<span style="color:#4B0082">      â–„â–„â–„â–„â–„â–„      </span>
<span style="color:#4B0082">    â–„â–ˆâ–€</span><span style="color:#6A5ACD">â–‘â–‘â–‘â–‘</span><span style="color:#4B0082">â–€â–ˆâ–„    </span>
<span style="color:#4B0082">   â–ˆâ–€</span><span style="color:#8A2BE2">â–„</span><span style="color:#000000">â—™</span><span style="color:#8A2BE2">â–€â–€â–€â–€</span><span style="color:#000000">â—™</span><span style="color:#8A2BE2">â–„</span><span style="color:#4B0082">â–€â–ˆ   </span>
<span style="color:#4B0082">  â–ˆâ–€</span><span style="color:#8A2BE2">â–ˆ â–„â–„â–„â–„â–„â–„ â–ˆ</span><span style="color:#4B0082">â–€â–ˆ  </span>
<span style="color:#4B0082"> â–ˆâ–€</span><span style="color:#8A2BE2">â–„â–ˆâ–€â–€â–€â–€â–€â–€â–€â–ˆâ–„</span><span style="color:#4B0082">â–€â–ˆ </span>
<span style="color:#4B0082">â–ˆâ–€</span><span style="color:#8A2BE2">â–ˆâ–€  â–„â–„â–„â–„  â–€â–ˆ</span><span style="color:#4B0082">â–€â–ˆ</span>
<span style="color:#4B0082">â–ˆ</span><span style="color:#8A2BE2">â–ˆ   â–ˆâ–„â–„â–ˆ   â–ˆ</span><span style="color:#4B0082">â–ˆ</span>
<span style="color:#4B0082">â–ˆ</span><span style="color:#9370DB">â–ˆâ–„  â–€â–€â–€â–€  â–„â–ˆ</span><span style="color:#4B0082">â–ˆ</span>
<span style="color:#4B0082">â–ˆ</span><span style="color:#9370DB">â–ˆâ–ˆâ–„  â–€â–€  â–„â–ˆâ–ˆ</span><span style="color:#4B0082">â–ˆ</span>
<span style="color:#4B0082">â–ˆ</span><span style="color:#9370DB">â–ˆâ–ˆâ–ˆâ–„    â–„â–ˆâ–ˆâ–ˆ</span><span style="color:#4B0082">â–ˆ</span>
<span style="color:#4B0082">â–ˆâ–„</span><span style="color:#9370DB">â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</span><span style="color:#4B0082">â–„â–ˆ</span>
<span style="color:#4B0082">â–€â–ˆâ–„</span><span style="color:#9370DB">â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</span><span style="color:#4B0082">â–„â–ˆâ–€</span>
<span style="color:#4B0082"> â–€â–ˆâ–ˆâ–„â–„â–„â–„â–„â–„â–„â–„â–„â–ˆâ–ˆâ–€ </span>
<span style="color:#4B0082">   â–€â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€â–€   </span>
    `,
                'Occult Detective': `
<span style="color:#2F4F4F">     â–„â–„â–„â–„â–„â–„â–„â–„     </span>
<span style="color:#2F4F4F">   â–„â–ˆâ–€</span><span style="color:#708090">â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#2F4F4F">â–€â–ˆâ–„   </span>
<span style="color:#2F4F4F">  â–ˆâ–€ </span><span style="color:#778899">â–„â–„â–„â–„â–„â–„â–„â–„</span><span style="color:#2F4F4F"> â–€â–ˆ  </span>
<span style="color:#2F4F4F"> â–ˆâ–€ </span><span style="color:#778899">â–ˆ</span><span style="color:#A9A9A9">â–’â–’â–’â–’â–’â–’</span><span style="color:#778899">â–ˆ</span><span style="color:#2F4F4F"> â–€â–ˆ </span>
<span style="color:#2F4F4F">â–ˆâ–€ </span><span style="color:#778899">â–ˆ</span><span style="color:#A9A9A9">â–’</span><span style="color:#000000">â—‹   â—‹</span><span style="color:#A9A9A9">â–’</span><span style="color:#778899">â–ˆ</span><span style="color:#2F4F4F"> â–€â–ˆ</span>
<span style="color:#2F4F4F">â–ˆ </span><span style="color:#778899">â–„â–ˆ</span><span style="color:#A9A9A9">â–’</span><span style="color:#000000">  â€¿</span><span style="color:#A9A9A9">â–’â–’</span><span style="color:#778899">â–ˆâ–„</span><span style="color:#2F4F4F"> â–ˆ</span>
<span style="color:#2F4F4F">â–ˆ </span><span style="color:#4B0082">â–ˆâ–ˆâ–ˆâ–€â–€â–€â–€â–€â–ˆâ–ˆâ–ˆ</span><span style="color:#2F4F4F"> â–ˆ</span>
<span style="color:#2F4F4F">â–ˆ </span><span style="color:#4B0082">â–ˆâ–ˆâ–€ </span><span style="color:#6A5ACD">â–„â–„</span><span style="color:#4B0082"> â–€â–ˆâ–ˆ</span><span style="color:#2F4F4F"> â–ˆ</span>
<span style="color:#2F4F4F">â–ˆ </span><span style="color:#4B0082">â–ˆâ–ˆ  </span><span style="color:#6A5ACD">â–€â–€</span><span style="color:#4B0082">  â–ˆâ–ˆ</span><span style="color:#2F4F4F"> â–ˆ</span>
<span style="color:#2F4F4F">â–ˆ </span><span style="color:#4B0082">â–ˆâ–ˆâ–„ </span><span style="color:#6A5ACD">â•±â•²</span><span style="color:#4B0082"> â–„â–ˆâ–ˆ</span><span style="color:#2F4F4F"> â–ˆ</span>
<span style="color:#2F4F4F">â–ˆâ–„</span><span style="color:#4B0082">â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</span><span style="color:#2F4F4F">â–„â–ˆ</span>
<span style="color:#2F4F4F">â–€â–ˆâ–„</span><span style="color:#4B0082">â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</span><span style="color:#2F4F4F">â–„â–ˆâ–€</span>
<span style="color:#2F4F4F"> â–€â–ˆâ–ˆâ–„â–„â–„â–„â–„â–„â–„â–„â–„â–ˆâ–ˆâ–€ </span>
<span style="color:#2F4F4F">   â–€â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€â–€   </span>
    `,
                'Eldritch Archaeologist': `
<span style="color:#556B2F">      â–„â–„â–„â–„â–„â–„      </span>
<span style="color:#556B2F">    â–„â–ˆâ–€</span><span style="color:#6B8E23">â–‘â–‘â–‘â–‘</span><span style="color:#556B2F">â–€â–ˆâ–„    </span>
<span style="color:#556B2F">   â–ˆâ–€</span><span style="color:#9ACD32">â–„</span><span style="color:#000000">â—™</span><span style="color:#9ACD32">â–€â–€â–€â–€</span><span style="color:#000000">â—™</span><span style="color:#9ACD32">â–„</span><span style="color:#556B2F">â–€â–ˆ   </span>
<span style="color:#556B2F">  â–ˆâ–€</span><span style="color:#9ACD32">â–ˆ â–„â–„â–„â–„â–„â–„ â–ˆ</span><span style="color:#556B2F">â–€â–ˆ  </span>
<span style="color:#556B2F"> â–ˆâ–€</span><span style="color:#9ACD32">â–„â–ˆâ–€â–€â–€â–€â–€â–€â–€â–ˆâ–„</span><span style="color:#556B2F">â–€â–ˆ </span>
<span style="color:#556B2F">â–ˆâ–€</span><span style="color:#9ACD32">â–ˆâ–€  </span><span style="color:#000000">â—‰   â—‰</span><span style="color:#9ACD32">  â–€â–ˆ</span><span style="color:#556B2F">â–€â–ˆ</span>
<span style="color:#556B2F">â–ˆ</span><span style="color:#9ACD32">â–ˆ    </span><span style="color:#000000">  â—¡</span><span style="color:#9ACD32">    â–ˆ</span><span style="color:#556B2F">â–ˆ</span>
<span style="color:#556B2F">â–ˆ</span><span style="color:#8FBC8F">â–ˆâ–„  â–€â–€â–€â–€  â–„â–ˆ</span><span style="color:#556B2F">â–ˆ</span>
<span style="color:#556B2F">â–ˆ</span><span style="color:#8FBC8F">â–ˆâ–ˆâ–„  â–€â–€  â–„â–ˆâ–ˆ</span><span style="color:#556B2F">â–ˆ</span>
<span style="color:#556B2F">â–ˆ</span><span style="color:#8FBC8F">â–ˆâ–ˆâ–ˆâ–„    â–„â–ˆâ–ˆâ–ˆ</span><span style="color:#556B2F">â–ˆ</span>
<span style="color:#556B2F">â–ˆâ–„</span><span style="color:#8FBC8F">â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</span><span style="color:#556B2F">â–„â–ˆ</span>
<span style="color:#556B2F">â–€â–ˆâ–„</span><span style="color:#8FBC8F">â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</span><span style="color:#556B2F">â–„â–ˆâ–€</span>
<span style="color:#556B2F"> â–€â–ˆâ–ˆâ–„â–„â–„â–„â–„â–„â–„â–„â–„â–ˆâ–ˆâ–€ </span>
<span style="color:#556B2F">   â–€â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€â–€   </span>
    `,
                'Cosmic Voyager': `
<span style="color:#191970">      â–„â–„â–ˆâ–€â–€â–ˆâ–„â–„      </span>
<span style="color:#191970">    â–„â–ˆâ–€</span><span style="color:#000080">â–‘â–‘â–‘â–‘â–‘â–‘</span><span style="color:#191970">â–€â–ˆâ–„    </span>
<span style="color:#191970">   â–ˆâ–€â–‘</span><span style="color:#4169E1">â–„â–„â–ˆâ–ˆâ–ˆâ–„â–„</span><span style="color:#191970">â–‘â–€â–ˆ   </span>
<span style="color:#191970">  â–ˆâ–‘</span><span style="color:#4169E1">â–ˆ</span><span style="color:#191970">â–’</span><span style="color:#FF4500">(@)</span><span style="color:#191970">â–’</span><span style="color:#4169E1">â–ˆ</span><span style="color:#191970">â–’</span><span style="color:#FF4500">(@)</span><span style="color:#191970">â–’</span><span style="color:#4169E1">â–ˆ</span><span style="color:#191970">â–‘â–ˆ  </span>
<span style="color:#191970"> â–ˆâ–‘</span><span style="color:#4169E1">â–ˆâ–€â–„</span><span style="color:#191970">â–’â–’â–’</span><span style="color:#4169E1">â–„â–€â–ˆ</span><span style="color:#191970">â–‘â–ˆ </span>
<span style="color:#191970">â–ˆâ–‘</span><span style="color:#4169E1">â–„â–ˆâ–€â–‘</span><span style="color:#191970">â–’â–’â–’</span><span style="color:#4169E1">â–‘â–€â–ˆâ–„</span><span style="color:#191970">â–‘â–ˆ</span>
<span style="color:#191970">â–ˆâ–‘</span><span style="color:#6495ED">â–ˆâ–„â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„â–„â–ˆ</span><span style="color:#191970">â–‘â–ˆ</span>
<span style="color:#191970">â–ˆâ–‘</span><span style="color:#6495ED">â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</span><span style="color:#191970">â–‘â–ˆ</span>
<span style="color:#191970">â–ˆâ–‘â–‘</span><span style="color:#6495ED">â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</span><span style="color:#191970">â–‘â–‘â–ˆ</span>
<span style="color:#191970">â–ˆâ–„â–‘â–‘</span><span style="color:#6495ED">â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</span><span style="color:#191970">â–‘â–‘â–„â–ˆ</span>
<span style="color:#191970"> â–ˆâ–€â–„â–„â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–„â–„â–€â–ˆ </span>
<span style="color:#191970"> â–€â–ˆâ–‘â–‘â–€â–€â–€â–€â–€â–€â–‘â–‘â–ˆâ–€ </span>
<span style="color:#191970">  â–€â–ˆâ–„â–‘â–‘â–‘â–‘â–‘â–‘â–„â–ˆâ–€  </span>
<span style="color:#191970">    â–€â–€â–ˆâ–„â–„â–„â–ˆâ–€â–€    </span>
    `
            };

            const dialogues = {
                adventurers: {
                    'Novice Explorer': {
                        normal: [
                            "What's this feeling...?",
                            "I must go deeper...",
                            "I need to know the truth...",
                            "No regrets choosing this path...",
                            "These ruins feel ancient...",
                            "Something calls to me...",
                            "Just a little further...",
                            "What secrets lie ahead?",
                            "The darkness feels... different here",
                            "My torch won't last forever..."
                        ],
                        mad: [
                            "The walls... they're breathing!",
                            "Can't sleep... they're watching...",
                            "The symbols... they speak to me...",
                            "Must... keep... exploring...",
                            "The shadows are dancing!",
                            "I hear whispers in the dark!",
                            "The path changes behind me!",
                            "My reflection... it blinked!",
                            "The air tastes like colors!",
                            "They're under my skin!"
                        ],
                        resist: [
                            "I... I won't give in!",
                            "My mind is my own!",
                            "Stay focused... stay sane...",
                            "The darkness won't take me!",
                            "I must... resist..."
                        ]
                    },
                    'Seasoned Investigator': {
                        normal: [
                            "These patterns seem familiar...",
                            "There must be a logical explanation...",
                            "I've seen this before somewhere...",
                            "The evidence is adding up...",
                            "Following the trail of clues...",
                            "This case is unlike any other...",
                            "The details matter...",
                            "Need to document everything...",
                            "Strange markings here...",
                            "Time to analyze the findings..."
                        ],
                        mad: [
                            "The angles... they're all wrong!",
                            "They're in my dreams now...",
                            "The truth... it burns!",
                            "Everything is connected!",
                            "The evidence defies physics!",
                            "My notes are writing themselves!",
                            "Time flows backwards here!",
                            "The case files are alive!",
                            "Reality is unraveling!",
                            "The truth was a lie all along!"
                        ],
                        resist: [
                            "Logic prevails!",
                            "Years of training pay off...",
                            "Mind over madness!",
                            "Experience guides me through...",
                            "Not today, cosmic horror..."
                        ]
                    },
                    'Arcane Scholar': {
                        normal: [
                            "These texts are fascinating...",
                            "Such ancient knowledge...",
                            "The symbols hold the key...",
                            "I'm close to a breakthrough...",
                            "This translation is challenging...",
                            "The manuscripts reveal more...",
                            "These runes are unique...",
                            "The patterns are complex...",
                            "Such forbidden knowledge...",
                            "The research continues..."
                        ],
                        mad: [
                            "The words... they move on their own!",
                            "The ancient ones speak through me!",
                            "Knowledge... too much knowledge!",
                            "I understand everything now!",
                            "The books are bleeding!",
                            "The letters crawl like insects!",
                            "The pages whisper secrets!",
                            "Reality is but a dream!",
                            "Time is an illusion!",
                            "The truth drives me mad!"
                        ],
                        resist: [
                            "Knowledge is my shield!",
                            "The wards hold strong!",
                            "My studies protect me!",
                            "Understanding brings clarity!",
                            "The sigils defend my mind!"
                        ]
                    },
                    'Occult Detective': {
                        normal: [
                            "Following the trail...",
                            "Something's not right here...",
                            "The pieces don't fit...",
                            "Getting closer to the truth...",
                            "These symbols are recurring...",
                            "The witnesses are hiding something...",
                            "This evidence is unusual...",
                            "The pattern is emerging...",
                            "Need more information...",
                            "The case grows stranger..."
                        ],
                        mad: [
                            "They're always watching!",
                            "The case... it's alive!",
                            "Can't trust my own shadow...",
                            "The evidence is impossible!",
                            "The walls have eyes!",
                            "My badge is melting!",
                            "The city is breathing!",
                            "Time is flowing backwards!",
                            "The streets are changing!",
                            "Reality is breaking down!"
                        ],
                        resist: [
                            "Not my first paranormal rodeo!",
                            "My mind stays sharp!",
                            "Can't cloud these eyes!",
                            "The truth shields me!",
                            "Seen worse in my line of work..."
                        ]
                    },
                    'Eldritch Archaeologist': {
                        normal: [
                            "These artifacts are unique...",
                            "Such strange architecture...",
                            "This predates known history...",
                            "Remarkable preservation...",
                            "The dating makes no sense...",
                            "These carvings are elaborate...",
                            "The site feels alive...",
                            "Such precise stonework...",
                            "The excavation continues...",
                            "These findings are unprecedented..."
                        ],
                        mad: [
                            "The ruins... they're changing!",
                            "Time is an illusion here!",
                            "The past is alive!",
                            "History was a lie!",
                            "The stones are pulsing!",
                            "The artifacts speak to me!",
                            "The dig site is moving!",
                            "The timeline is wrong!",
                            "The walls are breathing!",
                            "Ancient eyes are watching!"
                        ],
                        resist: [
                            "Ancient wisdom protects me!",
                            "These ruins won't break me!",
                            "History stands with me!",
                            "My research shields my mind!",
                            "The past strengthens my resolve!"
                        ]
                    },
                    'Cosmic Voyager': {
                        normal: [
                            "The stars align...",
                            "Space holds many secrets...",
                            "Beyond our dimension...",
                            "The void calls...",
                            "The cosmos beckons...",
                            "Such vast emptiness...",
                            "The patterns in space...",
                            "Strange constellations...",
                            "The universe whispers...",
                            "Time bends here..."
                        ],
                        mad: [
                            "The stars... they sing to me!",
                            "Space is alive!",
                            "Reality is breaking apart!",
                            "I see beyond the veil!",
                            "The void speaks my name!",
                            "The cosmos dances!",
                            "Dimensions are merging!",
                            "The stars are eyes!",
                            "Space-time is folding!",
                            "The universe screams!"
                        ],
                        resist: [
                            "The void cannot claim me!",
                            "My mind spans dimensions!",
                            "Reality bends, but I stand firm!",
                            "The stars align in my favor!",
                            "Cosmic forces flow through me!"
                        ]
                    }
                }
            };

            function formatNumber(num, decimalPlaces = 1) {
                if (!isFinite(num)) {
                    return "âˆ";
                }
                if (typeof num !== 'number' || isNaN(num)) {
                    console.warn(`Invalid number passed to formatNumber: ${num}`);
                    return '0';
                }

                if (num === 0) return '0';

                const absNum = Math.abs(num);

                // 1æœªæº€ã®æ•°å€¤ã®å‡¦ç†
                if (absNum < 1) {
                    // éå¸¸ã«å°ã•ãªæ•°å€¤ã®å ´åˆï¼ˆ0.0001æœªæº€ï¼‰ã¯ç§‘å­¦çš„è¨˜æ³•ã‚’ä½¿ç”¨
                    if (absNum < 0.0001) {
                        const exponent = Math.floor(Math.log10(absNum));
                        const mantissa = absNum / Math.pow(10, exponent);
                        return `${mantissa.toFixed(2)}e${exponent}`;
                    }
                    // ãã‚Œä»¥å¤–ã®1æœªæº€ã®æ•°å€¤ã¯ã€æŒ‡å®šã•ã‚ŒãŸå°æ•°ç‚¹ä»¥ä¸‹ã®æ¡æ•°ã§è¡¨ç¤º
                    return absNum.toFixed(Math.max(decimalPlaces, 4));
                }

                // 1ä»¥ä¸Š1000æœªæº€ã®æ•°å€¤
                if (absNum < 1e3) {
                    return num.toFixed(decimalPlaces);
                }

                // å¤§ããªæ•°å€¤ã®å‡¦ç†ï¼ˆæ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ï¼‰
                const abbreviations = ['', 'K', 'M', 'B', 'T'];
                const maxAbbreviationIndex = abbreviations.length - 1;

                let tier = Math.floor(Math.log10(absNum) / 3);
                if (tier > maxAbbreviationIndex) {
                    const exponent = Math.floor(Math.log10(absNum));
                    const mantissa = absNum / Math.pow(10, exponent);
                    return `${mantissa.toFixed(2)}e${exponent}`;
                } else {
                    const scaled = num / Math.pow(10, tier * 3);
                    const formatted = scaled.toFixed(decimalPlaces);
                    return `${formatted}${abbreviations[tier]}`;
                }
            }

            function safeFormatNumber(value, decimalPlaces = 1) {
                if (typeof value !== 'number' || !isFinite(value)) {
                    console.warn(`Invalid value encountered: ${value}`);
                    return '0';
                }
                return formatNumber(value, decimalPlaces);
            }

            function formatBigNumber(num) {
                if (typeof num === 'bigint') {
                    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
                }
                return formatNumber(num);
            }

            function sanitizeGameState() {
                const numericProps = ['source', 'miasma', 'followers', 'followerAccumulator', 'followerEfficiency'];

                numericProps.forEach(prop => {
                    // æœªå®šç¾©ã¾ãŸã¯ç„¡åŠ¹ãªå€¤ã®å ´åˆã¯0ã«åˆæœŸåŒ–
                    if (!isFinite(gameState[prop]) || isNaN(gameState[prop])) {
                        gameState[prop] = 0;
                    }

                    // è² ã®å€¤ã‚’é˜²æ­¢
                    if (gameState[prop] < 0) {
                        gameState[prop] = 0;
                    }

                    // æ¥µç«¯ã«å¤§ããªå€¤ã‚’é˜²æ­¢
                    if (gameState[prop] > Number.MAX_SAFE_INTEGER) {
                        gameState[prop] = Number.MAX_SAFE_INTEGER;
                    }
                });
            }

            // calculateResourceProductioné–¢æ•°ã®æˆ»ã‚Šå€¤ã®æ¤œè¨¼ã‚’è¿½åŠ 
            const originalCalculateResourceProduction = calculateResourceProduction;
            calculateResourceProduction = function () {
                const result = originalCalculateResourceProduction();

                // çµæœã®æ¤œè¨¼
                const validated = {
                    sourceProduction: Number(result.sourceProduction) || 0,
                    miasmaProduction: Number(result.miasmaProduction) || 0,
                    followerProduction: Number(result.followerProduction) || 0
                };

                // æ¥µç«¯ãªå€¤ã®é˜²æ­¢
                Object.keys(validated).forEach(key => {
                    if (!isFinite(validated[key]) || validated[key] < 0) {
                        validated[key] = 0;
                    }
                    if (validated[key] > Number.MAX_SAFE_INTEGER) {
                        validated[key] = Number.MAX_SAFE_INTEGER;
                    }
                });

                return validated;
            };

            // æœ€åˆã«UPDATE_INTERVALSã¨lastUpdateTimesã‚’å®šç¾©
            const UPDATE_INTERVALS = {
                monsterGrid: 100,
                followerSection: 100,
                madnessTable: 100,
                upgradeGrid: 100,
                gameDetails: 100
            };

            let lastUpdateTimes = {
                monsterGrid: 0,
                followerSection: 0,
                madnessTable: 0,
                upgradeGrid: 0,
                gameDetails: 0
            };

            // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®è¿½åŠ 
            let currentTooltip = null;
            let currentAsciiArt = null;
            let tooltipVisible = false;

            // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®æ›´æ–°é–¢æ•°ã‚‚ä¿®æ­£
            function updateFollowerSection() {
                const followerSection = document.getElementById('followerSection');
                if (!followerSection) return;

                const production = calculateResourceProduction();
                const cultosBonus = calculateCultosBonus();
                const baseFollowerProduction = production.followerProduction; // Cultosãƒœãƒ¼ãƒŠã‚¹é©ç”¨å‰
                const finalFollowerProduction = production.followerProduction / cultosBonus; // å…¨ãƒœãƒ¼ãƒŠã‚¹é©ç”¨å¾Œ

                const tooltipText = 'Basic Followers:\nâ€¢ Generate 0.1 source per second\nâ€¢ Can be recruited using source\nâ€¢ Production increases with upgrades' +
                    (cultosBonus > 1 ? `\nâ€¢ Current Cultos bonus: +${((cultosBonus - 1) * 100).toFixed(1)}%` : '');

                const tooltipContent = `
        <div class="follower-tooltip">
            <h3>Basic Followers</h3>
            <ul>
                <li>Generate 0.1 source per second</li>
                <li>Can be recruited using source</li>
                <li>Production increases with upgrades</li>
                ${cultosBonus > 1 ? `<li>Current Cultos bonus: +${((cultosBonus - 1) * 100).toFixed(1)}%</li>` : ''}
            </ul>
        </div>
    `;

                followerSection.innerHTML = `
        <h2>Followers</h2>
        <div class="follower-container" style="position: relative;">
            <div id="followerAsciiArt" class="ascii-art follower-ascii-art tooltip-trigger" 
                style="cursor: pointer; user-select: none;">
                ${asciiArt['Follower']}
                ${tooltipContent}
            </div>
        </div>
        <div class="follower-stats">
            <p>Count: <span id="followerCount">${formatNumber(gameState.followers, 0)}</span></p>
            <p>Efficiency: <span id="followerEfficiency">${formatNumber(gameState.followerEfficiency * cultosBonus, 2)}</span></p>
            <p>Source Production: <span id="followerPerSecond">${formatNumber(production.sourceProduction, 1)}</span>/sec</p>
            <p>Next Recruit Cost: <span id="nextFollowerCost">${formatNumber(getCost('follower'), 0)}</span> source</p>
        </div>
    `;

                // ã‚¹ã‚¿ã‚¤ãƒ«ã®è¿½åŠ 
                const style = document.createElement('style');
                style.textContent = `
        .follower-tooltip {
            display: none;
            position: absolute;
            color: #fff;
            padding: 8px;
            z-index: 10000;
            top: 5%;
            left: 50%;
            font-size: 10px;
            transform: translateX(-50%);
            width: max-content;
            font-family: 'Roboto', sans-serif;
        }   

        .follower-tooltip h3 {
            margin: 0 0 8px 0;
            color: #4CAF50;
        }

        .follower-tooltip ul {
            margin: 0;
            padding-left: 20px;
        }

        .follower-tooltip li {
            margin: 4px 0;
        }

            .cultos-bonus {
                margin-top: 10px;
                padding: 8px;
                background: rgba(66, 135, 245, 0.1);
                border-left: 3px solid #4287f5;
                border-radius: 4px;
            }
            .bonus-details {
                font-size: 0.9em;
                color: #888;
                margin-left: 10px;
                margin-top: 5px;
            }
            .production-details,.efficiency-details {
                margin-top: 15px;
                padding: 10px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 4px;
            }
        `;
                document.head.appendChild(style);

                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¿½åŠ 
                const followerArt = document.getElementById('followerAsciiArt');
                if (followerArt) {
                    followerArt.addEventListener('mouseenter', () => {
                        const tooltip = followerArt.querySelector('.follower-tooltip');
                        if (tooltip) {
                            tooltip.style.display = 'block';
                        }
                    });

                    followerArt.addEventListener('mouseleave', () => {
                        const tooltip = followerArt.querySelector('.follower-tooltip');
                        if (tooltip) {
                            tooltip.style.display = 'none';
                        }
                    });
                }
            }

            // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹é–¢æ•°
            function toggleFollowerTooltip(event) {
                const tooltip = event.currentTarget.querySelector('.follower-tooltip');
                if (tooltip) {
                    console.log('Toggling tooltip');
                    tooltip.classList.toggle('active');
                } else {
                    console.warn('Tooltip element not found');
                }
            }

            function updateButtonStates() {
                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ãƒ¼ãƒ‰ã®ãƒœã‚¿ãƒ³çŠ¶æ…‹ã‚’æ›´æ–°
                const monsterCards = document.querySelectorAll('.monster-card');
                monsterCards.forEach(card => {
                    const summonButton = card.querySelector('.summon-monster-btn');
                    if (summonButton) {
                        const monsterType = summonButton.dataset.monster;
                        const monster = gameState.monsters[monsterType];
                        if (monster) {
                            const canSummon = gameState.followers >= monster.baseFollowerCost;
                            summonButton.disabled = !canSummon;
                        }
                    }
                });

                // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
                const upgradeButtons = document.querySelectorAll('.buy-upgrade-btn');
                upgradeButtons.forEach(button => {
                    const upgradeType = button.dataset.upgrade;
                    if (upgradeType && baseCosts[upgradeType]) {
                        // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚³ã‚¹ãƒˆã‚’ baseCosts ã‹ã‚‰ç›´æ¥å–å¾—
                        const upgradeCost = Math.floor(baseCosts[upgradeType] * (gameState.upgradeCostMultiplier || 1));
                        const canAfford = gameState.source >= upgradeCost;
                        button.disabled = !canAfford;
                        button.classList.toggle('button-affordable', canAfford);
                        button.classList.toggle('button-disabled', !canAfford);
                    }
                });

                const recruitButton = document.getElementById('recruitFollowerBtn');
                if (recruitButton) {
                    const isSealed = gameState.pacts?.active?.includes('1');
                    recruitButton.style.display = isSealed ? 'none' : 'block';
                    recruitButton.disabled = isSealed;
                    recruitButton.classList.toggle('sealed-by-pact', isSealed);
                }

                // ç‹‚æ°—ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
                const madnessButtons = document.querySelectorAll('.madness-btn');
                madnessButtons.forEach(button => {
                    const index = parseInt(button.dataset.index);
                    if (!isNaN(index) && gameState.adventurers[index]) {
                        const adventurer = gameState.adventurers[index];
                        const canAttempt = !adventurer.isMad &&
                            !adventurer.isOnCooldown &&
                            gameState.miasma >= adventurer.madnessCost;
                        button.disabled = !canAttempt;
                    }
                });

                // å¥‘ç´„ã«ã‚ˆã‚‹å°å°çŠ¶æ…‹ã®ç¢ºèªã¨é©ç”¨
                if (gameState.pacts?.active?.includes('1')) {
                    hideManualRecruitButtons();
                }
            }

            function updateUpgradeSymbols() {
                const symbolsContainer = document.getElementById('upgradeSymbols');
                if (!symbolsContainer) return;

                // ã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚¯ãƒªã‚¢
                symbolsContainer.innerHTML = '';

                // è³¼å…¥æ¸ˆã¿ã®ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ã‚·ãƒ³ãƒœãƒ«ã‚’è¡¨ç¤º
                for (const upgrade of gameState.upgrades) {
                    if (upgradeSymbols[upgrade]) {
                        const symbolSpan = document.createElement('span');
                        symbolSpan.className = 'upgrade-symbol';
                        symbolSpan.textContent = upgradeSymbols[upgrade];

                        // tooltipã‚’è¨­å®š
                        const tooltipText = upgradeEffects[upgrade];
                        tippy(symbolSpan, {
                            content: tooltipText,
                            placement: 'bottom'
                        });

                        symbolsContainer.appendChild(symbolSpan);
                    }
                }
            }

            // å¹ãå‡ºã—ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
            let activeSpeechBubble = false;

            // ã‚¹ãƒ”ãƒ¼ãƒãƒãƒ–ãƒ«ã®çŠ¶æ…‹ç®¡ç†
            const speechBubbleState = {
                activeSpeechBubble: false,
                currentTimeout: null
            };

            // ã‚»ãƒªãƒ•ç®¡ç†ã®ãŸã‚ã®çŠ¶æ…‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            const bubbleState = {
                activeBubbles: new Set(),
                currentTimeout: null
            };

            // ã‚»ãƒªãƒ•ãƒãƒ–ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
            function showSpeechBubble(adventurerElement, text, duration = 3000, type = 'normal') {
                // æ—¢å­˜ã®ãƒãƒ–ãƒ«ã‚’ã™ã¹ã¦å‰Šé™¤
                removePreviousBubbles();

                // ãƒãƒ–ãƒ«ã®ä½œæˆ
                const bubble = document.createElement('div');
                bubble.className = `speech-bubble ${type}`;
                bubble.innerHTML = `
    <div class="bubble-content">
      <p>${text}</p>
      ${type === 'mad' ? '<div class="madness-effect"></div>' : ''}
    </div>
  `;

                // ãƒãƒ–ãƒ«ã‚’DOMã«è¿½åŠ 
                document.body.appendChild(bubble);

                // ä½ç½®ã®æ›´æ–°é–¢æ•°
                const updateBubblePosition = () => {
                    const rect = adventurerElement.getBoundingClientRect();
                    const windowHeight = window.innerHeight;
                    const verticalMargin = -65; // å…ƒã®ä»•æ§˜ã®ä¸Šæ–¹å‘ãƒãƒ¼ã‚¸ãƒ³

                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ä¸Šã«è¡¨ç¤ºï¼ˆå…ƒã®ä»•æ§˜é€šã‚Šï¼‰
                    bubble.style.bottom = `${windowHeight - rect.top + verticalMargin}px`;
                    bubble.style.left = `${rect.left + rect.width / 1.5}px`; // å…ƒã®æ°´å¹³ä½ç½®ã‚’ç¶­æŒ
                    bubble.className = `speech-bubble ${type} show top-arrow`; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ä¸Šå‘ãçŸ¢å°
                };

                // åˆæœŸä½ç½®è¨­å®šã¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                requestAnimationFrame(() => {
                    updateBubblePosition();
                    bubble.classList.add('show');
                });

                // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¨ãƒªã‚µã‚¤ã‚ºæ™‚ã®ä½ç½®æ›´æ–°ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ä»˜ãï¼‰
                const scrollHandler = debounce(() => {
                    if (bubble && bubble.parentElement) {
                        updateBubblePosition();
                    }
                }, 50);

                window.addEventListener('scroll', scrollHandler);
                window.addEventListener('resize', scrollHandler);

                // ãƒãƒ–ãƒ«ã®çŠ¶æ…‹ã‚’ç®¡ç†
                bubbleState.activeBubbles.add(bubble);

                // ä¸€å®šæ™‚é–“å¾Œã«å‰Šé™¤
                bubbleState.currentTimeout = setTimeout(() => {
                    removeBubble(bubble);
                }, duration);

                // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ç”¨ã®é–¢æ•°ã‚’ä¿å­˜
                const cleanup = () => {
                    window.removeEventListener('scroll', scrollHandler);
                    window.removeEventListener('resize', scrollHandler);
                };

                return { bubble, cleanup };
            }

            // æ—¢å­˜ã®ãƒãƒ–ãƒ«ã‚’å‰Šé™¤
            function removePreviousBubbles() {
                bubbleState.activeBubbles.forEach(bubble => {
                    removeBubble(bubble);
                });
                if (bubbleState.currentTimeout) {
                    clearTimeout(bubbleState.currentTimeout);
                    bubbleState.currentTimeout = null;
                }
            }

            // å˜ä¸€ã®ãƒãƒ–ãƒ«ã‚’å‰Šé™¤
            function removeBubble(bubble) {
                if (!bubble) return;

                bubble.classList.remove('show');
                bubble.addEventListener('transitionend', () => {
                    bubble.remove();
                    bubbleState.activeBubbles.delete(bubble);
                }, { once: true });
            }

            // ãƒ‡ãƒã‚¦ãƒ³ã‚¹é–¢æ•°
            function debounce(func, wait) {
                let timeout;
                return function (...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            }

            // å›ºå®šè¡¨ç¤ºç”¨ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
            function showFixedBubble(bubble) {
                if (bubble.parentElement) {
                    bubble.remove();
                }
                bubble.style.position = 'fixed';
                bubble.style.bottom = '20px';
                bubble.style.left = '50%';
                bubble.style.transform = 'translateX(-50%)';
                bubble.classList.add('no-arrow');
                document.body.appendChild(bubble);
            }

            // å¹ãå‡ºã—ã‚’å‰Šé™¤ã™ã‚‹é–¢æ•°
            function removeSpeechBubble() {
                const bubble = document.querySelector('.speech-bubble');
                if (bubble) {
                    bubble.classList.remove('show');
                    bubble.addEventListener('transitionend', () => {
                        bubble.remove();
                        speechBubbleState.activeSpeechBubble = false;
                    }, { once: true });
                }

                if (speechBubbleState.currentTimeout) {
                    clearTimeout(speechBubbleState.currentTimeout);
                    speechBubbleState.currentTimeout = null;
                }

                if (speechBubbleState.cleanup) {
                    speechBubbleState.cleanup();
                    speechBubbleState.cleanup = null;
                }
            }

            let existingStyle = document.querySelector('style');
            if (existingStyle) {
                existingStyle.textContent += `
/* ã‚¹ãƒ”ãƒ¼ãƒãƒãƒ–ãƒ«ã®ãƒ™ãƒ¼ã‚¹ã‚¹ã‚¿ã‚¤ãƒ« */
.speech-bubble {
    background: #1a1a1a;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 12px 16px;
    max-width: 800px;
    min-width: 180px;
    font-size: 10px;
    color: #ccc;
    position: fixed; /* å›ºå®šä½ç½®ã«å¤‰æ›´ */
    z-index: 100000;
    opacity: 0;
    pointer-events: none;
    text-align: center;
    transform: translateX(-50%);
    letter-spacing: 3px;
    white-space: normal;
    word-wrap: break-word;
    transition: all 0.3s ease;
    font-family: 'Press Start 2P', cursive;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    margin: 10px 0; /* ä¸Šä¸‹ã®ãƒãƒ¼ã‚¸ãƒ³ã‚’è¿½åŠ  */
}

/* è¡¨ç¤ºçŠ¶æ…‹ */
.speech-bubble.show {
    opacity: 1;
}

/* ä¸Šå‘ãçŸ¢å°ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.speech-bubble.top-arrow::after {
    content: '';
    position: absolute;
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    border-width: 10px 10px 0;
    border-style: solid;
    border-color: #444 transparent transparent;
}

/* ä¸‹å‘ãçŸ¢å°ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.speech-bubble.bottom-arrow::after {
    content: '';
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    border-width: 0 10px 10px;
    border-style: solid;
    border-color: transparent transparent #444;
}

/* ç‹‚æ°—çŠ¶æ…‹ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.speech-bubble.mad {
    background: rgba(40, 0, 0, 0.95);
    border: 2px solid #8a4a4a;
    color: #ff8a8a;
    font-weight: bold;
    font-style: italic;
    animation: madPulse 3s ease-in-out infinite;
    text-shadow: 0 0 5px #ff0000;
}

/* ãƒ¬ã‚¸ã‚¹ãƒˆçŠ¶æ…‹ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.speech-bubble.resist {
    background: rgba(0, 0, 40, 0.95);
    border: 2px solid #4a4a8a;
    color: #8a8aff;
    font-weight: bold;
    animation: resistGlow 2s ease-in-out infinite;
}

/* ãƒãƒ–ãƒ«ã®ä½ç½®èª¿æ•´ç”¨ã®ã‚¯ãƒ©ã‚¹ */
.speech-bubble.top-position {
    bottom: calc(100% + 20px); /* ã‚«ãƒ¼ãƒ‰ã®ä¸Šç«¯ã‹ã‚‰20pxä¸Šã«é…ç½® */
}

.speech-bubble.bottom-position {
    top: calc(100% + 20px); /* ã‚«ãƒ¼ãƒ‰ã®ä¸‹ç«¯ã‹ã‚‰20pxä¸‹ã«é…ç½® */
}

/* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®šç¾© */
@keyframes madPulse {
    0% { box-shadow: 0 0 5px #ff0000; }
    50% { box-shadow: 0 0 15px #ff0000; }
    100% { box-shadow: 0 0 5px #ff0000; }
}

@keyframes resistGlow {
    0% { box-shadow: 0 0 5px #4169e1; }
    50% { box-shadow: 0 0 15px #4169e1; }
    100% { box-shadow: 0 0 5px #4169e1; }
}
`;
            }

            // ãƒ©ãƒ³ãƒ€ãƒ ãªå°è©ã‚’é¸æŠã—ã¦è¡¨ç¤ºã™ã‚‹é–¢æ•°
            function triggerRandomDialogue() {
                const adventurers = gameState.adventurers.filter(a =>
                    gameState.unlockedContent.adventurers.has(a.name)
                );

                if (adventurers.length === 0) return;

                const selectedAdventurer = adventurers[Math.floor(Math.random() * adventurers.length)];
                const isMad = selectedAdventurer.isMad;

                const dialoguePool = isMad ? DIALOGUE[selectedAdventurer.name].mad : DIALOGUE[selectedAdventurer.name].normal;
                const selectedText = dialoguePool[Math.floor(Math.random() * dialoguePool.length)];

                showSpeechBubble({
                    text: selectedText,
                    type: isMad ? 'mad' : 'normal',
                    duration: isMad ? 3000 : 3000
                });
            }

            let lastDialogueTime = 0;
            const DIALOGUE_COOLDOWN = 3000; // 6ç§’ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
            // ãƒ©ãƒ³ãƒ€ãƒ ã«ã‚»ãƒªãƒ•ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
            function randomDialogue() {
                const currentTime = Date.now();

                // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ãªã‚‰å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
                if (currentTime - lastDialogueTime < DIALOGUE_COOLDOWN) {
                    return;
                }

                if (speechBubbleState.activeSpeechBubble) {
                    return;
                }

                // ç¢ºç‡ã‚’0.02%ã‹ã‚‰2%ã«å¢—åŠ 
                if (Math.random() < 0.02) {
                    console.log('Random dialogue triggered');
                    const activeAdventurers = gameState.adventurers.filter(adv =>
                        gameState.unlockedContent.adventurers.has(adv.name)
                    );

                    if (activeAdventurers.length > 0) {
                        const adventurer = activeAdventurers[Math.floor(Math.random() * activeAdventurers.length)];
                        const adventurerElement = document.querySelector(`#adventurer-${gameState.adventurers.indexOf(adventurer)}`);
                        console.log('Selected adventurer:', adventurer.name);

                        if (adventurerElement) {
                            const dialogueList = dialogues.adventurers[adventurer.name];
                            if (dialogueList) {
                                const state = adventurer.isMad ? 'mad' : 'normal';
                                const possibleDialogues = dialogueList[state];

                                if (possibleDialogues && possibleDialogues.length > 0) {
                                    const randomText = possibleDialogues[Math.floor(Math.random() * possibleDialogues.length)];
                                    showSpeechBubble(adventurerElement, randomText, 5000, state);
                                    lastDialogueTime = currentTime; // æœ€å¾Œã®ã‚»ãƒªãƒ•è¡¨ç¤ºæ™‚åˆ»ã‚’æ›´æ–°
                                }
                            }
                        }
                    }
                }
            }

            function checkMadness(adventurer) {
                const madnessChance = calculateMadnessChance(adventurer);
                //console.log('Madness check for:', adventurer.name, 'chance:', madnessChance);

                const adventurerElement = document.querySelector(`#adventurer-${gameState.adventurers.indexOf(adventurer)}`);
                if (!adventurerElement) {
                    console.warn('Adventurer element not found');
                    return false;
                }

                if (Math.random() < madnessChance) {
                    // console.log('Madness check succeeded');
                    if (!adventurer.isMad) {
                        adventurer.isMad = true;
                        // ç‹‚æ°—ã«é™¥ã£ãŸæ™‚ã®ã‚»ãƒªãƒ•ã‚’å¿…ãšè¡¨ç¤º
                        const dialogueList = dialogues.adventurers[adventurer.name];
                        if (dialogueList && dialogueList.mad && dialogueList.mad.length > 0) {
                            const madDialogues = dialogueList.mad;
                            const randomText = madDialogues[Math.floor(Math.random() * madDialogues.length)];
                            //       console.log('Selected mad dialogue:', randomText);
                            showSpeechBubble(adventurerElement, randomText, 5000, 'mad');
                        }
                    }
                    return true;
                } else {
                    // ãƒ¬ã‚¸ã‚¹ãƒˆæ™‚ã®ã‚»ãƒªãƒ•ã‚’å¿…ãšè¡¨ç¤º
                    const dialogueList = dialogues.adventurers[adventurer.name];
                    if (dialogueList && dialogueList.resist && dialogueList.resist.length > 0) {
                        const resistDialogues = dialogueList.resist;
                        const randomText = resistDialogues[Math.floor(Math.random() * resistDialogues.length)];
                        showSpeechBubble(adventurerElement, randomText, 3000, 'resist');
                        // console.log('Selected resist dialogue:', randomText);
                    }
                    return false;
                }
            }

            function showResistDialogue(adventurer, adventurerElement) {
                console.log('Showing resist dialogue for:', adventurer.name);

                // dialoguesã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰resistã‚»ãƒªãƒ•ã‚’å–å¾—ã—ã¦å¿…ãšè¡¨ç¤º
                const dialogueList = dialogues.adventurers[adventurer.name];
                if (dialogueList && dialogueList.resist && dialogueList.resist.length > 0) {
                    const resistDialogues = dialogueList.resist;
                    const randomText = resistDialogues[Math.floor(Math.random() * resistDialogues.length)];
                    console.log('Selected resist dialogue:', randomText);
                    showSpeechBubble(adventurerElement, randomText, 3000, 'resist');
                } else {
                    console.warn(`No resist dialogues found for ${adventurer.name}`);
                }
            }

            // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®å°è©ãƒ‡ãƒ¼ã‚¿
            const followerDialogues = {
                normal: [
                    "We serve the ancient ones...",
                    "The ritual must continue...",
                    "Our numbers grow stronger...",
                    "The Source flows through us...",
                    "We hear the whispers...",
                    "Our faith is unwavering...",
                    "The stars align...",
                    "We await the great awakening...",
                    "Our devotion deepens...",
                    "The old ones guide us..."
                ],
                transformed: {  // å¥‘ç´„å¾Œã®å°è©
                    1: [  // ç¬¬1ã®å¥‘ç´„
                        "We are reborn...",
                        "Our flesh transcends...",
                        "The pact binds us...",
                        "We see clearer now...",
                        "Our forms shift and change..."
                    ],
                    2: [  // ç¬¬2ã®å¥‘ç´„
                        "Reality bends to our will...",
                        "We exist between worlds...",
                        "Time flows differently...",
                        "The void embraces us...",
                        "We become one with darkness..."
                    ]
                }
            };

            // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®ã‚»ãƒªãƒ•ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
            function showFollowerDialogue() {
                const currentTime = Date.now();
                if (currentTime - lastDialogueTime < DIALOGUE_COOLDOWN) return;

                // ç¢ºç‡ã§å°è©ã‚’è¡¨ç¤ºï¼ˆ2%ã®ç¢ºç‡ï¼‰
                if (Math.random() < 0.02) {
                    const followerSection = document.getElementById('followerSection');
                    if (!followerSection) return;

                    let dialoguePool;
                    // å¥‘ç´„çŠ¶æ…‹ã«å¿œã˜ã¦å°è©ãƒ—ãƒ¼ãƒ«ã‚’é¸æŠ
                    if (gameState.pacts.active.includes('2')) {
                        dialoguePool = followerDialogues.transformed[2];
                    } else if (gameState.pacts.active.includes('1')) {
                        dialoguePool = followerDialogues.transformed[1];
                    } else {
                        dialoguePool = followerDialogues.normal;
                    }

                    const randomText = dialoguePool[Math.floor(Math.random() * dialoguePool.length)];
                    showSpeechBubble(followerSection, randomText, 3000, 'follower');
                    lastDialogueTime = currentTime;
                }
            }

            // ã‚²ãƒ¼ãƒ æƒ…å ±ã¨ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã®èª¬æ˜ã‚’è¿½åŠ 
            const gameInfo = {
                title: "Cultist's Complex Idle",
                description: `
Welcome to Cultist's Complex Idle, where you manage a growing cult dedicated to the ancient ones.
Collect Source, generate Miasma, and recruit followers to summon cosmic horrors!
    `,
                shortcuts: [
                    { key: "S", description: "Jump to Summon Old One section" },
                    { key: "A", description: "Jump to Madness Table section" },
                    { key: "Space", description: "Pause/Resume game" },
                    { key: "[", description: "Buy most expensive available item" },
                    { key: "]", description: "Buy least expensive available item" }
                ],
                gameplay: {
                    resources: [
                        { name: "Source", description: "Primary resource, used for most actions" },
                        { name: "Miasma", description: "Secondary resource, used for corrupting investigators" },
                        { name: "Followers", description: "Your loyal cultists who generate resources" }
                    ],
                    features: [
                        { name: "Monsters", description: "Ancient beings that boost your production" },
                        { name: "Madness", description: "Convert investigators to your cause" },
                        { name: "Pacts", description: "Powerful contracts that reset but provide permanent bonuses" }
                    ]
                }
            };

            // ã‚²ãƒ¼ãƒ æƒ…å ±ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
            function showGameInfoModal() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay active';
                modal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">${gameInfo.title}</h2>
                <button class="close-button" onclick="this.closest('.modal-overlay').remove()">Ã—</button>
            </div>
            <div class="modal-body">
                <h3>Game Description</h3>
                <p>${gameInfo.description}</p>
                
                <h3>Keyboard Shortcuts</h3>
                <ul>
                    ${gameInfo.shortcuts.map(s => `<li><kbd>${s.key}</kbd> - ${s.description}</li>`).join('')}
                </ul>
                
                <h3>Resources</h3>
                <ul>
                    ${gameInfo.gameplay.resources.map(r => `<li><strong>${r.name}</strong>: ${r.description}</li>`).join('')}
                </ul>
                
                <h3>Features</h3>
                <ul>
                    ${gameInfo.gameplay.features.map(f => `<li><strong>${f.name}</strong>: ${f.description}</li>`).join('')}
                </ul>
            </div>
        </div>
    `;
                document.body.appendChild(modal);
            }

            function toggleStatisticsModal() {
                const modal = document.getElementById('statisticsModal');
                const statsButton = document.getElementById('statisticsButton');

                if (modal.classList.contains('active')) {
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                    modal.classList.remove('active');
                    statsButton.classList.remove('active');
                    setTimeout(() => {
                        modal.style.display = 'none';
                    }, 300); // ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³æ™‚é–“å¾Œã«éè¡¨ç¤º
                } else {
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
                    modal.style.display = 'block';
                    updateStatistics(); // çµ±è¨ˆã‚’æ›´æ–°
                    requestAnimationFrame(() => {
                        modal.classList.add('active');
                        statsButton.classList.add('active');
                    });
                }
            }

            // æ—¢å­˜ã®showStatisticsModalé–¢æ•°ã‚’ç½®ãæ›ãˆ
            function showStatisticsModal() {
                toggleStatisticsModal();
            }

            // æ—¢å­˜ã®closeStatisticsModalé–¢æ•°ã‚’ç½®ãæ›ãˆ
            function closeStatisticsModal() {
                toggleStatisticsModal();
            }

            // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§ã®é–‰ã˜ã‚‹å‡¦ç†ã‚’æ”¹å–„
            document.getElementById('statisticsModal').addEventListener('click', function (e) {
                if (e.target === this) {
                    toggleStatisticsModal();
                }
            });

            // ESCã‚­ãƒ¼ã§ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape' && document.getElementById('statisticsModal').classList.contains('active')) {
                    toggleStatisticsModal();
                }
            });

            // åˆæœŸçŠ¶æ…‹ã§éè¡¨ç¤ºã«è¨­å®š
            document.addEventListener('DOMContentLoaded', function () {
                const modal = document.getElementById('statisticsModal');
                modal.style.display = 'none';
                modal.classList.remove('active');
            });

            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã«å¿œã˜ã¦ãƒœã‚¿ãƒ³ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹é–¢æ•°
            function scrollFunction() {
                const backToTopBtn = document.getElementById("backToTopBtn");
                if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                    backToTopBtn.style.display = "block";
                } else {
                    backToTopBtn.style.display = "none";
                }
            }

            // ãƒšãƒ¼ã‚¸ãƒˆãƒƒãƒ—ã¸ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹é–¢æ•°
            function backToTop() {
                document.body.scrollTop = 0; // For Safari
                document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
            }

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
            window.onscroll = function () { scrollFunction() };

            function setCultosMiner() {
                const cultosminer = document.getElementById('cultosminer');
                cultosminer.innerHTML = `
<span class="cultosminer-color2">   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—   </span>
<span class="cultosminer-color2"> â•”â•â•</span><span class="cultosminer-color1">  â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„  </span><span class="cultosminer-color2">â•šâ•â•— </span>
<span class="cultosminer-color2">â•”â•</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•šâ•—</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2"> â–“â–“â–’â–’â–‘â–‘ ï¼£ï¼µï¼¬ï¼´ï¼¯ï¼³ ï¼­ï¼©ï¼®ï¼¥ï¼² â–‘â–‘â–’â–’â–“â–“ </span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2"> â–“â–’â–‘ </span><span class="cultosminer-color4">â•”â•â•â•â•¦â•â•â•â•¦â•â•â•â•— â•”â•â•â•â•¦â•â•â•â•¦â•â•â•â•—</span><span class="cultosminer-color2"> â–‘â–’â–“ </span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2"> â–’â–‘  </span><span class="cultosminer-color4">â•‘â–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•‘ â•‘â–“â–“â–“â•‘â–“â–“â–“â•‘â–“â–“â–“â•‘</span><span class="cultosminer-color2">  â–‘â–’ </span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2"> â–‘   </span><span class="cultosminer-color4">â•šâ•â•â•â•©â•â•â•â•©â•â•â•â• â•šâ•â•â•â•©â•â•â•â•©â•â•â•â•</span><span class="cultosminer-color2">   â–‘ </span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆâ–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•šâ•â•â•</span><span class="cultosminer-color1">â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—</span><span class="cultosminer-color2">â–‘â–‘â–‘</span><span class="cultosminer-color1">â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—</span><span class="cultosminer-color2">â•â•â•â•</span>
<span class="cultosminer-color2">  â•”â•â•</span><span class="cultosminer-color1">â–’â–’â–’â–’â–’ â–’â–’â–’â–’â–’ â–’â–’â–’â–’â–’</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–ˆ</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–’â–’â–’â–’â–’ â–’â–’â–’â–’â–’ â–’â–’â–’â–’â–’</span><span class="cultosminer-color2">â•šâ•â•—</span>
<span class="cultosminer-color2"> â•”â•</span><span class="cultosminer-color1">â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”</span><span class="cultosminer-color2">â•šâ•—</span>
<span class="cultosminer-color2">â•”â•</span><span class="cultosminer-color1">â”‚ </span><span class="cultosminer-color2">â–“â–“ </span><span class="cultosminer-color1">â”‚â”‚ </span><span class="cultosminer-color2">â–“â–“ </span><span class="cultosminer-color1">â”‚â”‚ </span><span class="cultosminer-color2">â–“â–“ </span><span class="cultosminer-color1">â”‚â”‚ </span><span class="cultosminer-color2">â–“â–“ </span><span class="cultosminer-color1">â”‚â”‚ </span><span class="cultosminer-color2">â–“â–“ </span><span class="cultosminer-color1">â”‚â”‚ </span><span class="cultosminer-color2">â–“â–“ </span><span class="cultosminer-color1">â”‚â”‚ </span><span class="cultosminer-color2">â–“â–“ </span><span class="cultosminer-color1">â”‚â”‚ </span><span class="cultosminer-color2">â–“â–“ </span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2">â•šâ•—</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1">â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜</span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1">â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”</span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1">â”‚ </span><span class="cultosminer-color2">â–‘â–’â–“â–ˆ </span><span class="cultosminer-color1">â”‚â”‚ </span><span class="cultosminer-color2">â–‘â–’â–“â–ˆ </span><span class="cultosminer-color1">â”‚â”‚ </span><span class="cultosminer-color2">â–‘â–’â–“â–ˆ </span><span class="cultosminer-color1">â”‚â”‚ </span><span class="cultosminer-color2">â–‘â–’â–“â–ˆ </span><span class="cultosminer-color1">â”‚â”‚ </span><span class="cultosminer-color2">â–‘â–’â–“â–ˆ </span><span class="cultosminer-color1">â”‚â”‚ </span><span class="cultosminer-color2">â–‘â–’â–“â–ˆ </span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1">â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜</span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•šâ•â•â•â•</span><span class="cultosminer-color1">â–’â–“â–ˆâ–“â–’â–‘</span><span class="cultosminer-color2">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span><span class="cultosminer-color1">â–‘â–’â–“â–ˆâ–“â–’</span><span class="cultosminer-color2">â•â•â•â•â•</span>
<span class="cultosminer-color2">     â•šâ•â•â• </span><span class="cultosminer-color1">â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€ </span><span class="cultosminer-color2">â•šâ•â•â•     </span>
`;
            }

            function adjustFontSize(element, maxSize, minSize) {
                let fontSize = maxSize;
                element.style.fontSize = fontSize + 'px';
                while (element.scrollWidth > element.offsetWidth && fontSize > minSize) {
                    fontSize--;
                    element.style.fontSize = fontSize + 'px';
                }
            }

            function generateCultosMiner() {
                const miningStatus = canUseCultosMiner();
                const isActive = isMiningActive && miningStatus.canMine;

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ±ºå®šï¼ˆæ™‚é–“ãƒ™ãƒ¼ã‚¹ï¼‰
                const frame = Math.floor(Date.now() / 200) % 4;

                // å‹•çš„ãªãƒ‘ãƒ¼ãƒ„ã®ç”Ÿæˆ
                const dynamicParts = getDynamicParts(frame, isActive);

                return `
<div class="cultosminer ${isActive ? 'active' : 'inactive'}">
    ${getCultosMinerArt(dynamicParts, isActive)} 
</div>`;
            }

            function getDynamicParts(frame, isActive) {
                if (!isActive) {
                    return {
                        topBorder: 'â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„',
                        centerDisplay: 'â•‘â–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•‘ â•‘â–“â–“â–“â•‘â–“â–“â–“â•‘â–“â–“â–“â•‘',
                        bottomBorder: 'â•šâ•â•â•â•©â•â•â•â•©â•â•â•â• â•šâ•â•â•â•©â•â•â•â•©â•â•â•â•',
                        colors: {
                            top: '#666',
                            center: '#444',
                            bottom: '#333'
                        }
                    };
                }

                const animations = {
                    topBorder: [
                        { text: 'â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„', color: '#ff6b6b' },
                        { text: 'â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€â–„â–€', color: '#4ecdc4' },
                        { text: 'â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆ', color: '#ffe66d' },
                        { text: 'â–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€â–ˆâ–€', color: '#95e1d3' }
                    ],
                    centerDisplay: [
                        { text: 'â•‘â–“â–’â–‘â•‘â–“â–’â–‘â•‘â–“â–’â–‘â•‘ â•‘â–‘â–’â–“â•‘â–‘â–’â–“â•‘â–‘â–’â–“â•‘', color: '#a8e6cf' },
                        { text: 'â•‘â–‘â–’â–“â•‘â–‘â–’â–“â•‘â–‘â–’â–“â•‘ â•‘â–“â–’â–‘â•‘â–“â–’â–‘â•‘â–“â–’â–‘â•‘', color: '#dcedc1' },
                        { text: 'â•‘â–’â–“â–‘â•‘â–’â–“â–‘â•‘â–’â–“â–‘â•‘ â•‘â–‘â–“â–’â•‘â–‘â–“â–’â•‘â–‘â–“â–’â•‘', color: '#ffd3b6' },
                        { text: 'â•‘â–“â–‘â–’â•‘â–“â–‘â–’â•‘â–“â–‘â–’â•‘ â•‘â–’â–‘â–“â•‘â–’â–‘â–“â•‘â–’â–‘â–“â•‘', color: '#ffaaa5' }
                    ],
                    bottomBorder: [
                        { text: 'â•šâ•â–’â•â•©â•â–’â•â•©â•â–’â•â• â•šâ•â–’â•â•©â•â–’â•â•©â•â–’â•â•', color: '#48dbfb' },
                        { text: 'â•šâ–’â•â–’â•©â–’â•â–’â•©â–’â•â–’â• â•šâ–’â•â–’â•©â–’â•â–’â•©â–’â•â–’â•', color: '#ff9ff3' },
                        { text: 'â•šâ•â–“â•â•©â•â–“â•â•©â•â–“â•â• â•šâ•â–“â•â•©â•â–“â•â•©â•â–“â•â•', color: '#00d2d3' },
                        { text: 'â•šâ–“â•â–“â•©â–“â•â–“â•©â–“â•â–“â• â•šâ–“â•â–“â•©â–“â•â–“â•©â–“â•â–“â•', color: '#54a0ff' }
                    ],
                    // è¿½åŠ ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ã®è‰²
                    glowColors: [
                        '#ff6b6b88',
                        '#4ecdc488',
                        '#ffe66d88',
                        '#95e1d388'
                    ]
                };

                const currentFrame = animations.topBorder[frame];
                const centerFrame = animations.centerDisplay[frame];
                const bottomFrame = animations.bottomBorder[frame];
                const glowColor = animations.glowColors[frame];

                return {
                    topBorder: currentFrame.text,
                    centerDisplay: centerFrame.text,
                    bottomBorder: bottomFrame.text,
                    colors: {
                        top: currentFrame.color,
                        center: centerFrame.color,
                        bottom: bottomFrame.color,
                        glow: glowColor
                    }
                };
            }
            function getCultosMinerArt(parts, isActive) {
                const titleColor = isActive ? '#00ffff' : '#ff0000';
                // ä¸‹éƒ¨ãƒœã‚¿ãƒ³ç”¨ã®è‰²ã‚’å®šç¾©
                const buttonColors = isActive ? {
                    border: '#00ff66',      // ã‚µã‚¤ãƒãƒ¼ã‚°ãƒªãƒ¼ãƒ³ï¼ˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ï¼‰
                    fill: '#00994d',        // æš—ã‚ã®ã‚µã‚¤ãƒãƒ¼ã‚°ãƒªãƒ¼ãƒ³ï¼ˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ï¼‰
                    glow: '#00ff6633'       // ã‚°ãƒ­ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ï¼‰
                } : {
                    border: '#333333',      // æš—ã„ã‚°ãƒ¬ãƒ¼ï¼ˆéã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ï¼‰
                    fill: '#1a1a1a',        // ã‚ˆã‚Šæš—ã„ã‚°ãƒ¬ãƒ¼ï¼ˆéã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ï¼‰
                    glow: 'transparent'     // ã‚°ãƒ­ãƒ¼ãªã—ï¼ˆéã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ï¼‰
                };
                return `<div class="cultosminer-frame" style="--glow-color: ${parts.colors.glow}">
<span class="cultosminer-color2">   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—   </span>
<span class="cultosminer-color2"> â•”â•â•</span><span style="color: ${parts.colors.top}">${parts.topBorder}</span><span class="cultosminer-color2">â•šâ•â•— </span>
<span class="cultosminer-color2">â•”â•</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•šâ•—</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â”‚</span><span style="color: ${titleColor}"> â–“â–“â–’â–’â–‘â–‘ ï¼£ï¼µï¼¬ï¼´ï¼¯ï¼³ ï¼­ï¼©ï¼®ï¼¥ï¼² â–‘â–‘â–’â–’â–“â–“ </span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2"> â–“â–’â–‘ </span><span style="color: ${parts.colors.center}">${parts.centerDisplay}</span><span class="cultosminer-color2"> â–‘â–’â–“ </span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2"> â–‘   </span><span style="color: ${parts.colors.bottom}">${parts.bottomBorder}</span><span class="cultosminer-color2">   â–‘ </span><span class="cultosminer-color1">â”‚</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆ</span><span class="cultosminer-color2">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span><span class="cultosminer-color1">â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span class="cultosminer-color1"> â–â–ˆâ–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–ˆâ–Œ </span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•šâ•â•â•</span><span class="cultosminer-color1">â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—</span><span class="cultosminer-color2">â–‘â–‘â–‘</span><span class="cultosminer-color1">â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—</span><span class="cultosminer-color2">â•â•â•â•</span>
<span class="cultosminer-color2">  â•”â•â•</span><span style="color: ${buttonColors.border}">â–’â–’â–’â–’â–’ â–’â–’â–’â–’â–’ â–’â–’â–’â–’â–’</span><span class="cultosminer-color2">â–‘</span><span class="cultosminer-color1">â–ˆ</span><span class="cultosminer-color2">â–‘</span><span style="color: ${buttonColors.border}">â–’â–’â–’â–’â–’ â–’â–’â–’â–’â–’ â–’â–’â–’â–’â–’</span><span class="cultosminer-color2">â•šâ•â•—</span>
<span class="cultosminer-color2"> â•”â•</span><span style="color: ${buttonColors.border}">â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”</span><span class="cultosminer-color2">â•šâ•—</span>
<span class="cultosminer-color2">â•”â•</span><span style="color: ${buttonColors.border}">â”‚ </span><span style="color: ${buttonColors.fill}">â–“â–“ </span><span style="color: ${buttonColors.border}">â”‚â”‚ </span><span style="color: ${buttonColors.fill}">â–“â–“ </span><span style="color: ${buttonColors.border}">â”‚â”‚ </span><span style="color: ${buttonColors.fill}">â–“â–“ </span><span style="color: ${buttonColors.border}">â”‚â”‚ </span><span style="color: ${buttonColors.fill}">â–“â–“ </span><span style="color: ${buttonColors.border}">â”‚â”‚ </span><span style="color: ${buttonColors.fill}">â–“â–“ </span><span style="color: ${buttonColors.border}">â”‚â”‚ </span><span style="color: ${buttonColors.fill}">â–“â–“ </span><span style="color: ${buttonColors.border}">â”‚â”‚ </span><span style="color: ${buttonColors.fill}">â–“â–“ </span><span style="color: ${buttonColors.border}">â”‚â”‚ </span><span style="color: ${buttonColors.fill}">â–“â–“ </span><span style="color: ${buttonColors.border}">â”‚</span><span class="cultosminer-color2">â•šâ•—</span>
<span class="cultosminer-color2">â•‘</span><span style="color: ${buttonColors.border}">â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜</span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span style="color: ${buttonColors.border}">â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”</span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span style="color: ${buttonColors.border}">â”‚ </span><span style="color: ${buttonColors.fill}">â–‘â–’â–“â–ˆ </span><span style="color: ${buttonColors.border}">â”‚â”‚ </span><span style="color: ${buttonColors.fill}">â–‘â–’â–“â–ˆ </span><span style="color: ${buttonColors.border}">â”‚â”‚ </span><span style="color: ${buttonColors.fill}">â–‘â–’â–“â–ˆ </span><span style="color: ${buttonColors.border}">â”‚â”‚ </span><span style="color: ${buttonColors.fill}">â–‘â–’â–“â–ˆ </span><span style="color: ${buttonColors.border}">â”‚â”‚ </span><span style="color: ${buttonColors.fill}">â–‘â–’â–“â–ˆ </span><span style="color: ${buttonColors.border}">â”‚â”‚ </span><span style="color: ${buttonColors.fill}">â–‘â–’â–“â–ˆ </span><span style="color: ${buttonColors.border}">â”‚</span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•‘</span><span style="color: ${buttonColors.border}">â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜</span><span class="cultosminer-color2">â•‘</span>
<span class="cultosminer-color2">â•šâ•â•â•â•</span><span style="color: ${buttonColors.fill}">â–’â–“â–ˆâ–“â–’â–‘</span><span class="cultosminer-color2">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span><span style="color: ${buttonColors.fill}">â–‘â–’â–“â–ˆâ–“â–’</span><span class="cultosminer-color2">â•â•â•â•â•</span>
<span class="cultosminer-color2">     â•šâ•â•â• </span><span style="color: ${buttonColors.border}">â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€ </span><span class="cultosminer-color2">â•šâ•â•â•     </span></div>`;
            }

            function getBaseColor1() {
                const totalMonsters = Object.values(gameState.monsters).reduce((sum, monster) => sum + monster.count, 0);
                if (totalMonsters > 1000) return '#ff3300';  // æ·±ã„æ©™è‰²
                if (totalMonsters > 500) return '#cc2900';   // æš—ã‚ã®èµ¤æ©™
                if (totalMonsters > 100) return '#991f00';   // ã•ã‚‰ã«æš—ã„èµ¤æ©™
                return '#2b2b2b';                            // ãƒ€ãƒ¼ã‚¯ã‚°ãƒ¬ãƒ¼
            }

            function getBaseColor2() {
                const totalUpgrades = gameState.upgrades.length;
                if (totalUpgrades > 15) return '#00ff66';    // ã‚µã‚¤ãƒãƒ¼ã‚°ãƒªãƒ¼ãƒ³
                if (totalUpgrades > 10) return '#00cc52';    // æš—ã‚ã®ã‚µã‚¤ãƒãƒ¼ã‚°ãƒªãƒ¼ãƒ³
                if (totalUpgrades > 5) return '#00994d';     // ã•ã‚‰ã«æš—ã„ã‚µã‚¤ãƒãƒ¼ã‚°ãƒªãƒ¼ãƒ³
                return '#1a1a1a';                            // ã‚ˆã‚Šæš—ã„ã‚°ãƒ¬ãƒ¼
            }

            function getAccentColor1() {
                const cultosRate = gameState.cultosRate || 0;
                if (cultosRate > 0.1) return '#66ffff';      // æ˜ã‚‹ã„çœŸç©ºç®¡ãƒ–ãƒ«ãƒ¼
                if (cultosRate > 0.05) return '#33ffff';     // ä¸­é–“ã®çœŸç©ºç®¡ãƒ–ãƒ«ãƒ¼
                if (cultosRate > 0.01) return '#00ffff';     // æ¨™æº–ã®çœŸç©ºç®¡ãƒ–ãƒ«ãƒ¼
                return '#404040';                            // ãƒŸãƒ‡ã‚£ã‚¢ãƒ ã‚°ãƒ¬ãƒ¼
            }

            function getAccentColor2() {
                const miasmaRate = gameState.miasmaRate || 0;
                if (miasmaRate > 1000) return '#ff9933';     // çœŸç©ºç®¡ã‚ªãƒ¬ãƒ³ã‚¸
                if (miasmaRate > 500) return '#ff8000';      // æš—ã‚ã®çœŸç©ºç®¡ã‚ªãƒ¬ãƒ³ã‚¸
                if (miasmaRate > 100) return '#cc6600';      // ã•ã‚‰ã«æš—ã„çœŸç©ºç®¡ã‚ªãƒ¬ãƒ³ã‚¸
                return '#333333';                            // ãƒ€ãƒ¼ã‚¯ã‚°ãƒ¬ãƒ¼
            }
            function canUseCultosMiner() {
                // å¿…è¦ãªã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ç¢ºèª
                const hasRequiredUpgrade = gameState.upgrades.includes('Hiroshi Sakamoto`s Paper');

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®è¦ä»¶ç¢ºèª
                const hasRequiredMonsters =
                    (gameState.monsters['Shoggoth']?.count >= 10);

                // ã™ã¹ã¦ã®æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹ç¢ºèª
                const isUnlocked = hasRequiredUpgrade && hasRequiredMonsters;

                // ãƒªã‚½ãƒ¼ã‚¹ã®ãƒã‚§ãƒƒã‚¯ï¼ˆsource ã¨ miasma ãŒå¿…è¦ï¼‰
                const canAffordPower = gameState.source >= 1 && gameState.miasma >= 1;

                // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã¨ãƒªã‚½ãƒ¼ã‚¹çŠ¶æ…‹ã‚’è¿”ã™
                return {
                    isUnlocked,
                    canAffordPower,
                    canMine: isUnlocked && canAffordPower
                };
            }

            function updateCultosMiner() {
                const cultosminer = document.getElementById('cultosminer');
                const cultosColumn = document.getElementById('cultosColumn');
                if (!cultosminer || !cultosColumn) return;

                // ãƒã‚¤ãƒ‹ãƒ³ã‚°çŠ¶æ…‹ã®ç¢ºèª
                const miningStatus = canUseCultosMiner();

                // CultosMinerã®è¡¨ç¤ºçŠ¶æ…‹ã‚’æ›´æ–°
                if (!miningStatus.isUnlocked) {
                    cultosminer.classList.add('cultosminer-disabled');
                    cultosColumn.classList.add('cultos-hidden');
                } else {
                    cultosminer.classList.remove('cultosminer-disabled');
                    cultosColumn.classList.remove('cultos-hidden');
                }

                // ãƒã‚¤ãƒ‹ãƒ³ã‚°å¯èƒ½ãªå ´åˆã®å‡¦ç†
                if (miningStatus.canMine) {
                    if (!cultosminer.classList.contains('active')) {
                        cultosminer.classList.add('active');
                        logAction("Cultos Miner activated");
                    }
                    // ãƒã‚¤ãƒ‹ãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆã®æ›´æ–°
                    updateCultosRate();
                } else {
                    cultosminer.classList.remove('active');
                }

                // ã‚¨ãƒ³ãƒ–ãƒ¬ãƒ ã®æ›´æ–°
                const newCultosMinerContent = generateCultosMiner();
                if (cultosminer.innerHTML !== newCultosMinerContent) {
                    cultosminer.innerHTML = newCultosMinerContent;
                }
                updateMiningIndicator();
            }

            function updateCultosRate() {
                if (!gameState.hasOwnProperty('cultosRate')) {
                    gameState.cultosRate = 0;
                }

                const miningStatus = canUseCultosMiner();
                if (miningStatus.canMine) {
                    // ãƒã‚¤ãƒ‹ãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆã®è¨ˆç®—ï¼ˆæ—¢å­˜ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ä½¿ç”¨ï¼‰
                    const totalMonsters = Object.values(gameState.monsters)
                        .reduce((sum, monster) => sum + monster.count, 0);
                    const baseRate = 1 / (totalMonsters + 10);
                    const miasmaBoost = 1 + gameState.miasma / 10000;
                    const randomFactor = 0.9 + Math.random() * 0.2;

                    gameState.cultosRate = baseRate * miasmaBoost * randomFactor;
                } else {
                    gameState.cultosRate = 0;
                }

                // è¡¨ç¤ºã®æ›´æ–°
                document.getElementById('cultosHashRate').textContent =
                    formatNumber(gameState.cultosRate, 3);
            }

            function updateCultosVisibility() {
                const cultosColumn = document.getElementById('cultosColumn');
                if (!cultosColumn) return;

                const isCultosUnlocked = checkUnlockCondition('resources', 'cultos');
                cultosColumn.classList.toggle('cultos-hidden', !isCultosUnlocked);
            }


            // ãƒã‚¤ãƒ‹ãƒ³ã‚°ã®çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹å¤‰æ•°ã‚’è¿½åŠ 
            let isMiningActive = false;

            // CultosMinerã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
            document.getElementById('cultosminer').addEventListener('click', toggleMining);

            // toggleMiningé–¢æ•°ã‚’ä¿®æ­£
            function toggleMining() {
                isMiningActive = !isMiningActive;

                // ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã¨ UI ã®çŠ¶æ…‹ã‚’æ›´æ–°
                updateMiningIndicator();
                updateMiningUI(isMiningActive);

                // ãƒã‚¤ãƒ‹ãƒ³ã‚°çŠ¶æ…‹ã‚’ä¿å­˜
                localStorage.setItem('miningState', isMiningActive);
            }

            // æ–°ã—ã„é–¢æ•°: ãƒã‚¤ãƒ‹ãƒ³ã‚°UIã®æ›´æ–°ã‚’ä¸€å…ƒç®¡ç†
            function updateMiningUI(isActive) {
                const button = document.getElementById('toggleMining');
                const cultosSymbol = document.querySelector('.cultos-symbol');
                const sourceConsumptionRate = document.getElementById('sourceConsumptionRate');
                const miasmaConsumptionRate = document.getElementById('miasmaConsumptionRate');

                if (button) {
                    button.textContent = isActive ? 'Stop Mining' : 'Start Mining';
                }

                if (cultosSymbol) {
                    cultosSymbol.classList.toggle('active', isActive);
                    cultosSymbol.classList.toggle('inactive', !isActive);
                }

                if (sourceConsumptionRate) {
                    sourceConsumptionRate.classList.toggle('inactive', !isActive);
                }

                if (miasmaConsumptionRate) {
                    miasmaConsumptionRate.classList.toggle('inactive', !isActive);
                }
            }

            function updateMiningIndicator() {
                const indicator = document.getElementById('miningIndicator');
                if (!indicator) return;

                const miningStatus = canUseCultosMiner();

                if (isMiningActive && miningStatus.canMine) {
                    indicator.classList.add('active');
                    indicator.classList.remove('inactive');
                } else {
                    indicator.classList.remove('active');
                    indicator.classList.add('inactive');
                }
            }

            // æ—¢å­˜ã®åˆæœŸåŒ–å‡¦ç†ã‚’æ‹¡å¼µ
            document.addEventListener('DOMContentLoaded', function () {
                const savedMiningState = localStorage.getItem('miningState');
                if (savedMiningState === 'true') {
                    toggleMining();
                } else {
                    // åˆæœŸçŠ¶æ…‹ã§ã‚‚ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’æ›´æ–°
                    updateMiningIndicator();
                }

                document.getElementById('toggleMining').addEventListener('click', toggleMining);
            });

            function calculateCultosRate(deltaTime) {
                const miningStatus = canUseCultosMiner();

                if (!isMiningActive || !miningStatus.canMine) {
                    resetMiningRates();
                    updateConsumptionRates(0, 0, false);

                    // ãƒã‚¤ãƒ‹ãƒ³ã‚°ãŒåœæ­¢ã—ãŸéš›ã«ãƒœã‚¿ãƒ³ã¨UIã®çŠ¶æ…‹ã‚’æ›´æ–°
                    if (isMiningActive) {
                        isMiningActive = false;
                        updateMiningUI(false);
                        updateMiningIndicator();  // ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚‚æ›´æ–°
                        localStorage.setItem('miningState', 'false');
                        logAction('Cultos mining stopped: Conditions not met');
                    }

                    return 0;
                }

                // åŸºæœ¬ãƒ¬ãƒ¼ãƒˆã¨ã‚³ã‚¹ãƒˆã®è¨ˆç®—
                const baseHashRate = 0.000001;
                const totalMonsters = Object.values(gameState.monsters).reduce((sum, monster) => sum + monster.count, 0);
                const monsterBoost = 1 + (totalMonsters * 0.001);
                const miasmaBoost = 1 + (Math.log10(gameState.miasma + 1) * 0.01);
                const upgradeBoost = gameState.upgrades.includes('Hiroshi Sakamoto`s Paper') ? 1.5 : 1;

                // æ™‚é–“ãƒ™ãƒ¼ã‚¹ã®å¤‰å‹•ã‚’è¿½åŠ ï¼ˆ1æ™‚é–“å‘¨æœŸï¼‰
                const hourInSeconds = 3600;
                const currentTime = Date.now() / 1000; // ç§’å˜ä½ã«å¤‰æ›
                const timePhase = (currentTime % hourInSeconds) / hourInSeconds; // 0-1ã®å€¤

                // ã‚µã‚¤ãƒ³æ³¢ã«ã‚ˆã‚‹ç·©ã‚„ã‹ãªå¤‰å‹•ï¼ˆæŒ¯å¹…20%ï¼‰
                const fluctuation = 1 + (0.2 * Math.sin(2 * Math.PI * timePhase));

                // ãƒã‚¤ã‚ºã‚’è¿½åŠ ï¼ˆæœ€å¤§5%ã®å¾®ç´°ãªå¤‰å‹•ï¼‰
                const noise = 1 + (Math.random() * 0.05 - 0.025);

                // æœ€çµ‚çš„ãªãƒãƒƒã‚·ãƒ¥ãƒ¬ãƒ¼ãƒˆè¨ˆç®—
                const hashRate = baseHashRate * monsterBoost * upgradeBoost * fluctuation * noise;

                // ãƒªã‚½ãƒ¼ã‚¹ã‚³ã‚¹ãƒˆã®è¨ˆç®—ã¨æ¶ˆè²»
                const currentCost = {
                    source: hashRate * deltaTime * 100000000,
                    miasma: hashRate * deltaTime * 50000000
                };

                if (gameState.source < currentCost.source || gameState.miasma < currentCost.miasma) {
                    // ãƒªã‚½ãƒ¼ã‚¹ä¸è¶³æ™‚ã®ãƒã‚¤ãƒ‹ãƒ³ã‚°åœæ­¢å‡¦ç†
                    isMiningActive = false;
                    resetMiningRates();
                    updateConsumptionRates(0, 0, false);
                    updateMiningUI(false);
                    updateMiningIndicator();
                    localStorage.setItem('miningState', 'false');
                    logAction('Cultos mining stopped: Insufficient resources');
                    return 0;
                }

                // ãƒªã‚½ãƒ¼ã‚¹æ¶ˆè²»
                gameState.source -= currentCost.source;
                gameState.miasma -= currentCost.miasma;

                // ãƒ¬ãƒ¼ãƒˆè¡¨ç¤ºã®æ›´æ–°
                const sourceRate = currentCost.source / deltaTime;
                const miasmaRate = currentCost.miasma / deltaTime;
                updateConsumptionRates(sourceRate, miasmaRate, true);

                return hashRate;
            }

            // Cultosãƒœãƒ¼ãƒŠã‚¹ã®è¨ˆç®—é–¢æ•°
            function calculateCultosBonus() {
                if (!gameState.cultos || !gameState.unlockedContent.resources.has('cultos')) {
                    return 1;
                }

                // åŸºæœ¬: 1 + (1 Cultos ã«ã¤ã0.1%ã®ãƒœãƒ¼ãƒŠã‚¹ï¼ˆä¸Šé™50%ï¼‰)
                const baseBonus = Math.min(gameState.cultos * 0.001, 0.5);

                // Cultosã®æ¡æ•°ã«ã‚ˆã‚‹ãƒœãƒ¼ãƒŠã‚¹
                // 10, 100, 1000... Cultosã”ã¨ã«è¿½åŠ 5%ï¼ˆä¸Šé™30%ï¼‰
                const magnitude = gameState.cultos > 0 ? Math.floor(Math.log10(gameState.cultos)) : 0;
                const magnitudeBonus = Math.min(magnitude * 0.05, 0.3);

                // FolloweråŠ¹ç‡ãƒœãƒ¼ãƒŠã‚¹
                // 1000 Cultosã”ã¨ã«1%ã®ãƒœãƒ¼ãƒŠã‚¹ï¼ˆä¸Šé™20%ï¼‰
                const followerBonus = Math.min(Math.floor(gameState.cultos / 1000) * 0.01, 0.2);

                // åˆè¨ˆãƒœãƒ¼ãƒŠã‚¹ï¼ˆ1 + ãƒœãƒ¼ãƒŠã‚¹å€¤ï¼‰
                return 1 + baseBonus + magnitudeBonus + followerBonus;
            }

            // ãƒãƒƒã‚·ãƒ¥ãƒ¬ãƒ¼ãƒˆè¡¨ç¤ºã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆé–¢æ•°ã‚‚æ›´æ–°
            function formatHashRate(hashRate) {
                if (hashRate === 0) return "0 H/s";

                const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s'];
                const base = 1000;
                let unitIndex = 0;
                let scaledRate = hashRate;

                while (scaledRate >= base && unitIndex < units.length - 1) {
                    scaledRate /= base;
                    unitIndex++;
                }

                // å¤‰å‹•ã®æ¿€ã—ã•ã«å¿œã˜ã¦å°æ•°ç‚¹ä»¥ä¸‹ã®æ¡æ•°ã‚’èª¿æ•´
                const precision = scaledRate < 10 ? 3 : scaledRate < 100 ? 2 : 1;
                return `${scaledRate.toFixed(precision)} ${units[unitIndex]}`;
            }

            function resetMiningRates() {
                const cultosminer = document.getElementById('cultosminer');
                const cultosSymbol = document.querySelector('.cultos-symbol');

                if (cultosminer) {
                    cultosminer.classList.remove('active');
                    cultosminer.classList.add('inactive');
                }

                if (cultosSymbol) {
                    cultosSymbol.classList.remove('active');
                    cultosSymbol.classList.add('inactive');
                }
            }

            // æ¶ˆè²»ãƒ¬ãƒ¼ãƒˆè¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
            function updateConsumptionRates(sourceRate, miasmaRate, isActive) {
                const sourceRateDisplay = document.getElementById('sourceConsumptionRate');
                const miasmaRateDisplay = document.getElementById('miasmaConsumptionRate');

                if (sourceRateDisplay) {
                    sourceRateDisplay.textContent = `${formatNumber(sourceRate, 3)}/s`;
                    sourceRateDisplay.className = `rate-value ${isActive ? 'active' : 'inactive'}`;
                }

                if (miasmaRateDisplay) {
                    miasmaRateDisplay.textContent = `${formatNumber(miasmaRate, 3)}/s`;
                    miasmaRateDisplay.className = `rate-value ${isActive ? 'active' : 'inactive'}`;
                }
            }

            function updateCultosMinerAppearance() {
                const cultosSymbol = document.querySelector('.cultos-symbol');
                const cultosminer = document.getElementById('cultosminer');
                const miningStatus = canUseCultosMiner();

                // ãƒã‚¤ãƒ‹ãƒ³ã‚°çŠ¶æ…‹ã¨ãƒªã‚½ãƒ¼ã‚¹çŠ¶æ…‹ã«åŸºã¥ã„ã¦è¡¨ç¤ºã‚’æ›´æ–°
                const isDisabled = !miningStatus.canMine || !isMiningActive;

                if (cultosSymbol) {
                    cultosSymbol.classList.remove('active', 'inactive');
                    cultosSymbol.classList.add(isDisabled ? 'inactive' : 'active');
                }

                if (cultosminer) {
                    if (isDisabled) {
                        cultosminer.classList.add('cultosminer-disabled');
                        cultosminer.classList.remove('active');
                    } else {
                        cultosminer.classList.remove('cultosminer-disabled');
                        cultosminer.classList.add('active');
                    }
                }

                // ãƒã‚¤ãƒ‹ãƒ³ã‚°çŠ¶æ…‹ã®è¡¨ç¤ºã‚’æ›´æ–°
                const sourceRateDisplay = document.getElementById('sourceConsumptionRate');
                const miasmaRateDisplay = document.getElementById('miasmaConsumptionRate');
                const cultosHashRate = document.getElementById('cultosHashRate');

                if (sourceRateDisplay) sourceRateDisplay.className = `rate-value ${isDisabled ? 'inactive' : 'active'}`;
                if (miasmaRateDisplay) miasmaRateDisplay.className = `rate-value ${isDisabled ? 'inactive' : 'active'}`;
                if (cultosHashRate) cultosHashRate.className = `hash-rate ${isDisabled ? 'inactive' : 'active'}`;
            }

            function hasEnoughResources(cost) {
                return gameState.source >= cost.source && gameState.miasma >= cost.miasma;
            }

            function consumeResources(cost) {
                gameState.source -= cost.source;
                gameState.miasma -= cost.miasma;
            }

            function updateRates(hashRate, cost) {
                gameState.cultosRate = hashRate;
                gameState.sourceRate = -cost.source;
                gameState.miasmaRate = -cost.miasma;
            }

            function resetMiningRates() {
                gameState.cultosRate = 0;
                gameState.sourceRate = 0;
                gameState.miasmaRate = 0;
            }

            // ãƒãƒƒã‚·ãƒ¥ãƒ¬ãƒ¼ãƒˆã®è¡¨ç¤ºã‚’æ•´å½¢ã™ã‚‹é–¢æ•°
            function formatHashRate(hashRate) {
                if (hashRate === 0) return "0";

                const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s'];
                const base = 1000;
                let unitIndex = 0;
                let scaledRate = hashRate;

                while (scaledRate >= base && unitIndex < units.length - 1) {
                    scaledRate /= base;
                    unitIndex++;
                }

                // å°æ•°ç‚¹ä»¥ä¸‹3æ¡ã¾ã§è¡¨ç¤ºï¼ˆä¸è¦ãª0ã¯å‰Šé™¤ï¼‰
                return scaledRate.toPrecision(5).replace(/\.?0+$/, '') + ' ' + units[unitIndex];
            }


            const additionalStyles = `
.simple #cultosminer {
    font-size: 0.9em;
    display: inline-flex;
    align-items: center;
    gap: 5px;
    padding: 2px 5px;
}

.simple #eldritchDrum {
    font-size: 0.9em;
    display: inline-flex;
    align-items: center;
    gap: 5px;
    padding: 2px 5px;
}

#resourceDisplay.simple .cultos-symbol,
#resourceDisplay.simple #eldritchDrum {
    margin-left: 10px;
}

#resourceDisplay.simple .consumption-rate-container {
    font-size: 0.8em;
}

.simple .cultosminer-color1,
.simple .cultosminer-color2,
.simple .cultosminer-color3,
.simple .cultosminer-color4 {
    display: inline-block;
    vertical-align: middle;
}
`;

            const drumStyles = `
.drum-container {
    display: flex;
    align-items: flex-start;
    gap: 20px;
}

#eldritchDrum {
    font-family: 'Courier New', monospace;
    white-space: pre;
    display: inline-block;
    margin-left: 20px;
    color: #e0e0e0;
    line-height: 1.2;
}

#eldritchDrum.simple {
    font-size: 0.9em;
    line-height: 1;
}

#eldritchDrum.simple .drum-display {
    display: inline-flex;
    align-items: center;
    gap: 10px;
}

#eldritchDrum.simple .drum-frame {
    display: none;
}

#drumControls {
    margin-top: 5px;
    display: flex;
    gap: 10px;
}

#drumControls button {
    background-color: transparent;
    color: #e0e0e0;
    border: 1px solid #4CAF50;
    padding: 4px 8px;
    cursor: pointer;
    border-radius: 3px;
    font-size: 11px;
    transition: all 0.3s ease;
}

#drumControls button:hover:not(:disabled) {
    background-color: rgba(76, 175, 80, 0.2);
}
`;


            function addDrumStyles() {
                const styleSheet = document.createElement('style');
                styleSheet.textContent = drumStyles;
                document.head.appendChild(styleSheet);
            }

            // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®ç®¡ç†
            let drumState = {
                symbols: [
                    { id: 'NORMAL', char: 'â—Š', probability: 0.3, payoutMultiplier: 1.5 },
                    { id: 'MINOR', char: 'âœ§', probability: 0.25, payoutMultiplier: 2 },
                    { id: 'MEDIUM', char: 'Û', probability: 0.2, payoutMultiplier: 3 },
                    { id: 'MAJOR', char: 'â˜†', probability: 0.15, payoutMultiplier: 5 },
                    { id: 'SPECIAL', char: 'âœ´', probability: 0.07, payoutMultiplier: 8 },
                    { id: 'JACKPOT', char: 'â˜¯', probability: 0.03, payoutMultiplier: 20 }
                ],
                reels: [
                    ['â—Š', 'âœ§', 'Û'],  // ç¾åœ¨ã®ãƒªãƒ¼ãƒ«çŠ¶æ…‹
                    ['â˜†', 'âœ´', 'â˜¯'],
                    ['Û', 'â—Š', 'âœ§']
                ],
                phase: 'NORMAL',
                lampStates: [false, false, false],
                currentBet: 50,
                lastWin: 0,
                autoSpinEnabled: false,
                resonanceGauge: 0,
                setting: 1,
                lastChangeTime: Date.now(),
                spinning: false
            };

            // ãƒ•ãƒ¬ãƒ¼ãƒ ã®æç”»ãƒ‘ã‚¿ãƒ¼ãƒ³
            const framePatterns = {
                NORMAL: {
                    top: "â•­â”â”â”â”â”â”â”â”â”â”â”â•®",
                    middle: "â”‚           â”‚",
                    bottom: "â•°â”â”â”â”â”â”â”â”â”â”â”â•¯"
                },
                RESONATING: {
                    top: "â•­â‰‹â‰‹â‰‹â‰‹â‰‹â‰‹â‰‹â‰‹â‰‹â‰‹â‰‹â•®",
                    middle: "â”‚           â”‚",
                    bottom: "â•°â‰‹â‰‹â‰‹â‰‹â‰‹â‰‹â‰‹â‰‹â‰‹â‰‹â‰‹â•¯"
                }
            };

            function renderDrum() {
                const isSimple = document.getElementById('resourceDisplay').classList.contains('simple');
                const frame = framePatterns[drumState.phase];
                const lamps = drumState.lampStates.map(s => s ? '[â—]' : '[â—‹]').join('');

                if (isSimple) {
                    // ãƒ†ã‚­ã‚¹ãƒˆã®ã¿ã‚’è¿”ã™
                    return `[DRUM] BET: ${drumState.currentBet}Â©ï¸ ${drumState.spinning ? 'SPINNING' : `LAST: ${drumState.lastWin}Â©ï¸`}`;
                }

                // é€šå¸¸è¡¨ç¤º
                return `
${lamps} PHASE: [${drumState.phase}]
${frame.top}  BET: ${drumState.currentBet} Â©ï¸
â”‚ ${drumState.reels[0].join('  ')} â”‚  WIN: ${drumState.lastWin} Â©ï¸
â”‚ ${drumState.reels[1].join('  ')} â”‚
â”‚ ${drumState.reels[2].join('  ')} â”‚
${frame.bottom}
[AUTO: ${drumState.autoSpinEnabled ? 'ON' : 'OFF'}] [MAX: 1000]`;
            }

            // ãƒªãƒ¼ãƒ«ã®ã‚¹ãƒ”ãƒ³å‡¦ç†
            function spinReels() {
                if (drumState.spinning) return;
                if (gameState.cultos < drumState.currentBet) return;

                drumState.spinning = true;
                gameState.cultos -= drumState.currentBet;

                // ã‚¹ãƒ”ãƒ³ä¸­ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                let spinFrames = 0;
                const spinInterval = setInterval(() => {
                    // ãƒ©ãƒ³ãƒ€ãƒ ãªã‚·ãƒ³ãƒœãƒ«ã§ãƒªãƒ¼ãƒ«ã‚’æ›´æ–°
                    drumState.reels = drumState.reels.map(() =>
                        drumState.symbols.map(() =>
                            drumState.symbols[Math.floor(Math.random() * drumState.symbols.length)].char
                        )
                    );

                    spinFrames++;
                    if (spinFrames >= 20) {  // 20ãƒ•ãƒ¬ãƒ¼ãƒ ã§ã‚¹ãƒ”ãƒ³çµ‚äº†
                        clearInterval(spinInterval);
                        determineResults();
                    }
                }, 50);
            }

            // çµæœåˆ¤å®š
            function determineResults() {
                drumState.spinning = false;
                let win = 0;

                // çµæœã®æ±ºå®šï¼ˆè¨­å®šå€¤ã‚’è€ƒæ…®ï¼‰
                const results = calculateSpinResults();
                drumState.reels = results;

                // å½“é¸åˆ¤å®š
                win = calculateWin(results);
                drumState.lastWin = win;
                gameState.cultos += win;

                // ç¤ºå”†æ¼”å‡ºã®æ›´æ–°
                updateHints();
            }

            // åˆæœŸåŒ–ã®å®Ÿè¡Œ
            document.addEventListener('DOMContentLoaded', initializeElditchDrum);

            // ãƒœã‚¿ãƒ³ã®è¿½åŠ ã¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            function addDrumControls() {
                const controlsContainer = document.createElement('div');
                controlsContainer.id = 'drumControls';
                controlsContainer.style.marginLeft = '10px';  // Cultos Minerã¨ã®é–“éš”

                controlsContainer.innerHTML = `
        <button id="spinButton">SPIN (50 Â©ï¸)</button>
        <button id="autoSpinToggle">AUTO: OFF</button>
        <button id="betButton">BET: 50 Â©ï¸</button>
    `;

                // Cultos Minerã®æ¨ªã«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’é…ç½®
                const cultosMiner = document.getElementById('cultosminer');
                if (cultosMiner && cultosMiner.parentNode) {
                    cultosMiner.parentNode.insertBefore(controlsContainer, cultosMiner.nextSibling);
                }

                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
                document.getElementById('spinButton').addEventListener('click', () => {
                    if (gameState.cultos >= drumState.currentBet) {
                        spinReels();
                    }
                });

                document.getElementById('autoSpinToggle').addEventListener('click', () => {
                    drumState.autoSpinEnabled = !drumState.autoSpinEnabled;
                    document.getElementById('autoSpinToggle').textContent =
                        `AUTO: ${drumState.autoSpinEnabled ? 'ON' : 'OFF'}`;
                });

                document.getElementById('betButton').addEventListener('click', () => {
                    const betValues = [50, 100, 250, 500, 1000];
                    const currentIndex = betValues.indexOf(drumState.currentBet);
                    drumState.currentBet = betValues[(currentIndex + 1) % betValues.length];
                    document.getElementById('betButton').textContent = `BET: ${drumState.currentBet} Â©ï¸`;
                });
            }

            // ãƒ‡ãƒãƒƒã‚°ç”¨ã®ãƒ­ã‚°æ©Ÿèƒ½
            function logDrumEvent(event, data) {
                console.log(`[Eldritch's Drum] ${event}:`, data);
            }

            // ã‚»ãƒ¬ã‚¯ã‚¿ã‚’å…·ä½“çš„ã«æŒ‡å®šã—ã¦åˆæœŸåŒ–é–¢æ•°ã‚’ä¿®æ­£
            function initializeElditchDrum() {
                // æ—¢å­˜ã®DrumãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯å‰Šé™¤
                const existingDrum = document.getElementById('eldritchDrum');
                if (existingDrum) {
                    existingDrum.remove();
                }

                // Cultos Minerã‚’æ¢ã™
                const cultosminer = document.getElementById('cultosminer');
                if (!cultosminer) {
                    console.error('Cultos Miner element not found');
                    return;
                }

                // æ—¢å­˜ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’ç¢ºèª
                let containerDiv = cultosminer.parentElement.querySelector('.drum-container');
                if (!containerDiv) {
                    // ã‚³ãƒ³ãƒ†ãƒŠãŒãªã„å ´åˆã®ã¿æ–°è¦ä½œæˆ
                    containerDiv = document.createElement('div');
                    containerDiv.className = 'drum-container';
                    cultosminer.parentNode.insertBefore(containerDiv, cultosminer);
                    containerDiv.appendChild(cultosminer);
                }

                // Drumã®ä½œæˆ
                const drumDiv = document.createElement('div');
                drumDiv.id = 'eldritchDrum';
                containerDiv.appendChild(drumDiv);

                // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®è¿½åŠ 
                const controlsDiv = document.createElement('div');
                controlsDiv.id = 'drumControls';
                drumDiv.appendChild(controlsDiv);

                controlsDiv.innerHTML = `
        <button id="spinButton">SPIN (50 Â©ï¸)</button>
        <button id="autoSpinToggle">AUTO: OFF</button>
        <button id="betButton">BET: 50 Â©ï¸</button>
    `;

                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
                setupEventListeners();

                // æ›´æ–°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã®è¨­å®šï¼ˆæ—¢å­˜ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ãŒã‚ã‚Œã°å‰Šé™¤ï¼‰
                if (window.drumUpdateInterval) {
                    clearInterval(window.drumUpdateInterval);
                }
                window.drumUpdateInterval = setInterval(updateDrum, 50);
            }

            // DOMContentLoaded ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’1å›ã ã‘è¨­å®š
            const initialize = () => {
                // ã‚¹ã‚¿ã‚¤ãƒ«ã®è¿½åŠ ï¼ˆä¸€åº¦ã ã‘ï¼‰
                if (!document.getElementById('drumStyles')) {
                    const styleSheet = document.createElement('style');
                    styleSheet.id = 'drumStyles';
                    styleSheet.textContent = drumStyles;
                    document.head.appendChild(styleSheet);
                }

                // é…å»¶ã‚’å…¥ã‚Œã¦åˆæœŸåŒ–
                setTimeout(initializeElditchDrum, 100);
            };

            // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ã—ã¦å†è¨­å®š
            window.removeEventListener('DOMContentLoaded', initialize);
            document.addEventListener('DOMContentLoaded', initialize);

            // ã‚¹ãƒ”ãƒ³çµæœã®è¨ˆç®—ã‚’æ”¹å–„
            function calculateSpinResults() {
                // ãƒ‡ãƒãƒƒã‚°ç”¨ã®ç¢ºç‡è¡¨ç¤º
                const settingMultiplier = 1 + (drumState.setting - 1) * 0.05;
                logDrumEvent('Spin probability multiplier', settingMultiplier);

                return drumState.reels.map(() =>
                    drumState.symbols.map(() => {
                        const symbol = weightedRandomSymbol(settingMultiplier);
                        return symbol.char;
                    })
                );
            }

            // é‡ã¿ä»˜ããƒ©ãƒ³ãƒ€ãƒ é¸æŠã®å®Ÿè£…
            function weightedRandomSymbol(multiplier) {
                const random = Math.random();
                let probabilitySum = 0;

                for (const symbol of drumState.symbols) {
                    probabilitySum += symbol.probability * multiplier;
                    if (random <= probabilitySum) {
                        logDrumEvent('Selected symbol', symbol);
                        return symbol;
                    }
                }

                return drumState.symbols[0];
            }

            // å½“é¸åˆ¤å®šã®å®Ÿè£…
            function calculateWin(results) {
                let win = 0;
                const lines = [
                    [0, 0, 0], // æ¨ª1åˆ—ç›®
                    [1, 1, 1], // æ¨ª2åˆ—ç›®
                    [2, 2, 2], // æ¨ª3åˆ—ç›®
                ];

                lines.forEach((line, index) => {
                    const symbols = line.map((row, col) => results[row][col]);
                    const uniqueSymbols = new Set(symbols);

                    if (uniqueSymbols.size === 1) {
                        const symbol = drumState.symbols.find(s => s.char === symbols[0]);
                        if (symbol) {
                            const lineWin = drumState.currentBet * symbol.payoutMultiplier;
                            win += lineWin;
                            logDrumEvent(`Line ${index + 1} win`, lineWin);
                        }
                    }
                });

                return win;
            }

            // æç”»æ›´æ–°é–¢æ•°ã®æ”¹å–„
            function updateDrum() {
                const drumElement = document.getElementById('eldritchDrum');
                if (!drumElement) return;

                const isSimple = document.getElementById('resourceDisplay').classList.contains('simple');
                drumElement.classList.toggle('simple', isSimple);

                // ãƒ¡ã‚¤ãƒ³ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤éƒ¨åˆ†ã®æ›´æ–°
                const displayContent = drumElement.querySelector('.drum-display') || document.createElement('div');
                displayContent.className = 'drum-display';
                displayContent.textContent = renderDrum();

                if (!drumElement.contains(displayContent)) {
                    drumElement.insertBefore(displayContent, drumElement.firstChild);
                }

                // ã‚ªãƒ¼ãƒˆã‚¹ãƒ”ãƒ³å‡¦ç†
                if (drumState.autoSpinEnabled && !drumState.spinning && gameState.cultos >= drumState.currentBet) {
                    spinReels();
                }
            }

            // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®è¿½åŠ 
            window.onerror = function (msg, url, lineNo, columnNo, error) {
                logDrumEvent('Error', {
                    message: msg,
                    location: `${url}:${lineNo}:${columnNo}`,
                    error: error
                });
                return false;
            };

            function jumpToSummonOldOne() {
                const summonOldOneSection = document.querySelector('.main-content');
                if (summonOldOneSection) {
                    summonOldOneSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setTimeout(() => {
                        window.scrollBy(0, -document.getElementById('game-header').offsetHeight);
                    }, 500);
                }
            }

            function setupTopButtons() {
                const jumpToSummonOldOneBtn = document.getElementById('jumpToSummonOldOne');
                if (jumpToSummonOldOneBtn) {
                    jumpToSummonOldOneBtn.addEventListener('click', jumpToSummonOldOne);
                }

                const jumpToMadnessTableBtn = document.getElementById('jumpToMadnessTable');
                if (jumpToMadnessTableBtn) {
                    jumpToMadnessTableBtn.addEventListener('click', jumpToMadnessTable);
                }

                // Back to Top button functionality is already handled by the existing code
            }

            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            window.addEventListener('scroll', function () {
                const backToTopBtn = document.getElementById('backToTopBtn');
                if (backToTopBtn) {
                    if (window.pageYOffset > 300) { // 300pxã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ãŸã‚‰è¡¨ç¤º
                        backToTopBtn.style.display = 'block';
                    } else {
                        backToTopBtn.style.display = 'none';
                    }
                }
            });

            function toggleTimeAcceleration() {
                const accelerationLevels = [1, 2, 5, 10, 50, 100];
                const currentIndex = accelerationLevels.indexOf(timeAcceleration);
                const nextIndex = (currentIndex + 1) % accelerationLevels.length;
                timeAcceleration = accelerationLevels[nextIndex];
                updateTimeAccelerationDisplay();
            }

            // ç¾åœ¨è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã‚’ä¿®æ­£
            function getCurrentVisibleCard() {
                try {
                    const cards = document.querySelectorAll('.monster-card');
                    if (!cards || cards.length === 0) return null;

                    const headerHeight = getHeaderOffsets();

                    for (const card of cards) {
                        const rect = card.getBoundingClientRect();
                        if (rect && rect.top >= headerHeight && rect.top < window.innerHeight) {
                            return card;
                        }
                    }

                    return cards[0]; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æœ€åˆã®ã‚«ãƒ¼ãƒ‰ã‚’è¿”ã™
                } catch (error) {
                    console.warn('Error getting current visible card:', error);
                    return null;
                }
            }

            let isAllCardsExpanded = true;

            function toggleMonsterCardDetails(expanded) {
                const monsterCards = document.querySelectorAll('.monster-card-details');
                const toggleAllBtn = document.getElementById('toggleAllMonsterCards');

                // ç¾åœ¨ã®çŠ¶æ…‹ã‚’åè»¢
                isAllCardsExpanded = expanded;

                monsterCards.forEach(card => {
                    if (expanded) {
                        card.style.maxHeight = '1000px';
                        card.classList.add('expanded');
                    } else {
                        card.style.maxHeight = '0';
                        card.classList.remove('expanded');
                    }

                    // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
                    const progressBar = card.closest('.monster-card')?.querySelector('.summon-progress-bar');
                    if (progressBar) {
                        progressBar.style.display = expanded ? 'none' : 'block';
                    }
                });

                // ãƒœã‚¿ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’æ›´æ–°
                if (toggleAllBtn) {
                    toggleAllBtn.textContent = expanded ? 'Collapse All Cards' : 'Expand All Cards';
                }
            }

            function setupMonsterCardToggle() {
                const toggleAllBtn = document.getElementById('toggleAllMonsterCards');
                if (!toggleAllBtn) return;

                // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
                toggleAllBtn.onclick = function () {
                    toggleMonsterCardDetails(!isAllCardsExpanded);
                };
            }

            // DOMContentLoadedã‚¤ãƒ™ãƒ³ãƒˆã§åˆæœŸåŒ–ã‚’ç¢ºå®Ÿã«è¡Œã†
            document.addEventListener('DOMContentLoaded', () => {
                setupMonsterCardToggle();
            });


            function getHeaderOffsets() {
                let totalOffset = 0;
                const defaultOffset = 60;

                try {
                    const gameHeader = document.querySelector('.game-header');
                    if (gameHeader) {
                        // ã‚¿ã‚¤ãƒˆãƒ«ã®æŠ˜ã‚ŠãŸãŸã¿çŠ¶æ…‹ã‚’å¾©å…ƒ
                        const isTitleCollapsed = localStorage.getItem('titleCollapsed') === 'true';
                        if (isTitleCollapsed) {
                            gameHeader.classList.add('collapsed');
                        } else {
                            gameHeader.classList.remove('collapsed');
                        }
                        totalOffset += gameHeader.offsetHeight;
                    }

                    const resourceDisplay = document.querySelector('#resourceDisplay');
                    if (resourceDisplay) {
                        totalOffset += resourceDisplay.offsetHeight;
                    }

                    return Math.max(totalOffset, defaultOffset);
                } catch (error) {
                    console.warn('Error calculating header offsets:', error);
                    return defaultOffset;
                }
            }

            // ã‚¿ã‚¤ãƒˆãƒ«ã®ãƒˆã‚°ãƒ«é–¢æ•°ã‚’ä¿®æ­£
            function toggleTitle() {
                const gameHeader = document.querySelector('.game-header');
                if (gameHeader) {
                    const isCollapsed = gameHeader.classList.toggle('collapsed');
                    localStorage.setItem('titleCollapsed', isCollapsed);
                }
            }

            function getFirstVisibleCard() {
                try {
                    const cards = document.querySelectorAll('.monster-card');
                    if (cards.length === 0) return null;

                    const totalOffset = getHeaderOffsets();

                    for (const card of cards) {
                        const rect = card.getBoundingClientRect();
                        if (rect.top >= totalOffset && rect.top < window.innerHeight) {
                            return card;
                        }
                    }
                    return cards[0]; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æœ€åˆã®ã‚«ãƒ¼ãƒ‰ã‚’è¿”ã™
                } catch (error) {
                    console.error('Error in getFirstVisibleCard:', error);
                    return null;
                }
            }

            function getScrollOffset(element) {
                if (!element) return 0;

                try {
                    const totalOffset = getHeaderOffsets();
                    const elementRect = element.getBoundingClientRect();
                    return Math.max(0, window.pageYOffset + elementRect.top - totalOffset - 10);
                } catch (error) {
                    console.error('Error in getScrollOffset:', error);
                    return 0;
                }
            }

            function jumpToMadnessTable() {
                const madnessTable = document.getElementById('madnessTable');
                if (madnessTable) {
                    madnessTable.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setTimeout(() => {
                        window.scrollBy(0, -60);  // ãƒˆãƒƒãƒ—ãƒœã‚¿ãƒ³ã®é«˜ã•åˆ†ã ã‘ä¸Šã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                    }, 500);  // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒçµ‚ã‚ã£ãŸå¾Œã«å®Ÿè¡Œ
                }
            }


            function updateTimeAccelerationDisplay() {
                const display = document.getElementById('timeAccelerationDisplay');
                const tickSpeedDisplay = document.getElementById('tickSpeedDisplay');

                if (display) {
                    display.textContent = `x${timeAcceleration}`;
                }

                if (tickSpeedDisplay) {
                    // å¥‘ç´„ã«ã‚ˆã‚‹åŠ é€Ÿã‚‚è€ƒæ…®
                    const totalSpeed = timeAcceleration * (gameState.pacts?.tickSpeedMultiplier || 1);
                    tickSpeedDisplay.textContent = `x${totalSpeed.toFixed(3)}`;
                    tickSpeedDisplay.style.color = '#4CAF50';  // ç·‘è‰²ã§è¡¨ç¤º
                }
            }

            document.getElementById('toggleTimeAcceleration').addEventListener('click', function () {
                const accelerationLevels = [1, 2, 5, 10, 50, 100];
                const currentIndex = accelerationLevels.indexOf(timeAcceleration);
                const nextIndex = (currentIndex + 1) % accelerationLevels.length;
                timeAcceleration = accelerationLevels[nextIndex];
                updateTimeAccelerationDisplay();
            });

            // ã‚³ã‚¹ãƒˆè¨ˆç®—é–¢æ•°ã®ä¿®æ­£
            function getCost(type) {
                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®å ´åˆã¯åˆ¥è¨ˆç®—
                if (type === 'follower') {
                    const baseFollowerCost = 10;
                    const followerCount = gameState.followers;

                    // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã¯å˜ç´”ãªæŒ‡æ•°é–¢æ•°çš„æˆé•·ã‚’ç¶­æŒ
                    if (followerCount < 1000) {
                        return Math.floor(baseFollowerCost * Math.pow(1.1, followerCount));
                    } else {
                        // 1000ä»¥é™ã¯ç·šå½¢ã«è¿‘ã„æˆé•·
                        return Math.floor(baseFollowerCost * Math.pow(1.1, 1000) * (1 + (followerCount - 1000) * 0.01));
                    }
                }

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®å ´åˆ
                const monster = gameState.monsters[type];
                if (!monster) return Infinity;

                const baseSourceCost = monster.baseSourceCost || baseCosts[type] || 100;
                const count = monster.count || 0;

                // æ³¢å½¢ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
                function getWaveMultiplier(count) {
                    // åŸºæœ¬ã®æ³¢å½¢ï¼ˆè¤‡åˆçš„ãªæ­£å¼¦æ³¢ï¼‰
                    const baseWave = Math.sin(count * 0.4) * 0.2 + // ä¸»æ³¢å½¢
                        Math.sin(count * 0.8) * 0.1;   // äºŒæ¬¡æ³¢å½¢

                    // æ®µéšçš„ãªä¾¡æ ¼èª¿æ•´ï¼ˆ5ä½“ã”ã¨ã«å°ã•ãªä¾¡æ ¼ä½ä¸‹ï¼‰
                    const stepDiscount = (count % 5 === 4) ? -0.15 : 0;

                    // 10ä½“ã”ã¨ã®å¤§ããªä¾¡æ ¼ä¸Šæ˜‡
                    const majorSpike = (count % 10 === 9) ? 0.3 : 0;

                    // ã‚«ã‚¦ãƒ³ãƒˆãŒå¢—ãˆã‚‹ã”ã¨ã«æ³¢ã®å½±éŸ¿ã‚’å¾ã€…ã«æ¸›å°‘
                    const waveReduction = Math.max(0.2, 1 - count * 0.005);

                    // æœ€çµ‚çš„ãªä¹—æ•°ï¼ˆæ³¢å½¢åŠ¹æœã‚’åˆ¶é™ï¼‰
                    return 1 + ((baseWave + stepDiscount + majorSpike) * waveReduction);
                }

                // åŸºæœ¬ã®æŒ‡æ•°é–¢æ•°çš„ä¸Šæ˜‡
                let baseMultiplier;
                if (count < 100) {
                    baseMultiplier = Math.pow(1.15, count);
                } else {
                    baseMultiplier = Math.pow(1.15, 100) * (1 + (count - 100) * 0.05);
                }

                // æ³¢å½¢åŠ¹æœã‚’é©ç”¨
                const waveMultiplier = getWaveMultiplier(count);
                const finalCost = Math.floor(baseSourceCost * baseMultiplier * waveMultiplier);

                // ã‚³ã‚¹ãƒˆã®ä¸Šé™ã‚’è¨­å®š
                return Math.min(finalCost, Number.MAX_SAFE_INTEGER);
            }

            // Collect source function
            function collectSource() {
                gameState.source += 1; // 1å›ã®ã‚¯ãƒªãƒƒã‚¯ã§1ã¤ã ã‘å¢—åŠ 
                logAction("Collected 1 source");
            }

            // ãƒ‡ãƒãƒƒã‚°ç”¨ã®é–¢æ•°ã‚’è¿½åŠ 
            function debug(message) {
                console.log(`[DEBUG] ${message}`);
            }

            // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
            function validateUnlockState() {
                // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã®ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’æ›´æ–°
                for (let adventurer of gameState.adventurers) {
                    if (!gameState.unlockedContent.adventurers.has(adventurer.name)) {
                        if (checkUnlockCondition('adventurers', adventurer.name)) {
                            gameState.unlockedContent.adventurers.add(adventurer.name);
                            logAction(`New Adventurer Unlocked: ${adventurer.name}!`);
                        }
                    }
                }

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’æ›´æ–°
                for (let monsterName in gameState.monsters) {
                    if (!gameState.unlockedContent.monsters.has(monsterName)) {
                        if (checkUnlockCondition('monsters', monsterName)) {
                            gameState.unlockedContent.monsters.add(monsterName);
                            logAction(`New Monster Unlocked: ${monsterName}!`);
                        }
                    }
                }

                // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’æ›´æ–°
                for (let upgradeName in upgradeDefinitions) {
                    if (!gameState.unlockedContent.upgrades.has(upgradeName)) {
                        if (checkUnlockCondition('upgrades', upgradeName)) {
                            gameState.unlockedContent.upgrades.add(upgradeName);
                            logAction(`New Upgrade Unlocked: ${upgradeName}!`);
                        }
                    }
                }
            }

            // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ¡ä»¶ã®èª¬æ˜ã‚’å–å¾—ã™ã‚‹é–¢æ•°
            function getUnlockDescription(category, id) {
                const conditions = unlockConditions[category][id];
                if (!conditions) return 'Unknown condition';

                // æœ€åˆã‹ã‚‰è§£æ”¾ã•ã‚Œã¦ã„ã‚‹å ´åˆ
                if (conditions.isUnlocked) return '';

                // èª¬æ˜æ–‡ãŒç›´æ¥è¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã‚Œã‚’è¿”ã™
                if (conditions.description) return conditions.description;

                // requirement ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰èª¬æ˜ã‚’ç”Ÿæˆ
                const req = conditions.requirement;
                if (!req) return 'Unknown requirement';

                let descriptions = [];

                // Source requirement
                if (req.source) {
                    descriptions.push(`${formatNumber(req.source)} source`);
                }

                // Miasma requirement
                if (req.miasma) {
                    descriptions.push(`${formatNumber(req.miasma)} miasma`);
                }

                // Followers requirement
                if (req.followers) {
                    descriptions.push(`${formatNumber(req.followers)} followers`);
                }

                // Monster requirements
                if (req.monsters) {
                    for (const [monsterType, count] of Object.entries(req.monsters)) {
                        descriptions.push(`${count} ${monsterType}`);
                    }
                }

                // Upgrade requirements
                if (req.upgrades) {
                    if (Array.isArray(req.upgrades)) {
                        descriptions.push(`upgrades: ${req.upgrades.join(', ')}`);
                    }
                }

                // Adventurer level requirements
                if (req.adventurers) {
                    for (const [advName, advReq] of Object.entries(req.adventurers)) {
                        if (advReq.level) {
                            descriptions.push(`Level ${advReq.level} ${advName}`);
                        }
                    }
                }

                return `Requires ${descriptions.join(' and ')}`;
            }

            function checkUnlockCondition(type, name) {
                // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ¸ˆã¿ã®å ´åˆã¯ true ã‚’è¿”ã™
                if (gameState.unlockedContent[type].has(name)) {
                    return true;
                }

                const condition = unlockConditions[type]?.[name];
                if (!condition) return false;
                if (condition.isUnlocked) return true;

                const requirement = condition.requirement;
                if (!requirement) return false;

                // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã®ãƒ¬ãƒ™ãƒ«è¦ä»¶ãƒã‚§ãƒƒã‚¯
                if (requirement.adventurers) {
                    for (const [advName, reqData] of Object.entries(requirement.adventurers)) {
                        // å¯¾è±¡ã®ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã‚’æ¢ã™
                        const adventurer = gameState.adventurers.find(adv => adv.name === advName);
                        // ãƒ¬ãƒ™ãƒ«è¦ä»¶ã‚’æº€ãŸã—ã¦ã„ãªã„å ´åˆã¯ false ã‚’è¿”ã™
                        if (!adventurer || adventurer.level < reqData.level) {
                            return false;
                        }
                    }
                }

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼è¦ä»¶ãƒã‚§ãƒƒã‚¯
                if (requirement.monsters) {
                    for (const [monsterType, count] of Object.entries(requirement.monsters)) {
                        if (!gameState.monsters[monsterType] || gameState.monsters[monsterType].count < count) {
                            return false;
                        }
                    }
                }

                // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰è¦ä»¶ãƒã‚§ãƒƒã‚¯
                if (requirement.upgrades) {
                    for (const upgrade of requirement.upgrades) {
                        if (!gameState.upgrades.includes(upgrade)) {
                            return false;
                        }
                    }
                }

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚¿ã‚¤ãƒ—ã®æ•°ãƒã‚§ãƒƒã‚¯
                if (requirement.monsterTypes) {
                    const uniqueMonsterTypes = Object.values(gameState.monsters)
                        .filter(monster => monster.count > 0).length;
                    if (uniqueMonsterTypes < requirement.monsterTypes) {
                        return false;
                    }
                }

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãƒ¬ãƒ™ãƒ«è¦ä»¶ãƒã‚§ãƒƒã‚¯
                if (requirement.monsterLevel) {
                    const hasHighLevelMonster = Object.values(gameState.monsters)
                        .some(monster => monster.level >= requirement.monsterLevel);
                    if (!hasHighLevelMonster) {
                        return false;
                    }
                }

                // ã™ã¹ã¦ã®æ¡ä»¶ã‚’æº€ãŸã—ãŸå ´åˆ
                if (gameState.unlockedContent[type]) {
                    gameState.unlockedContent[type].add(name);
                }

                return true;
            }

            // updateUnlockStatusé–¢æ•°ã‚’ä¿®æ­£
            function updateUnlockStatus(skipDisplayUpdate = false) {
                if (!gameState.unlockedContent) {
                    initializeGameState();
                }

                let unlockOccurred = false;

                try {
                    // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã®ã‚¢ãƒ³ãƒ­ãƒƒã‚¯å‡¦ç†ã‚’ä¿®æ­£
                    for (const adventurer of gameState.adventurers) {
                        if (!gameState.unlockedContent.adventurers.has(adventurer.name)) {
                            if (checkUnlockCondition('adventurers', adventurer.name)) {
                                gameState.unlockedContent.adventurers.add(adventurer.name);
                                showUnlockNotification('adventurer', adventurer.name);
                                debug(`Adventurer unlocked: ${adventurer.name}`);
                                unlockOccurred = true;
                            }
                        }
                    }

                    // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ãƒã‚§ãƒƒã‚¯
                    upgradeOrder.forEach(upgradeName => {
                        if (!gameState.unlockedContent.upgrades.has(upgradeName)) {
                            if (checkUnlockCondition('upgrades', upgradeName)) {
                                gameState.unlockedContent.upgrades.add(upgradeName);
                                showUnlockNotification('upgrade', upgradeName);
                                debug(`Upgrade unlocked: ${upgradeName}`);
                                unlockOccurred = true;
                            }
                        }
                    });

                    // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ãƒã‚§ãƒƒã‚¯
                    monsterOrder.forEach(monsterName => {
                        if (!gameState.unlockedContent.monsters.has(monsterName)) {
                            if (checkUnlockCondition('monsters', monsterName)) {
                                gameState.unlockedContent.monsters.add(monsterName);
                                showUnlockNotification('monster', monsterName);
                                debug(`Monster unlocked: ${monsterName}`);
                                unlockOccurred = true;
                            }
                        }
                    });

                    // ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ãƒã‚§ãƒƒã‚¯
                    Object.keys(unlockConditions.resources || {}).forEach(resourceName => {
                        if (!gameState.unlockedContent.resources.has(resourceName)) {
                            if (checkUnlockCondition('resources', resourceName)) {
                                gameState.unlockedContent.resources.add(resourceName);
                                showUnlockNotification('resource', resourceName);
                                debug(`Resource unlocked: ${resourceName}`);
                                unlockOccurred = true;
                            }
                        }
                    });

                    if (unlockOccurred && !skipDisplayUpdate) {
                        updateDisplaysAfterUnlock();
                        // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã‚«ãƒ¼ãƒ‰ã®æ›´æ–°ã‚’æ˜ç¤ºçš„ã«å‘¼ã³å‡ºã—
                        updateAdventurerCards();
                    }

                } catch (error) {
                    console.error('Error in updateUnlockStatus:', error);
                    debug(`Error updating unlock status: ${error.message}`);
                }

                return unlockOccurred;
            }

            function initializeNotificationSystem() {
                // æ—¢å­˜ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’å‰Šé™¤ï¼ˆé‡è¤‡é˜²æ­¢ï¼‰
                const oldContainer = document.getElementById('notifications-container');
                if (oldContainer) {
                    oldContainer.remove();
                }

                // æ–°ã—ã„ã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œæˆ
                const container = document.createElement('div');
                container.id = 'notifications-container';
                container.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 100000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: none;
        max-height: 90vh;
        overflow-y: auto;
    `;
                document.body.appendChild(container);
            }

            // é€šçŸ¥ã‚³ãƒ³ãƒ†ãƒŠã‚’DOMã«è¿½åŠ ã™ã‚‹é–¢æ•°
            function createNotificationContainer() {
                if (!document.getElementById('notification-container')) {
                    const container = document.createElement('div');
                    container.id = 'notification-container';
                    container.className = 'notification-container';
                    document.body.appendChild(container);
                }
            }

            // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯é€²æ—ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
            function updateUnlockProgress() {
                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®é€²æ—
                const monsterProgress = document.getElementById('monster-unlock-progress');
                if (monsterProgress) {
                    const unlockedMonsters = gameState.unlockedContent.monsters.size;
                    const totalMonsters = Object.keys(gameState.monsters).length;
                    monsterProgress.textContent = `Monsters: ${unlockedMonsters}/${totalMonsters}`;
                }

                // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã®é€²æ—
                const adventurerProgress = document.getElementById('adventurer-unlock-progress');
                if (adventurerProgress) {
                    const unlockedAdventurers = gameState.unlockedContent.adventurers.size;
                    const totalAdventurers = gameState.adventurers.length;
                    adventurerProgress.textContent = `Adventurers: ${unlockedAdventurers}/${totalAdventurers}`;
                }

                // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®é€²æ—
                const upgradeProgress = document.getElementById('upgrade-unlock-progress');
                if (upgradeProgress) {
                    const unlockedUpgrades = gameState.unlockedContent.upgrades.size;
                    const totalUpgrades = Object.keys(upgradeDefinitions).length;
                    upgradeProgress.textContent = `Upgrades: ${unlockedUpgrades}/${totalUpgrades}`;
                }
            }

            // è£œåŠ©é–¢æ•°ï¼ˆã‚‚ã—æ—¢ã«å®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆï¼‰
            function logAction(message) {
                const logContainer = document.getElementById('action-log');
                if (!logContainer) return;

                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                logEntry.textContent = message;

                logContainer.insertBefore(logEntry, logContainer.firstChild);

                // ãƒ­ã‚°ã‚¨ãƒ³ãƒˆãƒªã®æ•°ã‚’åˆ¶é™ï¼ˆæœ€æ–°ã®50å€‹ã‚’ä¿æŒï¼‰
                while (logContainer.children.length > 50) {
                    logContainer.removeChild(logContainer.lastChild);
                }
            }

            function animateUnlock(element) {
                if (!element) return;

                element.classList.add('unlocking');
                element.addEventListener('animationend', () => {
                    element.classList.remove('unlocking');
                }, { once: true });
            }

            function checkSpecialUnlocks() {
                if (!gameState.unlockedContent) {
                    gameState.unlockedContent = {
                        adventurers: new Set(['Novice Explorer']),
                        monsters: new Set(['Shoggoth']),
                        upgrades: new Set(['Ritual Knowledge']),
                        resources: new Set()
                    };
                }

                // å„ã‚«ãƒ†ã‚´ãƒªãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
                if (!gameState.unlockedContent.monsters) gameState.unlockedContent.monsters = new Set(['Shoggoth']);
                if (!gameState.unlockedContent.adventurers) gameState.unlockedContent.adventurers = new Set(['Novice Explorer']);
                if (!gameState.unlockedContent.upgrades) gameState.unlockedContent.upgrades = new Set(['Ritual Knowledge']);
                // ç·ç”Ÿç”£é‡ã«åŸºã¥ãã‚¢ãƒ³ãƒ­ãƒƒã‚¯
                const totalProduction = calculateTotalProduction();
                if (totalProduction >= 1000 && !gameState.specialUnlocks.has('production1000')) {
                    gameState.specialUnlocks.add('production1000');
                    showUnlockNotification('special', 'Production Milestone: 1,000/s');
                }

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã«åŸºã¥ãã‚¢ãƒ³ãƒ­ãƒƒã‚¯
                if (gameState.followers >= 100 && !gameState.specialUnlocks.has('followers100')) {
                    gameState.specialUnlocks.add('followers100');
                    showUnlockNotification('special', 'Follower Milestone: 100');
                }

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°ã«åŸºã¥ãã‚¢ãƒ³ãƒ­ãƒƒã‚¯
                const totalMonsters = Object.values(gameState.monsters)
                    .reduce((sum, monster) => sum + monster.count, 0);
                if (totalMonsters >= 50 && !gameState.specialUnlocks.has('monsters50')) {
                    gameState.specialUnlocks.add('monsters50');
                    showUnlockNotification('special', 'Monster Milestone: 50 total');
                }

                // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰æ•°ã«åŸºã¥ãã‚¢ãƒ³ãƒ­ãƒƒã‚¯
                if (gameState.upgrades.length >= 5 && !gameState.specialUnlocks.has('upgrades5')) {
                    gameState.specialUnlocks.add('upgrades5');
                    showUnlockNotification('special', 'Upgrade Milestone: 5 purchased');
                }
            }

            function checkAndUpdateUnlocks() {
                // gameState.unlockedContentãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
                if (!gameState.unlockedContent) {
                    gameState.unlockedContent = {
                        adventurers: new Set(['Novice Explorer']),
                        monsters: new Set(['Shoggoth']),
                        upgrades: new Set(['Ritual Knowledge']),
                        resources: new Set()
                    };
                }

                // å„ã‚«ãƒ†ã‚´ãƒªãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
                if (!gameState.unlockedContent.monsters) {
                    gameState.unlockedContent.monsters = new Set(['Shoggoth']);
                }
                if (!gameState.unlockedContent.adventurers) {
                    gameState.unlockedContent.adventurers = new Set(['Novice Explorer']);
                }
                if (!gameState.unlockedContent.upgrades) {
                    gameState.unlockedContent.upgrades = new Set(['Ritual Knowledge']);
                }

                // upgradesãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒé…åˆ—ã¨ã—ã¦å­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
                if (!Array.isArray(gameState.upgrades)) {
                    gameState.upgrades = ['Ritual Knowledge'];
                }

                // å„ã‚«ãƒ†ã‚´ãƒªã®ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
                for (let monsterName in gameState.monsters) {
                    if (checkUnlockCondition('monsters', monsterName)) {
                        gameState.unlockedContent.monsters.add(monsterName);
                    }
                }

                for (let adventurer of gameState.adventurers) {
                    if (checkUnlockCondition('adventurers', adventurer.name)) {
                        gameState.unlockedContent.adventurers.add(adventurer.name);
                    }
                }

                for (let upgradeName in upgradeDefinitions) {
                    if (checkUnlockCondition('upgrades', upgradeName)) {
                        gameState.unlockedContent.upgrades.add(upgradeName);
                    }
                }
            }

            const cardConfigs = {
                monsters: {
                    prefix: 'monster-',
                    conditions: unlockConditions.monsters,
                    lastUnlockState: {},
                    getUnlockDescription: (id) => getUnlockDescription('monsters', id)
                },
                adventurers: {
                    prefix: 'adventurer-',
                    conditions: unlockConditions.adventurers,
                    lastUnlockState: {},
                    getUnlockDescription: (id) => getUnlockDescription('adventurers', id)
                },
                upgrades: {
                    prefix: 'upgrade-',
                    conditions: unlockConditions.upgrades,
                    lastUnlockState: {},
                    getUnlockDescription: (id) => getUnlockDescription('upgrades', id)
                }
            };

            // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°ã‚’ä¿®æ­£
            function checkNewUnlocks() {
                // åˆæœŸã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã®ãƒªã‚¹ãƒˆ
                const initialUnlocks = {
                    monsters: ['Shoggoth'],
                    adventurers: ['Novice Explorer'],
                    upgrades: ['Ritual Knowledge']
                };
                // å„ã‚«ãƒ†ã‚´ãƒªãƒ¼ã®ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯
                for (const category in unlockConditions) {
                    for (const [itemId, condition] of Object.entries(unlockConditions[category])) {
                        // åˆæœŸã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                        if (initialUnlocks[category]?.includes(itemId)) {
                            continue;
                        }

                        if (!gameState.unlockedContent[category].has(itemId) && checkUnlockCondition(category, itemId)) {
                            gameState.unlockedContent[category].add(itemId);
                            showUnlockNotification(category, itemId);
                            updateDisplaysAfterUnlock();
                        }
                    }
                }
            }

            function showUnlockNotification(type, name) {
                try {
                    // é€šçŸ¥è¦ç´ ã®ä½œæˆ
                    const notification = document.createElement('div');
                    notification.className = 'unlock-notification';
                    notification.innerHTML = `
            <div class="notification-icon ${type}-icon"></div>
            <div class="notification-content">
                <h4>New ${type} Unlocked!</h4>
                <p>${name}</p>
            </div>
        `;

                    // æ—¢å­˜ã®é€šçŸ¥ã‚’ç¢ºèªã—ã€ä½ç½®ã‚’èª¿æ•´
                    const existingNotifications = document.querySelectorAll('.unlock-notification');
                    const offset = existingNotifications.length * 70;

                    // é€šçŸ¥ã®ã‚¹ã‚¿ã‚¤ãƒ«
                    notification.style.cssText = `
            position: fixed;
            top: ${20 + offset}px;
            right: 20px;
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 15px;
            color: #e0e0e0;
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 250px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            animation: slideIn 0.5s ease-out, fadeOut 0.5s ease-in 4.5s;
            pointer-events: none;
        `;

                    document.body.appendChild(notification);

                    // 5ç§’å¾Œã«é€šçŸ¥ã‚’æ¶ˆã™ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
                    setTimeout(() => {
                        notification.style.animation = 'fadeOut 0.5s ease-in forwards';
                        setTimeout(() => notification.remove(), 500);
                    }, 4500);

                } catch (error) {
                    console.error('Error showing unlock notification:', error);
                }
            }

            // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            function animateUnlock(card) {
                card.classList.add('unlocking');
                card.classList.remove('locked');
                card.classList.add('unlocked');

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¾Œã«ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
                card.addEventListener('animationend', () => {
                    card.classList.remove('unlocking');
                }, { once: true });
            }

            function updateUnlockSystem() {
                checkAndUpdateUnlocks();
                updateUnlockStatus();
                updateProgressBars();
            }

            async function executeAction(action, params = {}) {
                debug(`executeAction called with action: ${action.name}`);
                if (globalLock) {
                    debug("Global lock is active, action not executed");
                    return;
                }
                globalLock = true;

                try {
                    if (action === summonMonster) {
                        await action(params.type);  // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ã‚¿ã‚¤ãƒ—ã‚’å–ã‚Šå‡ºã™
                    } else {
                        await action(params);
                    }
                    debug(`Action ${action.name} executed successfully`);
                } catch (error) {
                    debug(`Error executing action ${action.name}: ${error}`);
                } finally {
                    globalLock = false;
                }
            }

            function updateRecruitFollowerButton() {
                const recruitFollowerBtn = document.getElementById('recruitFollowerBtn');
                const cost = getCost('follower');

                if (recruitFollowerBtn) {
                    const canAfford = gameState.source >= cost;
                    recruitFollowerBtn.disabled = !canAfford;

                    if (!canAfford) {
                        recruitFollowerBtn.classList.remove('button-enabled', 'whiflash');
                        recruitFollowerBtn.classList.add('disabled');
                    } else {
                        recruitFollowerBtn.classList.remove('disabled');
                        recruitFollowerBtn.classList.add('button-enabled');
                    }
                }
            }

            function recruitFollower() {
                // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ­ãƒƒã‚¯ã‚’ãƒã‚§ãƒƒã‚¯
                if (actionLocks.recruitFollower) {
                    return;
                }

                // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ­ãƒƒã‚¯ã‚’è¨­å®š
                actionLocks.recruitFollower = true;

                try {
                    const cost = getCost('follower');
                    const recruitFollowerBtn = document.getElementById('recruitFollowerBtn');

                    if (gameState.source >= cost) {
                        // 1äººã®ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®ã¿ã‚’è¿½åŠ 
                        gameState.source -= cost;
                        gameState.followers++;
                        logAction(`Recruited 1 follower for ${cost} source`);

                        if (recruitFollowerBtn) {
                            recruitFollowerBtn.classList.add('whiflash');
                        }

                        // çµ±è¨ˆæƒ…å ±ã®æ›´æ–°
                        if (gameState.statistics) {
                            gameState.statistics.totalFollowersRecruited++;
                            gameState.statistics.peakFollowers = Math.max(
                                gameState.statistics.peakFollowers || 0,
                                gameState.followers
                            );
                        }

                        // UIæ›´æ–°
                        updateCultosMiner();
                        updateResourceDisplay();
                        updateRecruitFollowerButton();
                    }
                } catch (error) {
                    console.error("Error in recruitFollower:", error);
                } finally {
                    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
                    setTimeout(() => {
                        actionLocks.recruitFollower = false;
                    }, 50); // 50ãƒŸãƒªç§’ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
                }
            }

            let isSummoning = false;

            function summonMonster(type) {
                if (isSummoning) {
                    debug("Summoning already in progress");
                    return;
                }

                isSummoning = true;

                try {
                    const monsterData = gameState.monsters[type];
                    if (!monsterData) {
                        console.log("Monster data not found");
                        return;
                    }

                    const sourceCost = getCost(type);
                    const followerCost = Math.floor(monsterData.baseFollowerCost *
                        Math.pow(monsterData.followerCostGrowth, monsterData.count));

                    if (gameState.source < sourceCost || gameState.followers < followerCost) {
                        console.log("Not enough resources");
                        return;
                    }

                    // ãƒªã‚½ãƒ¼ã‚¹ã‚’æ¶ˆè²»ã—ã¦å¬å–šå®Ÿè¡Œ
                    gameState.source -= sourceCost;
                    gameState.followers -= followerCost;
                    monsterData.count++;

                    // UIæ›´æ–°ã¨ãƒ­ã‚°
                    logAction(`Summoned 1 ${type} for ${formatNumber(sourceCost)} source and ${formatNumber(followerCost)} followers`);
                    updateMonsterCards();
                    updateResourceDisplay();
                    updateCultosMiner();

                } catch (error) {
                    console.error("Summoning error:", error);
                } finally {
                    setTimeout(() => {
                        isSummoning = false;
                    }, 50);
                }
            }

            function buyUpgrade(upgrade) {
                debug(`buyUpgrade called for ${upgrade}`);

                // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
                if (!checkUnlockCondition('upgrades', upgrade)) {
                    debug(`Attempted to buy locked upgrade: ${upgrade}`);
                    logAction(`Cannot purchase ${upgrade} - not yet unlocked`);
                    return;
                }

                const cost = Math.floor(baseCosts[upgrade] * (gameState.upgradeCostMultiplier || 1));
                if (gameState.source >= cost && !gameState.upgrades.includes(upgrade)) {
                    gameState.source -= cost;
                    gameState.upgrades.push(upgrade);
                    applyUpgrade(upgrade);
                    updateUpgradeSymbols();
                    updateUpgradeGrid();
                    updateDisplay();
                    logAction(`Bought ${upgrade} upgrade for ${formatNumber(cost)} source`);
                    debug(`Upgrade bought. New upgrades: ${gameState.upgrades}`);

                } else {
                    if (gameState.source < cost) {
                        logAction(`Not enough source to buy ${upgrade}. Need ${formatNumber(cost)}, have ${formatNumber(gameState.source)}`);
                    } else {
                        logAction(`${upgrade} has already been purchased`);
                    }
                    debug(`Unable to buy upgrade ${upgrade}. Cost: ${cost}, Available: ${gameState.source}, Already owned: ${gameState.upgrades.includes(upgrade)}`);
                }
            }

            function calculateTimeToSummon(sourceDifference, productionPerSecond) {
                if (productionPerSecond <= 0) {
                    return sourceDifference > 0 ? Infinity : 0;
                }
                return Math.max(0, sourceDifference / productionPerSecond);
            }

            function calculateSynergyEffects() {
                let synergyEffects = {
                    source: 1,
                    miasma: 1,
                    all: 1
                };

                // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ç‰¹å®š
                const activeMonsters = new Set(
                    Object.entries(gameState.monsters)
                        .filter(([_, monster]) => monster.count > 0)
                        .map(([type, _]) => type)
                );

                // ã‚·ãƒŠã‚¸ãƒ¼åŠ¹æœã®è¨ˆç®—
                activeMonsters.forEach(monsterType => {
                    const monster = gameState.monsters[monsterType];
                    if (monster.synergy && activeMonsters.has(monster.synergy.partner)) {
                        const effectType = monster.synergy.type || 'all';
                        const effectValue = monster.synergy.effect;

                        // ã‚·ãƒŠã‚¸ãƒ¼åŠ¹æœã‚’ä¹—ç®—ã§é©ç”¨
                        synergyEffects[effectType] *= (1 + effectValue);

                        // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
                        debug(`Synergy activated: ${monsterType} with ${monster.synergy.partner}, type: ${effectType}, value: ${effectValue}`);
                    }
                });

                return synergyEffects;
            }

            function applySpecialAbilities() {
                for (const monsterType in gameState.monsters) {
                    const monster = gameState.monsters[monsterType];
                    if (!monster || !monster.specialAbility || monster.count === 0) continue;

                    const triggerCount = Math.floor(monster.count / monster.specialAbility.trigger);
                    if (triggerCount === 0) continue;

                    const effect = monster.specialAbility.effect;
                    switch (effect.type) {
                        case 'allMonsterEfficiency':
                            // ã™ã¹ã¦ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®åŠ¹ç‡ã‚’ä¸Šæ˜‡ï¼ˆä¸Šé™ãªã—ï¼‰
                            const efficiencyBonus = 1 + (effect.value * triggerCount);
                            for (const targetMonster in gameState.monsters) {
                                gameState.monsters[targetMonster].sourceEfficiency *= efficiencyBonus;
                                gameState.monsters[targetMonster].miasmaEfficiency *= efficiencyBonus;
                            }
                            debug(`Applied all monster efficiency bonus: +${((efficiencyBonus - 1) * 100).toFixed(1)}%`);
                            break;

                        case 'madnessChance':
                            // ç‹‚æ°—ãƒãƒ£ãƒ³ã‚¹å¢—åŠ ï¼ˆæœ€å¤§20%ã¾ã§ï¼‰
                            const maxMadnessBonus = 0.20;
                            const madnessBonus = Math.min(effect.value * triggerCount, maxMadnessBonus);
                            gameState.madnessChanceMultiplier = 1 + madnessBonus;
                            debug(`Applied madness chance modifier: +${(madnessBonus * 100).toFixed(1)}% (max: 20%)`);
                            break;

                        case 'miasmaEfficiency':
                            // ãƒŸã‚¢ã‚¹ãƒåŠ¹ç‡ä¸Šæ˜‡ï¼ˆä¸Šé™ãªã—ï¼‰
                            const miasmaBonus = Math.pow(1 + effect.value, triggerCount);
                            for (const targetMonster in gameState.monsters) {
                                gameState.monsters[targetMonster].miasmaEfficiency *= miasmaBonus;
                            }
                            debug(`Applied miasma efficiency bonus: x${miasmaBonus.toFixed(2)}`);
                            break;

                        case 'sourceProduction':
                            // Sourceç”Ÿç”£é‡ä¸Šæ˜‡ï¼ˆä¸Šé™ãªã—ï¼‰
                            const sourceBonus = Math.pow(1 + effect.value, triggerCount);
                            for (const targetMonster in gameState.monsters) {
                                gameState.monsters[targetMonster].sourceEfficiency *= sourceBonus;
                            }
                            debug(`Applied source production bonus: x${sourceBonus.toFixed(2)}`);
                            break;

                        case 'upgradeEffect':
                            // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰åŠ¹æœå¢—å¼·ï¼ˆä¸Šé™ãªã—ï¼‰
                            const upgradeBonus = 1 + (effect.value * triggerCount);
                            gameState.upgradeEffectMultiplier = (gameState.upgradeEffectMultiplier || 1) * upgradeBonus;
                            debug(`Applied upgrade effect multiplier: x${upgradeBonus.toFixed(2)}`);
                            break;

                        case 'followerProduction':
                            // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ç”Ÿç”£é‡å¢—åŠ ï¼ˆä¸Šé™ãªã—ï¼‰
                            const followerBonus = effect.value * triggerCount;
                            gameState.followerProductionBonus = (gameState.followerProductionBonus || 0) + followerBonus;
                            debug(`Applied follower production bonus: +${(followerBonus * 100).toFixed(1)}%`);
                            break;

                        case 'cosmicResonance':
                            // å®‡å®™å…±é³´åŠ¹æœï¼ˆå…¨ä½“ã®ç”Ÿç”£é‡å¢—åŠ ã€ä¸Šé™ãªã—ï¼‰
                            const resonanceBonus = Math.pow(1 + effect.value, triggerCount);
                            gameState.cosmicResonanceMultiplier = (gameState.cosmicResonanceMultiplier || 1) * resonanceBonus;
                            debug(`Applied cosmic resonance multiplier: x${resonanceBonus.toFixed(2)}`);
                            break;

                        case 'upgradeCost':
                            // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚³ã‚¹ãƒˆå‰Šæ¸›ï¼ˆæŒ‡å®šã•ã‚ŒãŸæœ€å¤§å€¤ã¾ã§ï¼‰
                            const totalDiscount = Math.min(effect.value * triggerCount, effect.maxDiscount);
                            gameState.upgradeCostMultiplier = Math.max(0.1, (1 - totalDiscount));
                            debug(`Applied upgrade cost reduction: -${(totalDiscount * 100).toFixed(1)}%`);
                            break;

                        case 'adventurerResistanceRecoveryTime':
                            // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã®æŠµæŠ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ™‚é–“å‰Šæ¸›ï¼ˆæœ€å°500msï¼‰
                            const cooldownReduction = effect.value * triggerCount;
                            gameState.adventurerCooldownReduction = Math.min(
                                (gameState.adventurerCooldownReduction || 0) + cooldownReduction,
                                gameState.adventurerBaseCooldown - 500
                            );
                            debug(`Applied adventurer cooldown reduction: ${cooldownReduction}ms`);
                            break;
                    }
                }

                // åŠ¹æœãŒé©ç”¨ã•ã‚ŒãŸã“ã¨ã‚’ç¤ºã™ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
                gameState.specialAbilitiesApplied = true;
            }

            function applySpecialAbilityEffect(monsterType, effectType, value) {
                const monster = gameState.monsters[monsterType];
                if (!monster || !monster.specialAbility || monster.specialAbility.effect.type !== effectType) {
                    return value;  // åŠ¹æœãŒé©ç”¨ã§ããªã„å ´åˆã¯å…ƒã®å€¤ã‚’è¿”ã™
                }

                const triggerCount = Math.floor(monster.count / monster.specialAbility.trigger);
                if (triggerCount === 0) {
                    return value;  // ãƒˆãƒªã‚¬ãƒ¼æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ãªã„å ´åˆã¯å…ƒã®å€¤ã‚’è¿”ã™
                }

                switch (effectType) {
                    case 'allMonsterEfficiency':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    case 'followerEfficiencyMultiplier':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, monster.count);
                    case 'followerEfficiency':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    case 'sourceProduction':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    case 'upgradeEffect':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    case 'followerProduction':
                        return value + monster.specialAbility.effect.value * triggerCount;
                    case 'cosmicResonance':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    case 'upgradeCost':
                        const totalDiscount = Math.min(monster.specialAbility.effect.maxDiscount, monster.specialAbility.effect.value * triggerCount);
                        return value * (1 - totalDiscount);
                    case 'adventurerResistanceRecoveryTime':
                        return value - (monster.specialAbility.effect.value * triggerCount);
                    case 'miasmaEfficiency':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    case 'madnessChance':
                        return value * Math.pow(1 + monster.specialAbility.effect.value, triggerCount);
                    default:
                        return value;
                }
            }

            function applyUpgrade(upgrade, multiplier = 1) {
                switch (upgrade) {
                    case "Ritual Knowledge":
                        gameState.followerEfficiency *= (1 + 0.25 * multiplier);
                        break;
                    case "Eldritch Tome":
                        for (let monster in gameState.monsters) {
                            gameState.monsters[monster].sourceEfficiency *= (1 + 0.25 * multiplier);
                            gameState.monsters[monster].miasmaEfficiency *= (1 + 0.25 * multiplier);
                        }
                        break;
                    case "Hiroshi Sakamoto`s Paper":
                        // Cultosãƒã‚¤ãƒ‹ãƒ³ã‚°ã®ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã«å¿…è¦ãªå‡¦ç†
                        const cultosminer = document.getElementById('cultosminer');
                        const cultosColumn = document.getElementById('cultosColumn');

                        if (cultosminer) {
                            cultosminer.classList.remove('cultosminer-disabled');
                        }
                        if (cultosColumn) {
                            cultosColumn.classList.remove('cultos-hidden');
                        }

                        // Cultosãƒã‚¤ãƒ‹ãƒ³ã‚°æ©Ÿèƒ½ã®åˆæœŸåŒ–
                        if (!gameState.hasOwnProperty('cultos')) {
                            gameState.cultos = 0;
                            gameState.cultosRate = 0;
                        }
                        break;
                    case "Cosmic Alignment":
                        gameState.cosmicAlignmentBonus = 1 + (0.1 * multiplier);
                        break;
                    case "Forbidden Ritual":
                        for (let monster in gameState.monsters) {
                            gameState.monsters[monster].sourceEfficiency *= (1 + 0.4 * multiplier);
                        }
                        break;
                    case "Hermetic Teachings":
                        gameState.followerEfficiency *= (1 + 0.3 * multiplier);
                        break;
                    case "Cosmic Insight":
                        gameState.followerEfficiency *= (1 + 0.35 * multiplier);
                        for (let monster in gameState.monsters) {
                            gameState.monsters[monster].sourceEfficiency *= (1 + 0.35 * multiplier);
                            gameState.monsters[monster].miasmaEfficiency *= (1 + 0.35 * multiplier);
                        }
                        break;
                    case "Astral Projection":
                        gameState.astralProjectionRate = 0.03 * multiplier;
                        break;
                    case "Dimensional Rift":
                        for (let upgrade of gameState.upgrades) {
                            if (upgrade !== "Dimensional Rift") {
                                applyUpgrade(upgrade, 1 + 0.5 * multiplier);
                            }
                        }
                        break;
                    case "Necronomicon Fragment":
                        for (let monster in gameState.monsters) {
                            gameState.monsters[monster].sourceEfficiency *= (1 + 0.5 * multiplier);
                            gameState.monsters[monster].miasmaEfficiency *= (1 + 0.5 * multiplier);
                        }
                        break;
                    case "Psychic Attunement":
                        for (let monster in gameState.monsters) {
                            gameState.monsters[monster].miasmaEfficiency *= (1 + 0.3 * multiplier);
                        }
                        break;
                    case "Quantum Entanglement":
                        gameState.quantumEntanglementBonus = 0.05 * multiplier;
                        break;
                    case "Temporal Manipulation":
                        gameState.temporalManipulationBonus = 1 + (0.2 * multiplier);
                        break;
                    case "Eldritch Evolution":
                        gameState.eldritchEvolutionRate = 0.001 * multiplier;
                        break;
                }
            }

            function updateUpgradeGrid() {
                const grid = document.getElementById('upgradeGrid');
                if (!grid) return;

                const sourceCount = Math.floor(gameState.source);

                // æ—¢å­˜ã®ã‚«ãƒ¼ãƒ‰ã‚’ä¸€æ™‚çš„ã«ä¿å­˜
                const existingCards = {};
                grid.querySelectorAll('.upgrade-card').forEach(card => {
                    const upgradeName = card.id.replace('upgrade-', '');
                    existingCards[upgradeName] = card;
                });

                // upgradeOrderã«å¾“ã£ã¦ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚’ä¸¦ã¹æ›¿ãˆ
                for (let upgrade of upgradeOrder) {
                    // æ—¢ã«è³¼å…¥æ¸ˆã¿ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                    if (gameState.upgrades.includes(upgrade)) {
                        const existingCard = document.getElementById(`upgrade-${upgrade}`);
                        if (existingCard) {
                            existingCard.remove();
                        }
                        continue;
                    }

                    let card = existingCards[upgrade];
                    if (!card) {
                        card = document.createElement('div');
                        card.id = `upgrade-${upgrade}`;
                        card.className = 'upgrade-card';

                        // tooltipã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ä½œæˆ
                        const tooltipText = getUpgradeEffectDescription(upgrade);

                        card.innerHTML = `
                <div class="upgrade-card-header">
                    <h3>
                        <span class="upgrade-symbol" title="${tooltipText}">${upgradeSymbols[upgrade] || ''}</span>
                        ${upgrade}
                    </h3>
                    <div class="upgrade-cost">Cost: </div>
                </div>
                <div class="upgrade-description">${upgradeEffects[upgrade]}</div>
                <div class="unlock-requirement"></div>
                <button class="buy-upgrade-btn" data-upgrade="${upgrade}" disabled>Purchase</button>
            `;
                        grid.appendChild(card);
                    }

                    // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ç¢ºèª
                    const isUnlocked = checkUnlockCondition('upgrades', upgrade);
                    card.classList.toggle('locked', !isUnlocked);
                    card.classList.toggle('unlocked', isUnlocked);

                    // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ¡ä»¶ã®è¡¨ç¤ºã‚’æ›´æ–°
                    const unlockReqElement = card.querySelector('.unlock-requirement');
                    if (unlockReqElement) {
                        const unlockDesc = getUnlockDescription('upgrades', upgrade);
                        if (unlockReqElement.textContent !== unlockDesc) {
                            unlockReqElement.textContent = unlockDesc;
                            unlockReqElement.style.display = isUnlocked ? 'none' : 'block';
                        }
                    }

                    // ã‚³ã‚¹ãƒˆã¨è³¼å…¥ãƒœã‚¿ãƒ³ã®æ›´æ–°
                    const cost = Math.floor(baseCosts[upgrade] * (gameState.upgradeCostMultiplier || 1));
                    const costElement = card.querySelector('.upgrade-cost');
                    if (costElement) {
                        costElement.textContent = `Cost: ${formatNumber(cost)} source`;
                    }

                    const button = card.querySelector('.buy-upgrade-btn');
                    if (button) {
                        const canAfford = sourceCount >= cost && isUnlocked;
                        button.disabled = !canAfford;
                        button.classList.toggle('button-enabled', canAfford);
                        button.classList.toggle('button-disabled', !canAfford);
                    }
                }
            }

            function updateUpgradeCards() {
                const grid = document.getElementById('upgradeGrid');
                if (!grid) return;

                const sourceCount = Math.floor(gameState.source);

                // Ensure upgradeOrder exists and is an array
                if (!Array.isArray(upgradeOrder)) {
                    console.error('upgradeOrder is not properly defined');
                    return;
                }

                // Clear existing cards first
                grid.innerHTML = '';

                // Iterate through upgrade order
                for (let upgrade of upgradeOrder) {
                    // Skip if already purchased
                    if (gameState.upgrades && gameState.upgrades.includes(upgrade)) continue;

                    const card = document.createElement('div');
                    card.id = `upgrade-${upgrade}`;
                    card.className = 'upgrade-card';

                    // Get upgrade definition safely
                    const upgradeData = upgradeDefinitions[upgrade] || {
                        cost: baseCosts[upgrade] || 100,
                        description: upgradeEffects[upgrade] || 'No description available'
                    };

                    // Safely get cost with multiplier
                    const cost = Math.floor((upgradeData.cost || baseCosts[upgrade] || 100) *
                        (gameState.upgradeCostMultiplier || 1));

                    // Check unlock condition
                    const isUnlocked = checkUnlockCondition('upgrades', upgrade);
                    const canAfford = sourceCount >= cost && isUnlocked;

                    // Create card HTML
                    card.innerHTML = `
            <div class="upgrade-card-header">
                <h3>${upgradeSymbols[upgrade] || ''} ${upgrade}</h3>
                <div class="upgrade-cost">Cost: ${formatNumber(cost)} source</div>
            </div>
            <div class="upgrade-description">${upgradeData.description}</div>
            ${!isUnlocked ? `<div class="unlock-requirement">${getUnlockDescription('upgrades', upgrade)}</div>` : ''}
            <button onclick="buyUpgrade('${upgrade}')" ${!canAfford ? 'disabled' : ''}>Purchase</button>
        `;

                    // Add appropriate classes
                    card.classList.toggle('locked', !isUnlocked);
                    card.classList.toggle('unlocked', isUnlocked);

                    grid.appendChild(card);
                }

                // Update upgrade symbols
                updateUpgradeSymbols();
            }

            function checkUnlockCondition(type, name) {
                if (gameState.unlockedContent[type].has(name)) {
                    return true;
                }
                const condition = unlockConditions[type]?.[name];
                if (!condition) return false;
                if (condition.isUnlocked) return true;

                const requirement = condition.requirement;
                if (!requirement) return false;

                // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã®ãƒ¬ãƒ™ãƒ«è¦ä»¶ãƒã‚§ãƒƒã‚¯
                if (requirement.adventurers) {
                    for (const [advName, reqData] of Object.entries(requirement.adventurers)) {
                        const adventurer = gameState.adventurers.find(adv => adv.name === advName);
                        // ã“ã“ã§ reqData.level ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«ä¿®æ­£
                        if (!adventurer || adventurer.level < reqData.level) {
                            return false;
                        }
                    }
                }

                // Check each requirement type
                if (requirement.monsters) {
                    for (const [monsterType, count] of Object.entries(requirement.monsters)) {
                        if (!gameState.monsters[monsterType] || gameState.monsters[monsterType].count < count) {
                            return false;
                        }
                    }
                }

                if (requirement.upgrades) {
                    for (const upgrade of requirement.upgrades) {
                        if (!gameState.upgrades.includes(upgrade)) {
                            return false;
                        }
                    }
                }

                if (requirement.monsterTypes) {
                    const uniqueMonsters = Object.values(gameState.monsters)
                        .filter(monster => monster.count > 0).length;
                    if (uniqueMonsters < requirement.monsterTypes) {
                        return false;
                    }
                }

                if (requirement.monsterLevel) {
                    const hasHighLevelMonster = Object.values(gameState.monsters)
                        .some(monster => monster.level >= requirement.monsterLevel);
                    if (!hasHighLevelMonster) {
                        return false;
                    }
                }

                return true;
            }

            function calculateUpgradeBoost() {
                let boost = 1;

                // å„ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®åŠ¹æœã‚’é©ç”¨
                if (gameState.upgrades.includes('Hiroshi Sakamoto`s Paper')) {
                    boost *= 1.5; // åŸºæœ¬ãƒœãƒ¼ãƒŠã‚¹
                }
                // ä»–ã®ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®åŠ¹æœã‚‚å¿…è¦ã«å¿œã˜ã¦è¿½åŠ 

                return boost;
            }

            function canAffordUpgrade(upgradeId) {
                const cost = Math.floor((upgradeDefinitions[upgradeId]?.cost || baseCosts[upgradeId] || 100) *
                    (gameState.upgradeCostMultiplier || 1));
                return gameState.source >= cost && !gameState.upgrades.includes(upgradeId);
            }

            // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰åŠ¹æœã®èª¬æ˜ã‚’å–å¾—ã™ã‚‹é–¢æ•°
            function getUpgradeEffectDescription(upgradeName) {
                const upgrade = upgradeDefinitions[upgradeName];
                if (!upgrade) return 'Unknown upgrade';

                switch (upgrade.type) {
                    case 'sourceEfficiency':
                        return `Increases source production by ${(upgrade.effect * 100).toFixed(1)}%`;
                    case 'miasmaEfficiency':
                        return `Increases miasma production by ${(upgrade.effect * 100).toFixed(1)}%`;
                    case 'followerEfficiency':
                        return `Increases follower efficiency by ${(upgrade.effect * 100).toFixed(1)}%`;
                    case 'monsterEfficiency':
                        return `Increases all monster efficiency by ${(upgrade.effect * 100).toFixed(1)}%`;
                    case 'cultosMiner':
                        return `Unlocks the ability to use Cultos Miner`;
                    case 'cosmicAlignment':
                        return `Increases all production by ${(upgrade.effect * 100).toFixed(1)}% when followers match monsters`;
                    case 'astralProjection':
                        return `Generates ${(upgrade.effect * 100).toFixed(1)}% of your source per second`;
                    case 'quantumEntanglement':
                        return `Increases all production by ${(upgrade.effect * 100).toFixed(1)}% when having paired monsters`;
                    case 'temporalManipulation':
                        return `Multiplies all production by ${upgrade.effect.toFixed(2)}x`;
                    case 'eldritchEvolution':
                        return `Monsters gain ${(upgrade.effect * 100).toFixed(1)}% efficiency every minute`;
                    default:
                        return upgrade.description || 'Effect unknown';
                }
            }

            function checkAdventurerUnlock(adventurerName) {
                const condition = unlockConditions.adventurers[adventurerName];
                if (!condition || condition.isUnlocked) return true;

                const req = condition.requirement;
                if (!req) return false;

                // ãƒŸã‚¢ã‚¹ãƒã®è¦ä»¶ãƒã‚§ãƒƒã‚¯
                if (req.miasma && gameState.miasma < req.miasma) return false;

                // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã®ãƒ¬ãƒ™ãƒ«è¦ä»¶ãƒã‚§ãƒƒã‚¯
                if (req.adventurers) {
                    for (const [reqName, reqLevel] of Object.entries(req.adventurers)) {
                        const adventurer = gameState.adventurers.find(a => a.name === reqName);
                        if (!adventurer || adventurer.level < reqLevel.level) return false;
                    }
                }

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®æ•°è¦ä»¶ãƒã‚§ãƒƒã‚¯
                if (req.monsters) {
                    for (const [monsterName, count] of Object.entries(req.monsters)) {
                        if (!gameState.monsters[monsterName] || gameState.monsters[monsterName].count < count) return false;
                    }
                }

                return true;
            }

            // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
            function updateAdventurerUnlocks() {
                gameState.adventurers.forEach(adventurer => {
                    if (!gameState.unlockedContent.adventurers.has(adventurer.name)) {
                        if (checkAdventurerUnlock(adventurer.name)) {
                            gameState.unlockedContent.adventurers.add(adventurer.name);
                            logAction(`New Adventurer Unlocked: ${adventurer.name}!`);
                        }
                    }
                });
            }

            function updateAdventurerStates() {
                const currentTime = gamePaused ? lastFrameTime : Date.now();

                for (const [index, adventurer] of gameState.adventurers.entries()) {
                    // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
                    const isUnlocked = gameState.unlockedContent.adventurers.has(adventurer.name);
                    if (!isUnlocked) continue;

                    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã®ç¢ºèªã¨æ›´æ–°
                    if (adventurer.cooldownEndTime > 0) {
                        if (!gamePaused && currentTime >= adventurer.cooldownEndTime) {
                            // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³çµ‚äº†æ™‚ã®å‡¦ç†
                            if (adventurer.isMad) {
                                adventurer.isMad = false;
                                logAction(`${adventurer.name} has returned to sanity!`);
                            }
                            adventurer.cooldownEndTime = 0;
                        }
                    }

                    // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã‚«ãƒ¼ãƒ‰ã®æ›´æ–°
                    const adventurerElement = document.getElementById(`adventurer-${index}`);
                    if (adventurerElement) {
                        // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³è¡¨ç¤ºã®æ›´æ–°
                        const cooldownDisplay = adventurerElement.querySelector('.cooldown-status');
                        if (cooldownDisplay) {
                            if (adventurer.cooldownEndTime > currentTime) {
                                const remainingTime = (adventurer.cooldownEndTime - currentTime) / timeAcceleration;
                                cooldownDisplay.textContent = formatTime(remainingTime / 1000);
                            } else {
                                cooldownDisplay.textContent = 'Ready';
                            }
                        }

                        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã®æ›´æ–°
                        const statusDisplay = adventurerElement.querySelector('.adventurer-status');
                        if (statusDisplay) {
                            if (adventurer.isMad) {
                                statusDisplay.textContent = 'Mad';
                            } else if (adventurer.cooldownEndTime > currentTime) {
                                statusDisplay.textContent = 'Cooling Down';
                            } else {
                                statusDisplay.textContent = 'Ready';
                            }
                        }

                        // ãƒãƒƒãƒ‰ãƒã‚¹ãƒœã‚¿ãƒ³ã®æ›´æ–°
                        const madnessButton = adventurerElement.querySelector('.madness-btn');
                        if (madnessButton) {
                            const canAttemptMadness = !adventurer.isMad &&
                                adventurer.cooldownEndTime <= currentTime &&
                                gameState.miasma >= adventurer.miasmaRequired;

                            madnessButton.disabled = !canAttemptMadness || gamePaused;
                        }
                    }
                }
            }

            function updateAdventurerCards() {
                const adventurerContainer = document.getElementById('adventurers');
                if (!adventurerContainer) return;

                // å„ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã‚«ãƒ¼ãƒ‰ã®æ›´æ–°
                for (let adventurer of gameState.adventurers) {
                    const card = document.getElementById(`adventurer-${adventurer.name.replace(/\s+/g, '-')}`);
                    if (!card) continue;

                    // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ç¢ºèª
                    const isUnlocked = checkUnlockCondition('adventurers', adventurer.name);

                    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³çŠ¶æ…‹ã®ç¢ºèª
                    const now = Date.now();
                    const isOnCooldown = now < adventurer.cooldownEndTime;
                    const isMad = adventurer.isMad;

                    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ®‹ã‚Šæ™‚é–“ã®è¨ˆç®—
                    let cooldownRemaining = 0;
                    if (isOnCooldown) {
                        cooldownRemaining = Math.ceil((adventurer.cooldownEndTime - now) / 1000);
                    }

                    // å„è¦ç´ ã®æ›´æ–°
                    const levelElement = card.querySelector('.adventurer-level');
                    if (levelElement) {
                        levelElement.textContent = `Level ${adventurer.level}`;
                    }

                    const productionElement = card.querySelector('.adventurer-production');
                    if (productionElement) {
                        const baseProduction = adventurer.baseFollowerProduction * Math.pow(1.1, adventurer.level - 1);
                        productionElement.textContent = `${formatNumber(baseProduction, 1)} followers/s`;
                    }

                    const madnessChanceElement = card.querySelector('.adventurer-madness-chance');
                    if (madnessChanceElement) {
                        madnessChanceElement.textContent = `${(adventurer.madnessChance * 100).toFixed(1)}% madness chance`;
                    }

                    const statusElement = card.querySelector('.adventurer-status');
                    if (statusElement) {
                        if (isMad) {
                            statusElement.textContent = 'Status: Mad';
                            statusElement.classList.add('status-mad');
                        } else if (isOnCooldown) {
                            statusElement.textContent = `Cooldown: ${cooldownRemaining}s`;
                            statusElement.classList.add('status-cooldown');
                        } else {
                            statusElement.textContent = 'Status: Ready';
                            statusElement.classList.add('status-ready');
                        }
                    }

                    // æ¢ç´¢ãƒœã‚¿ãƒ³ã®æ›´æ–°
                    const exploreButton = card.querySelector('.explore-btn');
                    if (exploreButton) {
                        const canExplore = !isOnCooldown && !isMad;
                        exploreButton.disabled = !canExplore;
                        exploreButton.classList.toggle('button-enabled', canExplore);
                        exploreButton.classList.toggle('button-disabled', !canExplore);
                    }

                    // æ²»ç™‚ãƒœã‚¿ãƒ³ã®æ›´æ–°
                    const healButton = card.querySelector('.heal-btn');
                    if (healButton) {
                        const healCost = Math.floor(100 * Math.pow(1.5, adventurer.level - 1));
                        healButton.textContent = `Heal (${healCost} source)`;
                        const canHeal = isMad && gameState.source >= healCost;
                        healButton.disabled = !isMad || !canHeal;
                        healButton.classList.toggle('button-enabled', canHeal && isMad);
                        healButton.classList.toggle('button-disabled', !canHeal || !isMad);
                    }

                    // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ãƒœã‚¿ãƒ³ã®æ›´æ–°
                    const levelUpButton = card.querySelector('.level-up-btn');
                    if (levelUpButton) {
                        const levelUpCost = Math.floor(200 * Math.pow(2, adventurer.level - 1));
                        levelUpButton.textContent = `Level Up (${levelUpCost} source)`;
                        const canLevelUp = gameState.source >= levelUpCost;
                        levelUpButton.disabled = !canLevelUp;
                        levelUpButton.classList.toggle('button-enabled', canLevelUp);
                        levelUpButton.classList.toggle('button-disabled', !canLevelUp);
                    }

                    // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®æ›´æ–°
                    const progressBar = card.querySelector('.cooldown-progress-bar');
                    if (progressBar && isOnCooldown) {
                        const percentage = ((adventurer.cooldownEndTime - now) / adventurer.cooldownTime) * 100;
                        progressBar.style.width = `${100 - percentage}%`;
                    }

                    // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®æ›´æ–°
                    card.classList.toggle('locked', !isUnlocked);
                    card.classList.toggle('unlocked', isUnlocked);
                    card.classList.toggle('mad', isMad);
                    card.classList.toggle('on-cooldown', isOnCooldown);
                }
            }

            // updateMadnessTableé–¢æ•°ã‚’ä¿®æ­£
            function updateMadnessTable() {
                const adventurersContainer = document.getElementById('adventurers');
                if (!adventurersContainer) {
                    console.error("Adventurers container not found");
                    return;
                }

                const currentTime = Date.now();
                const miasmaCount = Math.floor(gameState.miasma);

                gameState.adventurers.forEach((adventurer, index) => {
                    let adventurerElement = document.getElementById(`adventurer-${index}`);
                    if (!adventurerElement) {
                        // æ–°ã—ã„ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ¼è¦ç´ ã®ä½œæˆ
                        adventurerElement = document.createElement('div');
                        adventurerElement.id = `adventurer-${index}`;
                        adventurerElement.className = 'adventurer';
                        adventurerElement.innerHTML = `
                <h3>${adventurer.name}</h3>
                <div class="ascii-art">${asciiArt[adventurer.name]}</div>
                <p class="level-display">Level: <span class="adventurer-level">0</span></p>
                <p class="miasma-required">Miasma Required: <span class="miasma-requirement">0</span></p>
                <p class="production-display">Follower Production: <span class="follower-production">0</span>/sec</p>
                <p class="chance-display">Madness Chance: <span class="madness-chance">0</span>%</p>
                <p class="status-display">Status: <span class="adventurer-status">Ready</span></p>
                <button class="madness-btn" data-index="${index}">Attempt Madness</button>
                <p class="cooldown-display">Cooldown: <span class="cooldown-status">Ready</span></p>
                <div class="unlock-requirement"></div>
            `;
                        adventurersContainer.appendChild(adventurerElement);
                    }

                    // ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®æ›´æ–°ï¼ˆæ°¸ç¶šçš„ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã‚’è€ƒæ…®ï¼‰
                    const isUnlocked = gameState.unlockedContent.adventurers.has(adventurer.name);
                    adventurerElement.classList.toggle('locked', !isUnlocked);

                    if (!isUnlocked) {
                        // ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®è¡¨ç¤º
                        const unlockDesc = getUnlockDescription('adventurers', adventurer.name);
                        const requirementElem = adventurerElement.querySelector('.unlock-requirement');
                        if (requirementElem) {
                            requirementElem.textContent = unlockDesc;
                            requirementElem.style.display = 'block';
                        }
                    } else {
                        // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®è¡¨ç¤º
                        const requirementElem = adventurerElement.querySelector('.unlock-requirement');
                        if (requirementElem) {
                            requirementElem.style.display = 'none';
                        }
                    }

                    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã¨çŠ¶æ…‹ã®æ›´æ–°
                    const cooldownRemaining = Math.max(0, adventurer.cooldownEndTime - currentTime);
                    const adjustedCooldown = cooldownRemaining / timeAcceleration; // tick speedã§èª¿æ•´
                    const isReady = cooldownRemaining === 0 && !adventurer.isMad;
                    const canAttemptMadness = isUnlocked && miasmaCount >= adventurer.miasmaRequired && isReady;

                    // å„è¦ç´ ã®æ›´æ–°
                    updateElementText(adventurerElement, '.adventurer-level', adventurer.level);
                    updateElementText(adventurerElement, '.miasma-requirement', formatNumber(Math.floor(adventurer.miasmaRequired)));
                    updateElementText(adventurerElement, '.follower-production', formatNumber(adventurer.followerProduction, 1));
                    updateElementText(adventurerElement, '.madness-chance', (calculateFinalMadnessChance(adventurer) * 100).toFixed(0));

                    // çŠ¶æ…‹è¡¨ç¤ºã®æ›´æ–°
                    const statusText = adventurer.isMad ? 'Mad' :
                        (cooldownRemaining > 0 ? 'Cooldown' :
                            (isUnlocked ? 'Ready' : 'Locked'));
                    updateElementText(adventurerElement, '.adventurer-status', statusText);

                    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³è¡¨ç¤ºã®æ›´æ–°
                    const cooldownText = cooldownRemaining > 0 ?
                        formatTime(adjustedCooldown / 1000) : // tick speedã§èª¿æ•´ã•ã‚ŒãŸæ™‚é–“ã‚’è¡¨ç¤º
                        (isUnlocked ? 'Ready' : 'Locked');
                    updateElementText(adventurerElement, '.cooldown-status', cooldownText);

                    // ASCII ã‚¢ãƒ¼ãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ«æ›´æ–°
                    const asciiArtElem = adventurerElement.querySelector('.ascii-art');
                    if (asciiArtElem) {
                        asciiArtElem.classList.toggle('red-filter', adventurer.isMad);
                    }

                    // ãƒãƒƒãƒ‰ãƒã‚¹ãƒœã‚¿ãƒ³ã®æ›´æ–°ã‚’ä¿®æ­£
                    const madnessBtn = adventurerElement.querySelector('.madness-btn');
                    if (madnessBtn) {
                        const isOnCooldown = currentTime < adventurer.cooldownEndTime;
                        const hasEnoughMiasma = miasmaCount >= adventurer.miasmaRequired;
                        const canAttemptMadness = isUnlocked && !isOnCooldown && !adventurer.isMad && hasEnoughMiasma;

                        // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
                        madnessBtn.disabled = !canAttemptMadness;
                        madnessBtn.classList.toggle('button-enabled', canAttemptMadness);
                        madnessBtn.classList.toggle('button-disabled', !canAttemptMadness);

                        // ãƒœã‚¿ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆã¨ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’æ›´æ–°
                        let btnText = 'Attempt Madness';
                        let tooltipText = '';

                        if (!isUnlocked) {
                            tooltipText = 'Adventurer is locked';
                            btnText = 'Locked';
                        } else if (adventurer.isMad) {
                            tooltipText = 'Already mad';
                            btnText = 'Currently Mad';
                        } else if (isOnCooldown) {
                            tooltipText = 'Cooling Down';
                            btnText = 'Cooling Down';
                        } else if (!hasEnoughMiasma) {
                            tooltipText = `Need ${formatNumber(Math.ceil(adventurer.miasmaRequired - miasmaCount))} more miasma`;
                            btnText = 'Not Enough Miasma';
                        }

                        madnessBtn.textContent = btnText;
                        madnessBtn.title = tooltipText;
                    }

                    // é€²è¡ŒçŠ¶æ…‹ã«å¿œã˜ãŸã‚¹ã‚¿ã‚¤ãƒ«æ›´æ–°
                    adventurerElement.classList.toggle('active', adventurer.isMad);
                    adventurerElement.classList.toggle('cooldown', cooldownRemaining > 0);
                    adventurerElement.classList.toggle('available', canAttemptMadness);

                    // ãƒ¬ãƒ™ãƒ«è¡¨ç¤ºã®ã‚¹ã‚¿ã‚¤ãƒ«æ›´æ–°
                    const levelDisplay = adventurerElement.querySelector('.level-display');
                    if (levelDisplay) {
                        levelDisplay.classList.toggle('max-level', adventurer.level >= 10);
                    }

                    // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®æ›´æ–°ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
                    const progressBar = adventurerElement.querySelector('.madness-progress');
                    if (progressBar) {
                        const progress = Math.min(100, (miasmaCount / adventurer.miasmaRequired) * 100);
                        progressBar.style.width = `${progress}%`;
                        progressBar.classList.toggle('full', progress >= 100);
                    }
                });
            }

            function calculateMadnessChance(adventurer) {
                let finalChance = adventurer.madnessChance;

                // This Manã®ç‰¹æ®Šèƒ½åŠ›ã«ã‚ˆã‚‹è£œæ­£ï¼ˆä¸Šé™20%ã¾ã§ã«åˆ¶é™ï¼‰
                const maxMadnessBonus = 0.20; // æœ€å¤§20%ã®è£œæ­£
                const thisManBonus = (gameState.madnessChanceMultiplier || 1) - 1;
                const clampedBonus = Math.min(thisManBonus, maxMadnessBonus);

                finalChance *= (1 + clampedBonus);

                // å¥‘ç´„åŠ¹æœã®é©ç”¨
                if (gameState.pacts?.commonMultiplier) {
                    finalChance *= gameState.pacts.commonMultiplier;
                }

                // æœ€çµ‚çš„ãªç¢ºç‡ã‚’0ï½1ã®ç¯„å›²ã«åˆ¶é™
                return Math.min(Math.max(finalChance, 0), 1);
            }

            function calculateFinalMadnessChance(adventurer) {
                let finalChance = adventurer.madnessChance;

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç‰¹æ®Šèƒ½åŠ›ã«ã‚ˆã‚‹å½±éŸ¿ã‚’è¨ˆç®—ï¼ˆé‡è¤‡é©ç”¨ã‚’é˜²ãï¼‰
                let totalMonsterBonus = 0;
                for (let monsterType in gameState.monsters) {
                    const monster = gameState.monsters[monsterType];
                    if (monster.count > 0 && monster.specialAbility?.effect?.type === 'madnessChance') {
                        const triggerCount = Math.floor(monster.count / monster.specialAbility.trigger);
                        if (triggerCount > 0) {
                            totalMonsterBonus += monster.specialAbility.effect.value * triggerCount;
                        }
                    }
                }

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãƒœãƒ¼ãƒŠã‚¹ã‚’ä¸€æ‹¬é©ç”¨
                finalChance *= (1 + totalMonsterBonus);

                // å¥‘ç´„åŠ¹æœã®é©ç”¨
                if (gameState.pacts?.commonMultiplier) {
                    finalChance *= gameState.pacts.commonMultiplier;
                }

                // æœ€çµ‚çš„ãªç¢ºç‡ã‚’0ï½1ã®ç¯„å›²ã«åˆ¶é™
                return Math.min(Math.max(finalChance, 0), 1);
            }

            // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼šè¦ç´ ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å®‰å…¨ã«æ›´æ–°
            function updateElementText(parentElement, selector, text) {
                const element = parentElement.querySelector(selector);
                if (element) {
                    element.textContent = text;
                } else {
                    console.warn(`Element not found: ${selector}`);
                }
            }


            // attemptMadnessé–¢æ•°ã®ä¿®æ­£
            function attemptMadness(index) {
                // ã‚²ãƒ¼ãƒ ãŒä¸€æ™‚åœæ­¢ä¸­ã®å ´åˆã¯å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
                if (gamePaused) {
                    return;
                }

                const currentTime = Date.now();
                const adventurer = gameState.adventurers[index];


                if (!adventurer || adventurer.cooldownEndTime > currentTime) {
                    return;
                }

                // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã®ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
                if (!checkUnlockCondition('adventurers', adventurer.name)) {
                    debug(`Attempted to interact with locked adventurer: ${adventurer.name}`);
                    logAction(`Cannot attempt madness with ${adventurer.name} - not yet unlocked`);
                    return;
                }

                // ãƒŸã‚¢ã‚¹ãƒã®ã‚³ã‚¹ãƒˆãƒã‚§ãƒƒã‚¯
                if (gameState.miasma < adventurer.miasmaRequired) {
                    return;
                }

                gameState.miasma -= adventurer.miasmaRequired;

                // madnessChanceã®è¨ˆç®—ã‚’ä¿®æ­£
                const baseChance = adventurer.madnessChance;
                let finalChance = calculateFinalMadnessChance(adventurer);

                debug(`Attempting madness with chance: ${finalChance}`);

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç‰¹æ®Šèƒ½åŠ›ã«ã‚ˆã‚‹å½±éŸ¿ã‚’è¨ˆç®—
                for (let monsterType in gameState.monsters) {
                    if (gameState.monsters[monsterType].count > 0) {
                        const monster = gameState.monsters[monsterType];
                        if (monster.specialAbility &&
                            monster.specialAbility.effect.type === 'madnessChance') {
                            const triggerCount = Math.floor(monster.count / monster.specialAbility.trigger);
                            if (triggerCount > 0) {
                                finalChance *= (1 + monster.specialAbility.effect.value * triggerCount);
                            }
                        }
                    }
                }

                // å¥‘ç´„åŠ¹æœã®é©ç”¨
                if (gameState.pacts?.commonMultiplier) {
                    finalChance *= gameState.pacts.commonMultiplier;
                }

                // madnessChanceMultiplierã®é©ç”¨ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
                if (gameState.madnessChanceMultiplier) {
                    finalChance *= gameState.madnessChanceMultiplier;
                }

                debug(`Attempting madness with chance: ${finalChance}`);

                if (Math.random() < finalChance) {
                    // ç‹‚æ°—æˆåŠŸã®å‡¦ç†
                    let madnessCooldown = adventurer.baseCooldown * (1 + (adventurer.level * 0.1));
                    madnessCooldown = Math.max(500, madnessCooldown * timeAcceleration);
                    adventurer.cooldownEndTime = currentTime + madnessCooldown;
                    adventurer.isMad = true;
                    adventurer.level++;
                    adventurer.followerProduction *= 1.5;
                    adventurer.miasmaRequired *= 1.5;
                    adventurer.madnessChance *= 0.9;

                    const followerReward = Math.floor(adventurer.followerReward * Math.sqrt(adventurer.level));
                    gameState.followers += followerReward;

                    // ã‚»ãƒªãƒ•ã‚’è¡¨ç¤ºã™ã‚‹å‡¦ç†
                    const adventurerElement = document.querySelector(`#adventurer-${index}`);
                    if (adventurerElement) {
                        const dialogueList = dialogues.adventurers[adventurer.name];
                        if (dialogueList && dialogueList.mad && dialogueList.mad.length > 0) {
                            const madDialogues = dialogueList.mad;
                            const randomText = madDialogues[Math.floor(Math.random() * madDialogues.length)];
                            showSpeechBubble(adventurerElement, randomText, 5000, 'mad');
                        }
                    }

                    // çµ±è¨ˆã®æ›´æ–°
                    if (gameState.statistics) {
                        gameState.statistics.successfulMadness = (gameState.statistics.successfulMadness || 0) + 1;
                    }

                    logAction(`${adventurer.name} went mad! Level up to ${adventurer.level}. Generating ${formatNumber(adventurer.followerProduction, 1)} followers/sec. Gained ${formatNumber(followerReward)} followers.`);
                } else {
                    // å¤±æ•—æ™‚ã®å‡¦ç†
                    let resistanceCooldown = Math.max(500, (adventurer.baseCooldown * (1 + (adventurer.level * 0.1))) / 2);

                    // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç‰¹æ®Šèƒ½åŠ›ã«ã‚ˆã‚‹å½±éŸ¿ã‚’è¨ˆç®—
                    for (let monsterType in gameState.monsters) {
                        resistanceCooldown = applySpecialAbilityEffect(monsterType, 'adventurerResistanceRecoveryTime', resistanceCooldown);
                    }

                    resistanceCooldown = Math.max(500, resistanceCooldown * timeAcceleration);
                    adventurer.cooldownEndTime = currentTime + resistanceCooldown;

                    // ãƒ¬ã‚¸ã‚¹ãƒˆæ™‚ã®ã‚»ãƒªãƒ•ã‚’è¡¨ç¤º
                    const adventurerElement = document.querySelector(`#adventurer-${index}`);
                    if (adventurerElement) {
                        const dialogueList = dialogues.adventurers[adventurer.name];
                        if (dialogueList && dialogueList.resist && dialogueList.resist.length > 0) {
                            const resistDialogues = dialogueList.resist;
                            const randomText = resistDialogues[Math.floor(Math.random() * resistDialogues.length)];
                            showSpeechBubble(adventurerElement, randomText, 3000, 'resist');
                        }
                    }

                    logAction(`${adventurer.name} resisted the madness.`);
                }

                // çµ±è¨ˆã®æ›´æ–°
                if (gameState.statistics) {
                    gameState.statistics.totalMadnessAttempts = (gameState.statistics.totalMadnessAttempts || 0) + 1;
                }

                updateMadnessTable();
                updateResourceDisplay();
            }

            function handleMadnessAttempt(event) {
                if (event.target.classList.contains('madness-btn') && !event.target.disabled) {
                    const index = parseInt(event.target.dataset.index);
                    const adventurer = gameState.adventurers[index];
                    const currentTime = Date.now();

                    if (gameState.miasma >= adventurer.miasmaRequired && adventurer.cooldownEndTime <= currentTime) {
                        attemptMadness(index);
                    } else {
                        //console.log(`Madness attempt prevented. Miasma: ${gameState.miasma}, Required: ${adventurer.miasmaRequired}, Cooldown: ${adventurer.cooldownEndTime - currentTime}ms`);
                    }
                    event.preventDefault();
                }
            }

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
            const adventurersContainer = document.getElementById('adventurers');
            if (adventurersContainer) {
                adventurersContainer.addEventListener('click', handleMadnessAttempt);
            }

            function calculateTotalProduction() {
                let sourceProduction = 0;
                let miasmaProduction = 0;

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‹ã‚‰ã®ç”Ÿç”£
                for (let monsterName in gameState.monsters) {
                    const monster = gameState.monsters[monsterName];
                    sourceProduction += monster.count * monster.sourceEfficiency;
                    miasmaProduction += monster.count * monster.miasmaEfficiency;
                }

                // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã‹ã‚‰ã®ç”Ÿç”£
                for (let adventurer of gameState.adventurers) {
                    if (adventurer.isUnlocked && !adventurer.isMad) {
                        sourceProduction += adventurer.baseFollowerProduction * Math.pow(1.1, adventurer.level - 1);
                    }
                }

                return sourceProduction + miasmaProduction;
            }

            function calculateBaseProduction() {
                let sourceProduction = gameState.followers * gameState.followerEfficiency;
                let miasmaProduction = 0;
                let followerProduction = 0;

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‹ã‚‰ã®ç”Ÿç”£é‡ã‚’è¨ˆç®—
                for (let monster in gameState.monsters) {
                    const monsterData = gameState.monsters[monster];
                    sourceProduction += monsterData.count * monsterData.sourceEfficiency;
                    miasmaProduction += monsterData.count * monsterData.miasmaEfficiency;
                }

                // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã‹ã‚‰ã®ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ç”Ÿç”£ã‚’è¨ˆç®—
                for (const adventurer of gameState.adventurers) {
                    if (!adventurer.isMad && gameState.unlockedContent.adventurers.has(adventurer.name)) {
                        // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸç”Ÿç”£é‡ã®è¨ˆç®—
                        const baseProduction = adventurer.baseFollowerProduction * Math.pow(1.1, adventurer.level - 1);
                        followerProduction += baseProduction;
                    }
                }

                // å¥‘ç´„åŠ¹æœã®é©ç”¨
                if (gameState.pacts?.active) {
                    const multiplier = gameState.pacts.commonMultiplier || 1;
                    followerProduction *= multiplier;
                }

                return { sourceProduction, miasmaProduction, followerProduction };
            }

            // å¿…è¦æœ€ä½followeræ•°ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°
            function calculateMinimumFollowers() {
                const baseProduction = calculateBaseProduction();
                const sourceRate = baseProduction.sourceProduction;
                const miasmaRate = baseProduction.miasmaProduction;

                // ç”Ÿç”£é‡ã«åŸºã¥ã„ã¦å¿…è¦æœ€ä½æ•°ã‚’è¨ˆç®—
                const sourceBasedMin = Math.floor(sourceRate / 1000);
                const miasmaBasedMin = Math.floor(miasmaRate / 500);

                return Math.max(sourceBasedMin, miasmaBasedMin, 1); // æœ€ä½1äººã¯å¿…è¦
            }

            // ç”Ÿç”£é‡ãƒšãƒŠãƒ«ãƒ†ã‚£ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°
            function calculateProductionPenalty() {
                const currentFollowers = gameState.followers;
                const minimumRequired = calculateMinimumFollowers();

                return currentFollowers < minimumRequired ? 0.3 : 1; // ä¸è¶³æ™‚ã¯ç”Ÿç”£é‡3/10
            }

            // æœ€çµ‚çš„ãªç”Ÿç”£é‡ã®è¨ˆç®—é–¢æ•°
            function calculateResourceProduction() {
                // åŸºæœ¬ç”Ÿç”£é‡ã®åˆæœŸåŒ–
                let sourceProduction = gameState.followers * gameState.followerEfficiency;
                let miasmaProduction = 0;
                let followerProduction = 0;

                // ã‚·ãƒŠã‚¸ãƒ¼åŠ¹æœã‚’è¨ˆç®—ï¼ˆåŠ ç®—æ–¹å¼ï¼‰
                const synergyEffects = {
                    source: 0,
                    miasma: 0,
                    all: 0
                };

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ã‚·ãƒŠã‚¸ãƒ¼åŠ¹æœã‚’è¨ˆç®—
                for (const [monsterType, monster] of Object.entries(gameState.monsters)) {
                    if (monster.count > 0 && monster.synergy) {
                        const partnerMonster = gameState.monsters[monster.synergy.partner];
                        if (partnerMonster && partnerMonster.count > 0) {
                            const synergyBonus = monster.synergy.effect;
                            switch (monster.synergy.type) {
                                case 'source':
                                    synergyEffects.source += synergyBonus;
                                    break;
                                case 'miasma':
                                    synergyEffects.miasma += synergyBonus;
                                    break;
                                case 'all':
                                    synergyEffects.all += synergyBonus;
                                    break;
                            }
                        }
                    }
                }

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‹ã‚‰ã®ç”Ÿç”£é‡ã‚’è¨ˆç®—
                for (const [monsterType, monster] of Object.entries(gameState.monsters)) {
                    if (monster.count > 0) {
                        // åŸºæœ¬ç”Ÿç”£é‡
                        let monsterSourceProduction = monster.count * monster.sourceEfficiency;
                        let monsterMiasmaProduction = monster.count * monster.miasmaEfficiency;

                        // ã‚·ãƒŠã‚¸ãƒ¼ãƒœãƒ¼ãƒŠã‚¹ã®é©ç”¨ï¼ˆåŠ ç®—æ–¹å¼ï¼‰
                        const totalSourceBonus = 1 + synergyEffects.source + synergyEffects.all;
                        const totalMiasmaBonus = 1 + synergyEffects.miasma + synergyEffects.all;

                        monsterSourceProduction *= totalSourceBonus;
                        monsterMiasmaProduction *= totalMiasmaBonus;

                        sourceProduction += monsterSourceProduction;
                        miasmaProduction += monsterMiasmaProduction;
                    }
                }

                // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã‹ã‚‰ã®ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ç”Ÿç”£ã‚’è¨ˆç®—
                for (const adventurer of gameState.adventurers) {
                    if (gameState.unlockedContent.adventurers.has(adventurer.name)) {
                        // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã‹ã¤ç‹‚æ°—çŠ¶æ…‹ã®æ™‚ã®ã¿ç”Ÿç”£
                        const currentTime = Date.now();
                        const isOnCooldown = currentTime < adventurer.cooldownEndTime;

                        if (adventurer.isMad && isOnCooldown) {
                            // ãƒ¬ãƒ™ãƒ«ãƒœãƒ¼ãƒŠã‚¹ã‚’åŠ ç®—æ–¹å¼ã§è¨ˆç®—
                            const levelBonus = 1 + (adventurer.level - 1) * 0.1; // 10%ãšã¤åŠ ç®—
                            followerProduction += adventurer.followerProduction * levelBonus; // followerProductionã‚’ä½¿ç”¨
                        }
                    }
                }

                // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒœãƒ¼ãƒŠã‚¹ã®è¨ˆç®—ï¼ˆåŠ ç®—æ–¹å¼ï¼‰
                let globalBonus = 1;

                // Cosmic Alignment ãƒœãƒ¼ãƒŠã‚¹
                if (gameState.cosmicAlignmentBonus) {
                    globalBonus += (gameState.cosmicAlignmentBonus - 1);
                }

                // Quantum Entanglement ãƒœãƒ¼ãƒŠã‚¹
                if (gameState.quantumEntanglementBonus) {
                    globalBonus += gameState.quantumEntanglementBonus;
                }

                // Temporal Manipulation ãƒœãƒ¼ãƒŠã‚¹
                if (gameState.temporalManipulationBonus) {
                    globalBonus += (gameState.temporalManipulationBonus - 1);
                }

                // Astral Projection ãƒœãƒ¼ãƒŠã‚¹
                if (gameState.astralProjectionRate) {
                    globalBonus += gameState.astralProjectionRate;
                }

                // å¥‘ç´„åŠ¹æœã®é©ç”¨
                if (gameState.pacts?.active) {
                    const pactBonus = (gameState.pacts.commonMultiplier || 1) - 1;
                    globalBonus += pactBonus;
                }

                // Cultosãƒœãƒ¼ãƒŠã‚¹ã®è¨ˆç®—
                const cultosBonus = calculateCultosBonus() - 1;
                globalBonus += cultosBonus;

                // ç”Ÿç”£ãƒšãƒŠãƒ«ãƒ†ã‚£ã®è¨ˆç®—
                const productionPenalty = calculateProductionPenalty();
                globalBonus *= productionPenalty;

                // æœ€çµ‚çš„ãªç”Ÿç”£é‡ã®è¨ˆç®—
                sourceProduction *= globalBonus;
                miasmaProduction *= globalBonus;
                followerProduction *= globalBonus;

                // å°æ•°ç‚¹ä»¥ä¸‹ã‚’é©åˆ‡ã«å‡¦ç†
                return {
                    sourceProduction: Math.max(0, sourceProduction),
                    miasmaProduction: Math.max(0, miasmaProduction),
                    followerProduction: Math.max(0, followerProduction),
                    baseFollowerProduction: followerProduction / globalBonus // ãƒšãƒŠãƒ«ãƒ†ã‚£é©ç”¨å‰ã®åŸºæœ¬ç”Ÿç”£é‡
                };
            }

            // è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
            function updateResourceDisplay() {
                const sourceCount = Math.floor(gameState.source);
                const miasmaCount = Math.floor(gameState.miasma);
                const baseProduction = calculateBaseProduction();
                const minimumFollowers = calculateMinimumFollowers();
                const penalty = calculateProductionPenalty();
                const finalProduction = calculateResourceProduction();

                // ãƒªã‚½ãƒ¼ã‚¹ã‚«ã‚¦ãƒ³ãƒˆã®æ›´æ–°
                document.getElementById('largeSourceCount').textContent = formatNumber(sourceCount, 3);
                document.getElementById('largeMiasmaCount').textContent = formatNumber(miasmaCount, 3);

                // ç”Ÿç”£ç‡ã®æ›´æ–°
                const sourcePerSecond = document.getElementById('largeSourcePerSecond');
                const miasmaPerSecond = document.getElementById('largeMiasmaPerSecond');

                sourcePerSecond.textContent = formatNumber(finalProduction.sourceProduction, 3);
                miasmaPerSecond.textContent = formatNumber(finalProduction.miasmaProduction, 3);

                // Cultosã®è¡¨ç¤ºã‚’æ›´æ–°
                const cultosCount = document.querySelector('.cultos-count');
                const cultosHashRate = document.getElementById('cultosHashRate');

                if (cultosCount) {
                    cultosCount.textContent = formatNumber(gameState.cultos, 3);
                }
                if (cultosHashRate) {
                    cultosHashRate.textContent = formatHashRate(gameState.cultosRate);
                }

                // ãƒšãƒŠãƒ«ãƒ†ã‚£çŠ¶æ…‹ã®è¦–è¦šçš„è¡¨ç¤º
                if (penalty < 1) {
                    sourcePerSecond.classList.add('penalty');
                    miasmaPerSecond.classList.add('penalty');
                } else {
                    sourcePerSecond.classList.remove('penalty');
                    miasmaPerSecond.classList.remove('penalty');
                }

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æƒ…å ±ã®æ›´æ–°
                const followerSection = document.getElementById('followerSection');
                if (followerSection) {
                    const followerInfo = followerSection.querySelector('.follower-info') ||
                        document.createElement('div');
                    followerInfo.className = 'follower-info';

                    followerInfo.innerHTML = `
            <p>Current Followers: ${formatNumber(gameState.followers)}</p>
            <p class="${gameState.followers < minimumFollowers ? 'warning' : ''}">
                Minimum Required: ${formatNumber(minimumFollowers)}
                ${gameState.followers < minimumFollowers ?
                            `<br><span class="penalty-warning">
                        Production reduced to 33%<br>
                        Base production: ${formatNumber(baseProduction.sourceProduction)}/s<br>
                        Current production: ${formatNumber(finalProduction.sourceProduction)}/s
                    </span>` :
                            ''}
            </p>
        `;

                    if (!followerSection.querySelector('.follower-info')) {
                        followerSection.appendChild(followerInfo);
                    }
                }
                // Cultosã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ¶å¾¡
                updateCultosVisibility();
            }

            function updateGameState(deltaTime) {
                // å¥‘ç´„ã®åŠ¹æœã‚’é©ç”¨
                const baseMultiplier = timeAcceleration * (gameState.pacts?.tickSpeedMultiplier || 1);

                // ç”Ÿç”£é‡ã®è¨ˆç®—
                const production = calculateResourceProduction();

                // ãƒªã‚½ãƒ¼ã‚¹ã®æ›´æ–°ï¼ˆæ™‚é–“ã¨ãƒãƒ«ãƒãƒ—ãƒ©ã‚¤ãƒ¤ãƒ¼ã‚’é©ç”¨ï¼‰
                gameState.source += production.sourceProduction * deltaTime * baseMultiplier;
                gameState.miasma += production.miasmaProduction * deltaTime * baseMultiplier;

                // Cultosç”Ÿç”£ã®æ›´æ–°
                const cultosRate = calculateCultosRate(deltaTime);
                gameState.cultos += cultosRate * deltaTime;

                // followerAccumulatorã®åˆæœŸåŒ–ã‚’ç¢ºå®Ÿã«è¡Œã†
                if (typeof gameState.followerAccumulator !== 'number') {
                    gameState.followerAccumulator = 0;
                }

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®ç´¯ç©å‡¦ç†
                if (production.followerProduction > 0) {
                    gameState.followerAccumulator += production.followerProduction * deltaTime * baseMultiplier;

                    if (gameState.followerAccumulator >= 1) {
                        const newFollowers = Math.floor(gameState.followerAccumulator);
                        gameState.followers += newFollowers;
                        gameState.followerAccumulator -= newFollowers;
                    }
                }

                // æœ€å°ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã®ä¿è¨¼ï¼ˆå¥‘ç´„åŠ¹æœï¼‰
                updatePactEffects();

                // ãã®ä»–ã®ã‚²ãƒ¼ãƒ ã‚·ã‚¹ãƒ†ãƒ ã®æ›´æ–°
                updateAdventurerStates();
                applySpecialAbilities();
                checkPacts();
                updateUnlockSystem();
                sanitizeGameState();

                // çµ±è¨ˆæƒ…å ±ã®æ›´æ–°
                if (gameState.statistics) {
                    gameState.statistics.totalSourceGenerated += production.sourceProduction * deltaTime * baseMultiplier;
                    gameState.statistics.totalMiasmaGenerated += production.miasmaProduction * deltaTime * baseMultiplier;
                    gameState.statistics.peakFollowers = Math.max(
                        gameState.statistics.peakFollowers || 0,
                        gameState.followers || 0
                    );
                }
            }

            // updateDisplayé–¢æ•°ã®ä¿®æ­£
            function updateDisplay() {
                try {
                    Object.keys(UPDATE_INTERVALS).forEach(key => {
                        const now = Date.now();
                        if (now - lastUpdateTimes[key] >= UPDATE_INTERVALS[key]) {
                            switch (key) {
                                case 'monsterGrid':
                                    updateMonsterGrid();
                                    break;
                                case 'followerSection':
                                    updateFollowerSection();
                                    break;
                                case 'madnessTable':
                                    updateMadnessTable();
                                    break;
                                case 'upgradeGrid':
                                    updateUpgradeGrid();
                                    break;
                                case 'gameDetails':
                            }
                            lastUpdateTimes[key] = now;
                        }
                    });
                } catch (error) {
                    console.error('Error in updateDisplay:', error);
                }
            }

            // updateGameDetails é–¢æ•°ã®è¿½åŠ 
            function updateGameDetails() {
                const detailsDiv = document.getElementById('gameDetails');
                if (!detailsDiv) {
                    console.warn("Game details div not found");
                    return;
                }

                const followerBoost = 1 + (gameState.followers * 0.01);
                const monsterTypes = Object.values(gameState.monsters).filter(m => m.count > 0).length;
                const monsterSynergyBoost = 1 + (monsterTypes * 0.1);

                let detailsHTML = `
        <p><strong>Follower Efficiency:</strong> ${formatNumber(gameState.followerEfficiency, 2)}</p>
        <p><strong>Follower Boost:</strong> ${formatNumber(followerBoost, 2)}x</p>
        <p><strong>Monster Synergy Boost:</strong> ${formatNumber(monsterSynergyBoost, 2)}x</p>
        <p><strong>Cosmic Alignment Bonus:</strong> ${formatNumber(gameState.cosmicAlignmentBonus, 2)}x</p>
        <p><strong>Astral Projection Rate:</strong> ${formatNumber(gameState.astralProjectionRate * 100, 2)}%</p>
        <p><strong>Quantum Entanglement Bonus:</strong> ${formatNumber(gameState.quantumEntanglementBonus * 100, 2)}%</p>
        <p><strong>Temporal Manipulation Bonus:</strong> ${formatNumber(gameState.temporalManipulationBonus, 2)}x</p>
        <p><strong>Eldritch Evolution Rate:</strong> ${formatNumber(gameState.eldritchEvolutionRate * 100, 2)}%</p>
        <p><strong>Active Upgrades:</strong> ${gameState.upgrades.join(', ') || 'None'}</p>
        <h3>Monster Production:</h3>
    `;

                for (let monster in gameState.monsters) {
                    if (gameState.monsters[monster].count > 0) {
                        const production = gameState.monsters[monster].count * gameState.monsters[monster].sourceEfficiency * followerBoost * monsterSynergyBoost;
                        detailsHTML += `<p>${monster}: ${formatNumber(production, 1)} source/sec</p>`;
                    }
                }

                detailsDiv.innerHTML = detailsHTML;
            }

            function calculateMonsterEfficiency(monsterType) {
                const monster = gameState.monsters[monsterType];
                let sourceEfficiency = monster.sourceEfficiency;
                let miasmaEfficiency = monster.miasmaEfficiency;

                // Apply global multipliers
                const globalMultiplier = (gameState.pacts?.commonMultiplier || 1);

                // Apply Cosmic Alignment bonus if active
                if (gameState.cosmicAlignmentBonus) {
                    sourceEfficiency *= gameState.cosmicAlignmentBonus;
                    miasmaEfficiency *= gameState.cosmicAlignmentBonus;
                }

                // Apply Quantum Entanglement bonus if active
                if (gameState.quantumEntanglementBonus) {
                    sourceEfficiency *= (1 + gameState.quantumEntanglementBonus);
                    miasmaEfficiency *= (1 + gameState.quantumEntanglementBonus);
                }

                // Apply Temporal Manipulation bonus if active
                if (gameState.temporalManipulationBonus) {
                    sourceEfficiency *= gameState.temporalManipulationBonus;
                    miasmaEfficiency *= gameState.temporalManipulationBonus;
                }

                // Apply Eldritch Evolution bonus if active
                if (gameState.eldritchEvolutionRate && monster.evolutionTime) {
                    const evolutionBonus = 1 + (gameState.eldritchEvolutionRate *
                        Math.floor((Date.now() - monster.evolutionTime) / 60000));
                    sourceEfficiency *= evolutionBonus;
                    miasmaEfficiency *= evolutionBonus;
                }

                // Apply global multiplier from pacts
                sourceEfficiency *= globalMultiplier;
                miasmaEfficiency *= globalMultiplier;

                return {
                    sourceEfficiency,
                    miasmaEfficiency
                };
            }

            function updateMonsterGrid() {
                const grid = document.getElementById('monsterGrid');
                if (!grid) {
                    console.error("Monster grid not found");
                    return;
                }

                const sourceCount = Math.floor(gameState.source);
                const followerCount = gameState.followers;

                for (let monster of monsterOrder) {
                    let card = document.getElementById(`monster-${monster}`);
                    if (!card) {
                        card = document.createElement('div');
                        card.id = `monster-${monster}`;
                        card.className = 'monster-card';
                        card.innerHTML = `
                <div class="monster-card-header">
                    <h3>${monster} (<span class="header-count">0</span>)</h3>
                    <div class="monster-details">
                        <p>Total Source Production: <span class="monster-source-production"></span>/sec</p>
                        <p>Total Miasma Production: <span class="monster-miasma-production"></span>/sec</p>
                    </div>
                </div>
                <div class="monster-card-details expanded">
                    <div class="ascii-art">${asciiArt[monster]}</div>
                    <p>Count: <span class="monster-count"></span></p>
                    <p>Source Efficiency: <span class="monster-source-efficiency"></span></p>
                    <p>Miasma Efficiency: <span class="monster-miasma-efficiency"></span></p>
                    <div class="monster-details">
                        <p>Next Summon Cost: <span class="monster-next-cost"></span> source and <span class="monster-follower-cost"></span> followers</p>
                        <p>Time to Next Summon: <span class="monster-time-to-summon"></span></p>
                        <p>Synergy: <span class="monster-synergy"></span></p>
                        <p>Special Ability: <span class="monster-special-ability"></span></p>
                    </div>
                </div>
                <div class="summon-progress-bar">
                    <div class="resource-progress source-progress"></div>
                    <div class="resource-progress follower-progress"></div>
                </div>
                <button class="summon-monster-btn" data-monster="${monster}">Summon ${monster}</button>
                <div class="unlock-requirement"></div>`;
                        grid.appendChild(card);

                        // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã®è¨­å®š
                        const header = card.querySelector('.monster-card-header');
                        const details = card.querySelector('.monster-card-details');
                        const summonBtn = card.querySelector('.summon-monster-btn');
                        summonBtn.addEventListener('click', () => summonMonster(monster));
                    }

                    const monsterData = gameState.monsters[monster];
                    if (!monsterData) {
                        console.error(`No data found for monster: ${monster}`);
                        continue;
                    }

                    // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ç¢ºèªã¨è¡¨ç¤ºæ›´æ–°
                    const isUnlocked = checkUnlockCondition('monsters', monster);
                    card.classList.toggle('locked', !isUnlocked);
                    card.classList.toggle('unlocked', isUnlocked);

                    // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®è¡¨ç¤ºåˆ¶å¾¡
                    const progressBar = card.querySelector('.summon-progress-bar');
                    const details = card.querySelector('.monster-card-details');
                    if (progressBar) {
                        progressBar.style.display = (!isUnlocked || details.classList.contains('expanded')) ? 'none' : 'block';
                    }

                    const unlockReqElement = card.querySelector('.unlock-requirement');
                    if (unlockReqElement) {
                        if (!isUnlocked) {
                            const unlockDesc = getUnlockDescription('monsters', monster);
                            unlockReqElement.textContent = `Unlock Requirement: ${unlockDesc}`;
                            unlockReqElement.style.display = 'block';
                            unlockReqElement.classList.add('unlock-requirement-text');
                        } else {
                            unlockReqElement.style.display = 'none';
                            unlockReqElement.classList.remove('unlock-requirement-text');
                        }
                    }

                    const finalEfficiencies = calculateMonsterEfficiency(monster);
                    const count = Math.floor(monsterData.count || 0);
                    const sourceEfficiency = monsterData.sourceEfficiency || 0;
                    const miasmaEfficiency = monsterData.miasmaEfficiency || 0;
                    const sourceProduction = count * finalEfficiencies.sourceEfficiency;
                    const miasmaProduction = count * finalEfficiencies.miasmaEfficiency;
                    const nextCost = getCost(monster);
                    const followerCost = Math.floor(monsterData.baseFollowerCost * Math.pow(monsterData.followerCostGrowth, count));
                    const sourceDifference = nextCost - sourceCount;
                    const { sourceProduction: currentSourceProduction } = calculateResourceProduction();
                    const timeToSummon = calculateTimeToSummon(sourceDifference, currentSourceProduction);

                    // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®æ›´æ–°
                    if (progressBar && isUnlocked) {
                        const sourceProgressEl = progressBar.querySelector('.source-progress');
                        const followerProgressEl = progressBar.querySelector('.follower-progress');

                        if (sourceProgressEl && followerProgressEl) {
                            const sourceProgress = Math.min(100, (sourceCount / nextCost) * 100);
                            const followerProgress = Math.min(100, (followerCount / followerCost) * 100);

                            sourceProgressEl.style.width = `${sourceProgress}%`;
                            followerProgressEl.style.width = `${followerProgress}%`;

                            sourceProgressEl.style.opacity = sourceProgress === 100 ? '0.8' : '0.5';
                            followerProgressEl.style.opacity = followerProgress === 100 ? '0.8' : '0.5';
                        }
                    }

                    // å„è¦ç´ ã®æ›´æ–°
                    updateElementText(card, '.monster-count', formatNumber(count, 0));
                    updateElementText(card, '.monster-source-efficiency', formatNumber(finalEfficiencies.sourceEfficiency, 1));
                    updateElementText(card, '.monster-miasma-efficiency', formatNumber(finalEfficiencies.miasmaEfficiency, 1));
                    updateElementText(card, '.monster-source-production', formatNumber(sourceProduction, 1));
                    updateElementText(card, '.monster-miasma-production', formatNumber(miasmaProduction, 1));
                    updateElementText(card, '.monster-next-cost', formatNumber(nextCost, 0));
                    updateElementText(card, '.monster-follower-cost', formatNumber(followerCost, 0));
                    updateElementText(card, '.monster-time-to-summon', formatTime(timeToSummon));
                    updateElementText(card, '.header-count', formatNumber(count, 0));

                    // ã‚·ãƒŠã‚¸ãƒ¼æƒ…å ±ã®æ›´æ–°
                    const synergyInfo = monsterData.synergy;
                    const synergyElement = card.querySelector('.monster-synergy');
                    if (synergyInfo && synergyElement) {
                        let synergyText = `+${(synergyInfo.effect * 100).toFixed(1)}% `;
                        if (synergyInfo.type) {
                            synergyText += `${synergyInfo.type} `;
                        }
                        synergyText += `production with ${synergyInfo.partner}`;
                        synergyElement.textContent = synergyText;
                    }

                    const specialAbilityInfo = monsterData.specialAbility;
                    const specialAbilityElement = card.querySelector('.monster-special-ability');
                    if (specialAbilityElement) {
                        if (specialAbilityInfo) {
                            const description = describeSpecialAbility(specialAbilityInfo);
                            specialAbilityElement.textContent = description;
                        } else {
                            specialAbilityElement.textContent = 'None';
                        }
                    }

                    // ã‚µãƒ¢ãƒ³ãƒœã‚¿ãƒ³ã®æ›´æ–°
                    const summonBtn = card.querySelector('.summon-monster-btn');
                    if (summonBtn) {
                        const canAfford = sourceCount >= nextCost && followerCount >= followerCost;
                        summonBtn.disabled = !canAfford;
                        summonBtn.classList.toggle('button-enabled', canAfford);
                        summonBtn.classList.toggle('button-disabled', !canAfford);
                    }
                }
            }

            function updateMonsterStates() {
                for (const monsterType in gameState.monsters) {
                    const monster = gameState.monsters[monsterType];
                    if (monster.count > 0) {
                        // ç‰¹æ®Šèƒ½åŠ›ã®ç™ºå‹•æ¡ä»¶ãƒã‚§ãƒƒã‚¯
                        const triggerCount = Math.floor(monster.count / monster.specialAbility.trigger);
                        if (triggerCount > 0) {
                            if (monster.specialAbility.effect.type === 'madnessChance') {
                                // madnessChanceã®æ›´æ–°ã‚’ãƒ­ã‚°ã«è¨˜éŒ²
                                debug(`${monsterType}: Applying madness chance modifier: ${monster.specialAbility.effect.value * triggerCount}`);
                            }
                        }
                    }
                }
            }

            function checkSpecialAbilityEffects() {
                for (const monsterType in gameState.monsters) {
                    const monster = gameState.monsters[monsterType];
                    if (monster.count > 0 && monster.specialAbility) {
                        const triggerCount = Math.floor(monster.count / monster.specialAbility.trigger);
                        debug(`${monsterType} special ability status:
                Count: ${monster.count}
                Triggers: ${triggerCount}
                Effect Type: ${monster.specialAbility.effect.type}
                Effect Value: ${monster.specialAbility.effect.value}
                Current Multiplier: ${gameState.madnessChanceMultiplier || 1}`);
                    }
                }
            }

            // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®æ›´æ–°æ™‚ã«ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ¶å¾¡ã™ã‚‹é–¢æ•°ã‚’ä¿®æ­£
            function updateMonsterCardLockState(card, isLocked) {
                const progressBar = card.querySelector('.summon-progress-bar');
                const details = card.querySelector('.monster-card-details');

                if (progressBar) {
                    if (isLocked) {
                        progressBar.style.display = 'none';
                    } else {
                        // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã§æŠ˜ã‚ŠãŸãŸã¾ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿è¡¨ç¤º
                        progressBar.style.display = details.classList.contains('expanded') ? 'none' : 'block';
                    }
                }
            }

            function updateMonsterCards() {
                const monsterGrid = document.getElementById('monsterGrid');
                if (!monsterGrid) return;

                // sourceCountã‚’å®šç¾©
                const sourceCount = Math.floor(gameState.source);

                // æ—¢å­˜ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ãƒ¼ãƒ‰ã®æ›´æ–°
                for (let monsterName in gameState.monsters) {
                    const monster = gameState.monsters[monsterName];
                    const card = document.getElementById(`monster-${monsterName}`);

                    if (!card) continue;

                    // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®åŸºæœ¬æƒ…å ±ã‚’æ›´æ–°
                    const countElement = card.querySelector('.monster-count');
                    if (countElement) {
                        countElement.textContent = formatNumber(monster.count, 0);
                    }

                    // ç”Ÿç”£åŠ¹ç‡ã®æ›´æ–°
                    const sourceEfficiencyElement = card.querySelector('.monster-source-efficiency');
                    if (sourceEfficiencyElement) {
                        sourceEfficiencyElement.textContent = formatNumber(monster.sourceEfficiency, 2);
                    }

                    const miasmaEfficiencyElement = card.querySelector('.monster-miasma-efficiency');
                    if (miasmaEfficiencyElement) {
                        miasmaEfficiencyElement.textContent = formatNumber(monster.miasmaEfficiency, 2);
                    }

                    // ç·ç”Ÿç”£é‡ã®æ›´æ–°
                    const sourceProduction = monster.count * monster.sourceEfficiency;
                    const miasmaProduction = monster.count * monster.miasmaEfficiency;

                    const sourceProductionElement = card.querySelector('.monster-source-production');
                    if (sourceProductionElement) {
                        sourceProductionElement.textContent = formatNumber(sourceProduction, 1);
                    }

                    const miasmaProductionElement = card.querySelector('.monster-miasma-production');
                    if (miasmaProductionElement) {
                        miasmaProductionElement.textContent = formatNumber(miasmaProduction, 1);
                    }

                    // ã‚³ã‚¹ãƒˆã®æ›´æ–°
                    const nextCost = getCost(monsterName);
                    const followerCost = Math.floor(monster.baseFollowerCost * Math.pow(monster.followerCostGrowth, monster.count));

                    const nextCostElement = card.querySelector('.monster-next-cost');
                    if (nextCostElement) {
                        nextCostElement.textContent = formatNumber(nextCost, 0);
                    }

                    const followerCostElement = card.querySelector('.monster-follower-cost');
                    if (followerCostElement) {
                        followerCostElement.textContent = formatNumber(followerCost, 0);
                    }

                    // ã‚µãƒ¢ãƒ³ãƒœã‚¿ãƒ³ã®æ›´æ–°
                    const summonBtn = card.querySelector('.summon-monster-btn');
                    if (summonBtn) {
                        const monster = gameState.monsters[monsterName];
                        const followerCost = Math.floor(monster.baseFollowerCost * Math.pow(monster.followerCostGrowth, monster.count));
                        const sourceCost = getCost(monsterName);

                        // é€šå¸¸ã®æ¡ä»¶ãƒã‚§ãƒƒã‚¯
                        const hasEnoughFollowers = gameState.followers >= followerCost;
                        const hasEnoughSource = sourceCount >= sourceCost;

                        // å¥‘ç´„ã«ã‚ˆã‚‹æœ€å°ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã®åˆ¶é™ã‚’ãƒã‚§ãƒƒã‚¯
                        let meetsMinimumRequirement = true;
                        if (gameState.pacts?.active?.includes('1')) {
                            // å¬å–šå¾Œã«æœ€å°ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã®åŠåˆ†ã‚’ä¸‹å›ã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
                            const minimumFollowers = gameState.minimumFollowers || 0;
                            meetsMinimumRequirement = (gameState.followers - followerCost) >= (minimumFollowers);
                        }

                        // ã™ã¹ã¦ã®æ¡ä»¶ã‚’æº€ãŸã™å ´åˆã®ã¿ã‚µãƒ¢ãƒ³å¯èƒ½
                        const canSummon = hasEnoughFollowers && hasEnoughSource;

                        summonBtn.disabled = !canSummon;
                        summonBtn.classList.toggle('button-enabled', canSummon);
                        summonBtn.classList.toggle('button-disabled', !canSummon);

                        // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’æ›´æ–°
                        let tooltipText = '';
                        if (!hasEnoughSource) {
                            tooltipText = `Need ${formatNumber(sourceCost - sourceCount)} more source`;
                        } else if (!hasEnoughFollowers) {
                            tooltipText = `Need ${formatNumber(followerCost - gameState.followers)} more followers`;
                        } else if (!meetsMinimumRequirement) {
                            tooltipText = `Must maintain minimum follower count (${formatNumber(gameState.minimumFollowers)})`;
                        }
                        summonBtn.title = tooltipText;
                    }

                    // ç‹‚æ°—ãƒãƒ£ãƒ³ã‚¹ã®è¡¨ç¤ºã‚’æ›´æ–°
                    const madnessChanceElement = card.querySelector('.madness-chance');
                    if (madnessChanceElement) {
                        const chance = calculateMadnessChance(adventurer);
                        madnessChanceElement.textContent = `${(chance * 100).toFixed(1)}%`;

                        // è£œæ­£ãŒé©ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯è¦–è¦šçš„ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’è¿½åŠ 
                        const hasBonus = chance > adventurer.madnessChance;
                        madnessChanceElement.classList.toggle('has-bonus', hasBonus);

                        if (hasBonus) {
                            const baseChance = adventurer.madnessChance * 100;
                            const totalChance = chance * 100;
                            madnessChanceElement.title = `Base: ${baseChance.toFixed(1)}% + Bonus: ${(totalChance - baseChance).toFixed(1)}%`;
                        }
                    }

                    // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®æ›´æ–°
                    const isUnlocked = checkUnlockCondition('monsters', monsterName);
                    card.classList.toggle('locked', !isUnlocked);
                    card.classList.toggle('unlocked', isUnlocked);
                }

                // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®æ›´æ–°
                updateProgressBars();
            }

            function updateProgressBars() {
                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ãƒ¼ãƒ‰ã®ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼æ›´æ–°
                for (let monsterType in gameState.monsters) {
                    const card = document.getElementById(`monster-${monsterType}`);
                    if (!card) continue;

                    const monster = gameState.monsters[monsterType];
                    const sourceCost = getCost(monsterType);
                    const followerCost = Math.floor(monster.baseFollowerCost *
                        Math.pow(monster.followerCostGrowth, monster.count));

                    // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’ç¢ºèª
                    let progressContainer = card.querySelector('.summon-progress-bar');
                    if (!progressContainer) continue;

                    // ãƒªã‚½ãƒ¼ã‚¹ã®é€²æ—ç‡ã‚’è¨ˆç®—
                    const sourceProgress = Math.min(100, (gameState.source / sourceCost * 100));
                    const followerProgress = Math.min(100, (gameState.followers / followerCost * 100));
                    const hasEnoughFollowers = gameState.followers >= followerCost;

                    // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®è¦ç´ ã‚’å–å¾—
                    const sourceProgressBar = progressContainer.querySelector('.source-progress');
                    const followerProgressBar = progressContainer.querySelector('.follower-progress');

                    // Sourceé€²æ—ãƒãƒ¼ã®æ›´æ–°
                    if (sourceProgressBar) {
                        sourceProgressBar.style.width = `${sourceProgress}%`;
                        sourceProgressBar.style.opacity = gameState.source >= sourceCost ? '0.8' : '0.5';
                    }

                    // Followeré€²æ—ãƒãƒ¼ã®æ›´æ–°
                    if (followerProgressBar) {
                        followerProgressBar.style.width = `${followerProgress}%`;
                        followerProgressBar.style.opacity = hasEnoughFollowers ? '0.8' : '0.5';
                        followerProgressBar.style.backgroundColor = ''; // å¸¸ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è‰²ã‚’ä½¿ç”¨
                    }

                    // ASCIIé€²æ—ãƒãƒ¼ã®æ›´æ–°
                    let asciiContainer = progressContainer.querySelector('.ascii-progress');
                    if (!asciiContainer) {
                        asciiContainer = document.createElement('div');
                        asciiContainer.className = 'ascii-progress';
                        progressContainer.appendChild(asciiContainer);
                    }

                    // å¬å–šå¯èƒ½çŠ¶æ…‹ã®åˆ¤å®š
                    const canSummon = gameState.source >= sourceCost && hasEnoughFollowers;

                    // ASCIIãƒãƒ¼ã®æ›´æ–°
                    const sourceBar = createBar(sourceProgress, 'source', true);
                    const followerBar = createBar(followerProgress, 'follower', true);

                    asciiContainer.innerHTML = `
            <div class="ascii-progress-line source">
                <span class="bar">${sourceBar}</span>
            </div>
            <div class="ascii-progress-line follower">
                <span class="bar">${followerBar}</span>
            </div>
        `;
                }
            }

            function createBar(percentage, style = 'default', canSummon = true) {
                const width = 60;
                const themes = {
                    source: {
                        start: '<span style="color: #42bd49">S: </span>',
                        end: '<span style="color: #42bd49">Â»</span>',
                        fills: [
                            '<span style="color: #064808">||</span>',
                            '<span style="color: #1a8d1d">||</span>',
                            '<span style="color: #2eb233">||</span>',
                            '<span style="color: #42bd49">||</span>'
                        ],
                        maxFills: [
                            '<span style="color: #50ff50; text-shadow: 0 0 5px #50ff50">||</span>'
                        ],
                        empty: '<span style="color: #064808"> </span>',
                    },
                    follower: {
                        start: '<span style="color: #9932CC">F: </span>',
                        end: '<span style="color: #9932CC">Â»</span>',
                        fills: [
                            '<span style="color: #4B0082">||</span>',
                            '<span style="color: #800080">||</span>',
                            '<span style="color: #9932CC">||</span>',
                            '<span style="color: #fb40fb">||</span>'
                        ],
                        maxFills: [
                            '<span style="color: #ff50ff; text-shadow: 0 0 5px #ff50ff">||</span>'
                        ],
                        empty: '<span style="color: #4B0082"> </span>',
                    }
                };

                const theme = canSummon ? themes[style] : themes.gray;
                const fillCount = Math.floor((percentage / 100) * width);
                const emptyCount = width - fillCount;

                let barContent = percentage >= 100 ?
                    theme.maxFills[0].repeat(fillCount) :
                    Array.from({ length: fillCount }, (_, i) =>
                        theme.fills[Math.floor((i / width) * theme.fills.length)]).join('');

                return `${theme.start}${barContent}${theme.empty.repeat(emptyCount)}${theme.end}`;
            }

            function describeSpecialAbility(ability) {
                if (!ability) return 'None';

                const { trigger, effect } = ability;
                if (!effect) return 'Invalid special ability';

                // Effect description based on type
                let effectDescription;
                switch (effect.type) {
                    case 'allMonsterEfficiency':
                        effectDescription = `Increase all monster efficiency by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    case 'miasmaEfficiency':
                        effectDescription = `Increase miasma production by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    case 'followerEfficiency':
                        effectDescription = `Increase follower efficiency by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    case 'sourceProduction':
                        effectDescription = `Increase source production by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    case 'upgradeEffect':
                        effectDescription = `Increase all upgrade effects by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    case 'followerProduction':
                        effectDescription = `Increase follower production by ${effect.value.toFixed(1)} per second`;
                        break;
                    case 'cosmicResonance':
                        effectDescription = `Increase all production by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    case 'upgradeCost':
                        effectDescription = `Reduce upgrade costs by ${(effect.value * 100).toFixed(1)}% (max ${(effect.maxDiscount * 100).toFixed(1)}%)`;
                        break;
                    case 'adventurerResistanceRecoveryTime':
                        effectDescription = `Reduce adventurer resistance cooldown by ${(effect.value / 1000).toFixed(1)} second(s)`;
                        break;
                    case 'madnessChance':
                        effectDescription = `Increase madness chance by ${(effect.value * 100).toFixed(1)}%`;
                        break;
                    default:
                        effectDescription = 'Unknown effect type';
                }

                return `Every ${trigger} ${trigger === 1 ? 'summon' : 'summons'}: ${effectDescription}`;
            }

            // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®šã™ã‚‹é–¢æ•°
            function setupMonsterEventListeners() {
                const monsterButtons = document.querySelectorAll('.summon-monster-btn');
                monsterButtons.forEach(button => {
                    button.removeEventListener('click', handleMonsterSummon); // æ—¢å­˜ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
                    button.addEventListener('click', handleMonsterSummon); // æ–°ã—ã„ãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                });
            }

            // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å¬å–šãƒãƒ³ãƒ‰ãƒ©ãƒ¼
            function handleMonsterSummon(event) {
                const monsterType = event.target.dataset.monster;
                if (monsterType) {
                    summonMonster(monsterType);
                }
            }

            // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼UIã‚’å†æ§‹ç¯‰ã™ã‚‹æ–°ã—ã„é–¢æ•°
            function rebuildMonsterUI() {
                const monsterGrid = document.getElementById('monsterGrid');
                if (monsterGrid) {
                    monsterGrid.innerHTML = ''; // ã‚°ãƒªãƒƒãƒ‰ã‚’ã‚¯ãƒªã‚¢
                    updateMonsterGrid(); // ã‚°ãƒªãƒƒãƒ‰ã‚’å†æ§‹ç¯‰
                }

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å†è¨­å®š
                setupMonsterEventListeners();
            }

            // Add visual effects for pact modal
            function animatePactModal() {
                const modal = document.querySelector('.pact-modal');
                const content = document.querySelector('.pact-content');
                const description = document.querySelector('.pact-description');
                const effects = document.querySelectorAll('.pact-effect');

                // Fade in modal
                modal.style.opacity = '0';
                modal.style.display = 'flex';
                setTimeout(() => {
                    modal.style.opacity = '1';
                }, 10);

                // Slide up animation
                content.style.transform = 'translateY(50px)';
                setTimeout(() => {
                    content.style.transform = 'translateY(0)';
                }, 500);

                // Text reveal animation
                description.innerHTML = '';
                let i = 0;
                const text = PACTS[1].description;
                function revealText() {
                    if (i < text.length) {
                        description.innerHTML += text.charAt(i);
                        i++;
                        setTimeout(revealText, 30);
                    }
                }
                setTimeout(revealText, 1000);

                // Effects fade in  
                effects.forEach((effect, index) => {
                    effect.style.opacity = '0';
                    effect.style.transform = 'translateX(-20px)';
                    setTimeout(() => {
                        effect.style.opacity = '1';
                        effect.style.transform = 'translateX(0)';
                    }, 1500 + (index * 200));
                });
            }

            // Update follower ASCII art with new appearance
            function updateFollowerAsciiArt(newArt, tooltipText) {
                const followerArt = document.getElementById('followerAsciiArt');
                if (followerArt) {
                    followerArt.classList.add('transforming');

                    setTimeout(() => {
                        followerArt.innerHTML = newArt;
                        followerArt.classList.remove('transforming');
                        followerArt.classList.add('transformed');
                    }, 1000);
                }
            }

            // Add visual feedback for pact activation
            function addPactVisualEffects() {
                const gameContainer = document.querySelector('.container');
                if (gameContainer) {
                    gameContainer.classList.add('pact-active');
                    setTimeout(() => {
                        gameContainer.classList.remove('pact-active');
                    }, 2000);
                }
            }

            function hideManualRecruitButtons() {
                const elements = [
                    document.getElementById('recruitFollowerBtn'),
                    document.getElementById('collectSource'),
                    ...document.querySelectorAll('.recruit-follower-btn')
                ];

                elements.forEach(element => {
                    if (element) {
                        element.style.display = 'none';
                        element.disabled = true;
                        element.classList.add('sealed-by-pact');
                    }
                });

                // ãƒªã‚¯ãƒ«ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ã‚³ãƒ³ãƒ†ãƒŠã‚‚éè¡¨ç¤ºã«
                const recruitContainer = document.querySelector('.recruit-container');
                if (recruitContainer) {
                    recruitContainer.style.display = 'none';
                    recruitContainer.classList.add('sealed-by-pact');
                }
            }

            function showManualRecruitButtons() {
                try {
                    // å…¨ã¦ã®ãƒªã‚¯ãƒ«ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚’å–å¾—
                    const sourceBtn = document.getElementById('collectSource');
                    const followerBtn = document.getElementById('recruitFollowerBtn');
                    const recruitButtons = document.querySelectorAll('.recruit-follower-btn');

                    // sealed-by-pactã‚¯ãƒ©ã‚¹ãŒä»˜ã„ã¦ã„ã‚‹ãƒœã‚¿ãƒ³ã®ã¿è¡¨ç¤ºã‚’æˆ»ã™
                    [sourceBtn, followerBtn, ...recruitButtons].forEach(btn => {
                        if (btn && btn.classList.contains('sealed-by-pact')) {
                            btn.style.display = 'block';
                            btn.classList.remove('sealed-by-pact');
                            btn.disabled = false;
                        }
                    });

                    // ãƒªã‚¯ãƒ«ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ã‚³ãƒ³ãƒ†ãƒŠã‚‚è¡¨ç¤ºã‚’æˆ»ã™
                    const recruitContainer = document.querySelector('.recruit-container.sealed-by-pact');
                    if (recruitContainer) {
                        recruitContainer.style.display = 'block';
                        recruitContainer.classList.remove('sealed-by-pact');
                    }

                    //console.log("Manual recruit buttons shown");
                } catch (error) {
                    console.error("Error showing manual recruit buttons:", error);
                }
            }

            // å¥‘ç´„ãƒã‚§ãƒƒã‚¯é–¢æ•° - ã™ã¹ã¦ã®å¥‘ç´„ã«å¯¾å¿œ
            function checkPacts() {
                if (!gameState.pacts.showingPactModal) {
                    // ç¬¬1ã®å¥‘ç´„ãƒã‚§ãƒƒã‚¯
                    if (!gameState.pacts.active.includes('1') && gameState.source >= 1e6 - 1) {
                        showPactModal(1);
                        return;
                    }
                    // ç¬¬2ã®å¥‘ç´„ãƒã‚§ãƒƒã‚¯
                    if (gameState.pacts.active.includes('1') && !gameState.pacts.active.includes('2') &&
                        gameState.source >= 1e28 - 1) {
                        showPactModal(2);
                        return;
                    }
                }
            }

            // å¥‘ç´„ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹å…±é€šé–¢æ•°
            function showPactModal(pactId) {
                const pact = PACTS[pactId];
                if (!pact) return;

                gameState.pacts.showingPactModal = true;
                gamePaused = true;

                const effectsList = pact.effects
                    .map(effect => `<li class="pact-effect">${effect.description}</li>`)
                    .join('');

                const modalHtml = `
    <div class="pact-modal">
        <div class="pact-content">
            <h2 class="pact-title">${pact.name}</h2>
            <div class="pact-scroll">
                <p class="pact-description">${pact.description}</p>
                <p class="pact-flavor">${pact.flavorText}</p>
                <ul class="pact-effects">${effectsList}</ul>
                <p class="pact-warning">${pact.warning}</p>
            </div>
            <div class="pact-buttons">
                <button onclick="acceptPact(${pactId})">Accept Contract</button>
                <button onclick="declinePact()" class="decline-btn">Decline</button>
            </div>
        </div>
    </div>`;

                document.body.insertAdjacentHTML('beforeend', modalHtml);
                animatePactModal();
            }

            // PACTã®çŠ¶æ…‹ã‚’è¿½è·¡ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’gameStateã«è¿½åŠ 
            if (!gameState.pacts) {
                gameState.pacts = {
                    active: [],
                    currentFollowerArt: null,
                    commonMultiplier: 1,
                    tickSpeedMultiplier: 1,
                    showingPactModal: false
                };
            }

            function applyPactEffects(pact) {
                pact.effects.forEach(effect => {
                    switch (effect.type) {
                        case "minimumFollowers":
                            gameState.minimumFollowers = Math.max(gameState.minimumFollowers || 0, effect.value);
                            gameState.followers = Math.max(gameState.followers || 0, effect.value);
                            break;
                        case "followerEfficiency":
                            gameState.followerEfficiency = (gameState.followerEfficiency || 0.1) * (1 + effect.value);
                            break;
                        case "globalMultiplier":
                            gameState.pacts.commonMultiplier *= (1 + effect.value);
                            break;
                        case "tickSpeed":
                            gameState.pacts.tickSpeedMultiplier *= (1 + effect.value);
                            break;
                        case "sealManualRecruits":
                            hideManualRecruitButtons();
                            break;
                    }
                });
            }

            // PACTã«ç‰¹æœ‰ã®UIæ›´æ–°ã‚’è¡Œã†é–¢æ•°
            function updatePactSpecificUI() {
                // æ‰‹å‹•ãƒªã‚¯ãƒ«ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
                if (gameState.pacts.active.includes('1')) {
                    hideManualRecruitButtons();
                } else {
                    showManualRecruitButtons();
                }

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®å¤–è¦³ã‚’æ›´æ–°
                updateFollowerAppearance();

                // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®é †åºã‚’ç¢ºå®Ÿã«ç¶­æŒ
                const upgradeGrid = document.getElementById('upgradeGrid');
                if (upgradeGrid) {
                    upgradeGrid.innerHTML = '';
                    updateUpgradeGrid();
                }

                // ã‚¨ãƒ³ãƒ–ãƒ¬ãƒ ã‚’æ›´æ–°
                updateCultosMiner();

                // tick speedè¡¨ç¤ºã‚’æ›´æ–°
                updateTimeAccelerationDisplay();

                // çµ±è¨ˆæƒ…å ±ã‚’æ›´æ–°
                if (document.getElementById('statisticsModal')?.classList.contains('active')) {
                    updateStatistics();
                }
            }


            // PACTé©ç”¨æ™‚ã®å‡¦ç†ã‚’æ”¹å–„
            function applyPact(pactId) {
                const pact = PACTS[pactId];
                if (!pact) return;

                // ç¾åœ¨ã®ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã‚’ä¿å­˜
                const currentFollowers = gameState.followers;

                // å¥‘ç´„ã«ã‚ˆã‚‹æœ€å°ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã‚’è¨ˆç®—
                let minimumFollowers = 0;
                pact.effects.forEach(effect => {
                    if (effect.type === "minimumFollowers") {
                        minimumFollowers = Math.max(minimumFollowers, effect.value);
                    }
                });

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã‚’æ›´æ–°ï¼ˆç¾åœ¨ã®æ•°ã¨æœ€å°å€¤ã®åŠåˆ†ã®å¤§ãã„æ–¹ã‚’ç¶­æŒï¼‰
                gameState.followers = Math.max(currentFollowers, minimumFollowers);

                // PACTã®åŠ¹æœã‚’é©ç”¨
                pact.effects.forEach(effect => {
                    switch (effect.type) {
                        case "minimumFollowers":
                            gameState.minimumFollowers = effect.value;
                            break;
                        case "followerEfficiency":
                            gameState.followerEfficiency *= (1 + effect.value);
                            break;
                        case "globalMultiplier":
                            gameState.pacts.commonMultiplier *= (1 + effect.value);
                            break;
                        case "tickSpeed":
                            gameState.pacts.tickSpeedMultiplier *= (1 + effect.value);
                            break;
                    }
                });

                // PACTã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒªã‚¹ãƒˆã«è¿½åŠ 
                if (!gameState.pacts.active.includes(pactId)) {
                    gameState.pacts.active.push(pactId);
                }

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®ã‚¢ãƒ¼ãƒˆã‚’æ›´æ–°
                gameState.pacts.currentFollowerArt = pact.followerAsciiArt;
                gameState.pacts.currentTooltipText = pact.tooltipText;

                // UIæ›´æ–°ã‚’å®Ÿè¡Œ
                updateFollowerAppearance();
                rebuildUI();

                // è¦–è¦šåŠ¹æœã‚’è¿½åŠ 
                addPactVisualEffects();
                logAction(`The ${pact.name} has been sealed`);

                // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’ä¿å­˜
                saveGame();
            }

            // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®å¤–è¦³ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°ã‚’æ”¹å–„
            function updateFollowerAppearance() {
                const followerArt = document.getElementById('followerAsciiArt');
                if (!followerArt) return;

                // æœ€æ–°ã®PACTã®ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã‚¢ãƒ¼ãƒˆã‚’å–å¾—
                let currentArt = null;
                let currentTooltip = null;

                if (gameState.pacts?.active?.length > 0) {
                    const lastPactId = gameState.pacts.active[gameState.pacts.active.length - 1];
                    const lastPact = PACTS[lastPactId];
                    if (lastPact) {
                        currentArt = lastPact.followerAsciiArt;
                        currentTooltip = lastPact.tooltipText;
                    }
                }

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãã§æ›´æ–°
                followerArt.classList.add('transforming');

                setTimeout(() => {
                    if (currentArt) {
                        followerArt.innerHTML = currentArt;
                        followerArt.setAttribute('data-tooltip', currentTooltip || '');
                        followerArt.classList.add('pact-transformed');
                    } else {
                        followerArt.innerHTML = asciiArt['Follower'];
                        followerArt.removeAttribute('data-tooltip');
                        followerArt.classList.remove('pact-transformed');
                    }
                    followerArt.classList.remove('transforming');
                }, 1000);
            }

            // å¥‘ç´„ã®è¦–è¦šåŠ¹æœã‚’æ›´æ–°ã™ã‚‹å…±é€šé–¢æ•°
            function updatePactVisuals(pact) {
                if (!pact) return;

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®ASCII artã¨ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’æ›´æ–°
                updateFollowerAsciiArt(pact.followerAsciiArt, pact.tooltipText);

                // è¦–è¦šåŠ¹æœã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                const gameContainer = document.querySelector('.container');
                if (gameContainer) {
                    gameContainer.classList.add('pact-active');
                    setTimeout(() => {
                        gameContainer.classList.remove('pact-active');
                    }, 2000);
                }

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®å¤‰èº«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                const followerArt = document.getElementById('followerAsciiArt');
                if (followerArt) {
                    followerArt.classList.add('transforming');
                    setTimeout(() => {
                        followerArt.classList.remove('transforming');
                        followerArt.classList.add('transformed');
                    }, 1000);
                }
            }

            // acceptPacté–¢æ•°ã‚’å®Œå…¨ã«æ›¸ãç›´ã—
            function acceptPact(pactId) {
                try {
                    console.log("Accepting pact:", pactId);

                    // å¥‘ç´„ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                    closePactModal();

                    // ç¾åœ¨ã®é‡è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                    const persistentData = {
                        statistics: { ...gameState.statistics },
                        pacts: {
                            active: [...(gameState.pacts?.active || []), pactId.toString()],
                            commonMultiplier: (gameState.pacts?.commonMultiplier || 1) * 1.25, // 25%å¢—åŠ 
                            tickSpeedMultiplier: (gameState.pacts?.tickSpeedMultiplier || 1) * 1.25,
                            showingPactModal: false
                        },
                        cultos: gameState.cultos || 0,
                        cultosRate: gameState.cultosRate || 0,
                        minimumFollowers: 0
                    };

                    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’åˆæœŸçŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆ
                    gameState = JSON.parse(JSON.stringify(initialGameState));

                    // æ°¸ç¶šãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒ
                    gameState.statistics = persistentData.statistics;
                    gameState.pacts = persistentData.pacts;
                    gameState.cultos = persistentData.cultos;
                    gameState.cultosRate = persistentData.cultosRate;

                    // åˆæœŸã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’è¨­å®š
                    gameState.unlockedContent = {
                        monsters: new Set(['Shoggoth']),
                        adventurers: new Set(['Novice Explorer']),
                        upgrades: new Set(['Ritual Knowledge']),
                        resources: new Set()
                    };

                    // PACTåŠ¹æœã®å³æ™‚é©ç”¨
                    const pact = PACTS[pactId];
                    if (pact) {
                        pact.effects.forEach(effect => {
                            switch (effect.type) {
                                case "minimumFollowers":
                                    persistentData.minimumFollowers = Math.max(persistentData.minimumFollowers, effect.value);
                                    gameState.followers = effect.value; // æœ€å°å€¤ã‚’ç›´æ¥è¨­å®š
                                    break;
                                case "followerEfficiency":
                                    gameState.followerEfficiency *= (1 + effect.value);
                                    break;
                                case "sealManualRecruits":
                                    // æ‰‹å‹•ãƒªã‚¯ãƒ«ãƒ¼ãƒˆã‚’å³åº§ã«ç„¡åŠ¹åŒ–
                                    const recruitBtn = document.getElementById('recruitFollowerBtn');
                                    if (recruitBtn) {
                                        recruitBtn.style.display = 'none';
                                        recruitBtn.disabled = true;
                                        recruitBtn.classList.add('sealed-by-pact');
                                    }
                                    const collectSourceBtn = document.getElementById('collectSource');
                                    if (collectSourceBtn) {
                                        collectSourceBtn.style.display = 'none';
                                        collectSourceBtn.disabled = true;
                                        collectSourceBtn.classList.add('sealed-by-pact');
                                    }
                                    break;
                            }
                        });
                    }

                    // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®å¤–è¦³ã‚’å³åº§ã«æ›´æ–°
                    const followerArt = document.getElementById('followerAsciiArt');
                    if (followerArt && pact.followerAsciiArt) {
                        followerArt.innerHTML = pact.followerAsciiArt;
                        if (pact.tooltipText) {
                            followerArt.setAttribute('data-tooltip', pact.tooltipText);
                        }
                        followerArt.classList.add('transformed');
                    }

                    // DOMã®å®Œå…¨ãªå†æ§‹ç¯‰
                    resetDOM();
                    rebuildUI();

                    // è¿½åŠ ã®UIæ›´æ–°
                    updateResourceDisplay();
                    updateCultosMiner();
                    updateTimeAccelerationDisplay();
                    updateUpgradeSymbols();
                    updateButtonStates();

                    // ã“ã®æ™‚ç‚¹ã§ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’å¼·åˆ¶çš„ã«æ›´æ–°
                    if (pactId === '1') {
                        const allRecruitButtons = document.querySelectorAll('.recruit-follower-btn, #recruitFollowerBtn');
                        allRecruitButtons.forEach(btn => {
                            btn.style.display = 'none';
                            btn.disabled = true;
                            btn.classList.add('sealed-by-pact');
                        });
                    }

                    // ã‚²ãƒ¼ãƒ ã‚’å†é–‹
                    gamePaused = false;

                    // çŠ¶æ…‹ã‚’ä¿å­˜
                    saveGame();

                    logAction(`The ${PACTS[pactId].name} has been sealed - Progress has been reset`);

                    // å³åº§ã«ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚°ãƒªãƒƒãƒ‰ã‚’æ›´æ–°
                    const upgradeGrid = document.getElementById('upgradeGrid');
                    if (upgradeGrid) {
                        upgradeGrid.innerHTML = '';
                        updateUpgradeGrid();
                    }

                    return true;

                } catch (error) {
                    console.error("Error accepting pact:", error);
                    return false;
                }
            }

            function closePactModal() {
                try {
                    const modal = document.querySelector('.pact-modal');
                    if (modal) {
                        modal.remove();
                    }
                    gameState.pacts.showingPactModal = false;
                    gamePaused = false;
                    console.log("Modal closed successfully");
                } catch (error) {
                    console.error("Error closing modal:", error);
                }
            }

            // ã‚²ãƒ¼ãƒ ãƒ­ãƒ¼ãƒ‰æ™‚ã®ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼å¤–è¦³æ›´æ–°ã‚’ç¢ºå®Ÿã«è¡Œã†
            const existingLoadGame = window.loadGame;
            window.loadGame = function () {
                const result = existingLoadGame.apply(this, arguments);

                if (result && gameState.pacts?.active?.length > 0) {
                    const lastPactId = gameState.pacts.active[gameState.pacts.active.length - 1];
                    const pact = PACTS[lastPactId];

                    if (pact) {
                        const followerArt = document.getElementById('followerAsciiArt');
                        if (followerArt) {
                            followerArt.innerHTML = pact.followerAsciiArt;
                            if (pact.tooltipText) {
                                followerArt.setAttribute('data-tooltip', pact.tooltipText);
                            }
                            followerArt.classList.add('transformed');
                        }
                    }
                }

                return result;
            };

            // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ›´æ–°æ™‚ã«ã‚‚å¤–è¦³ã‚’ç¢ºèª
            const existingUpdateFollowerSection = window.updateFollowerSection;
            window.updateFollowerSection = function () {
                existingUpdateFollowerSection.apply(this, arguments);

                if (gameState.pacts?.active?.length > 0) {
                    const lastPactId = gameState.pacts.active[gameState.pacts.active.length - 1];
                    const pact = PACTS[lastPactId];

                    if (pact) {
                        const followerArt = document.getElementById('followerAsciiArt');
                        if (followerArt) {
                            followerArt.innerHTML = pact.followerAsciiArt || asciiArt['Follower'];
                            if (pact.tooltipText) {
                                followerArt.setAttribute('data-tooltip', pact.tooltipText);
                            }
                        }
                    }
                }
            };

            // å¥‘ç´„æ‹’å¦å…±é€šé–¢æ•°
            function declinePact() {
                closePactModal();
                gamePaused = false;
            }

            // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—å†…ã§ã®å¥‘ç´„åŠ¹æœã®é©ç”¨
            function updatePactEffects() {
                if (!gameState.pacts?.active) return;

                // ç¾åœ¨ã®ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã‚’ä¿å­˜
                const currentFollowers = gameState.followers;
                let minimumFollowers = 0;

                // ã™ã¹ã¦ã®æœ‰åŠ¹ãªå¥‘ç´„ã‹ã‚‰æœ€å°ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã‚’è¨ˆç®—
                gameState.pacts.active.forEach(pactId => {
                    const pact = PACTS[pactId];
                    if (pact) {
                        const minFollowersEffect = pact.effects.find(e => e.type === "minimumFollowers");
                        if (minFollowersEffect) {
                            minimumFollowers = Math.max(minimumFollowers, minFollowersEffect.value);
                        }
                    }
                });

                // æœ€å°ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã‚’ä¿å­˜
                gameState.minimumFollowers = minimumFollowers;

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã‚’èª¿æ•´ï¼ˆç¾åœ¨ã®æ•°ã¨æœ€å°å€¤ã®åŠåˆ†ã®å¤§ãã„æ–¹ã‚’ç¶­æŒï¼‰
                gameState.followers = Math.max(currentFollowers, minimumFollowers);
            }

            // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹éš›ã®å¥‘ç´„ã®å¾©å…ƒ
            function restorePacts() {
                if (gameState.pacts && gameState.pacts.active) {
                    gameState.pacts.active.forEach(pactId => {
                        if (!gameState.pacts.applied.includes(pactId)) {  // è¿½åŠ : ã™ã§ã«é©ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
                            applyPact(parseInt(pactId));
                            gameState.pacts.applied.push(pactId);  // è¿½åŠ : é©ç”¨æ¸ˆã¿ãƒªã‚¹ãƒˆã«è¿½åŠ 
                        }
                    });
                }
            }

            // ã‚²ãƒ¼ãƒ åˆæœŸåŒ–æ™‚ã«å¥‘ç´„ã‚·ã‚¹ãƒ†ãƒ ã‚’è¨­å®š
            function initializePactSystem() {
                if (!gameState.pacts) {
                    gameState.pacts = {
                        active: [],
                        applied: [],  // è¿½åŠ : é©ç”¨æ¸ˆã¿ã®å¥‘ç´„ã‚’è¿½è·¡ã™ã‚‹ãƒªã‚¹ãƒˆ
                        commonMultiplier: 1,
                        tickSpeedMultiplier: 1,
                        showingPactModal: false
                    };
                }
            }

            function addPactVisualEffects() {
                const gameContainer = document.querySelector('.container');
                if (gameContainer) {
                    gameContainer.classList.add('pact-active');
                    setTimeout(() => {
                        gameContainer.classList.remove('pact-active');
                    }, 2000);
                }
            }

            function formatTime(seconds) {
                // tick speedã‚’è€ƒæ…®ã—ã¦æ™‚é–“ã‚’èª¿æ•´
                seconds = seconds / timeAcceleration;

                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = Math.floor(seconds % 60);

                let timeString = '';
                if (hours > 0) timeString += `${hours}h `;
                if (minutes > 0 || hours > 0) timeString += `${minutes}m `;
                timeString += `${remainingSeconds}s`;

                return timeString.trim();
            }

            // logAction é–¢æ•°ã®å†å®šç¾©
            function logAction(message) {
                const log = document.getElementById('log');
                if (log) {
                    const p = document.createElement('p');
                    // æ•°å€¤ã‚’å«ã‚€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å ´åˆã€formatNumberé–¢æ•°ã‚’ä½¿ç”¨ã—ã¦æ•´å½¢
                    p.textContent = message.replace(/\d+(\.\d+)?/g, match => formatNumber(parseFloat(match)));
                    log.insertBefore(p, log.firstChild);
                    if (log.childElementCount > 20) {
                        log.removeChild(log.lastChild);
                    }
                }
                debug(`Log: ${message}`);
            }

            function debugGameState() {
                debug("Current game state:");
                debug(`Source: ${gameState.source}`);
                debug(`Miasma: ${gameState.miasma}`);
                debug(`Followers: ${gameState.followers}`);
                debug(`Follower Efficiency: ${gameState.followerEfficiency}`);

                if (typeof gameState.source !== 'number') debug("WARNING: source is not a number");
                if (typeof gameState.miasma !== 'number') debug("WARNING: miasma is not a number");
                if (typeof gameState.followers !== 'number') debug("WARNING: followers is not a number");
                if (typeof gameState.followerEfficiency !== 'number') debug("WARNING: followerEfficiency is not a number");
            }

            // ã‚»ãƒ¼ãƒ–å‰ã®çŠ¶æ…‹æ¤œè¨¼
            function validateBeforeSave() {
                const numericProps = ['source', 'miasma', 'followers', 'followerEfficiency'];
                let isValid = true;

                numericProps.forEach(prop => {
                    if (typeof gameState[prop] !== 'number' || isNaN(gameState[prop])) {
                        debug(`Invalid ${prop} before save: ${gameState[prop]}`);
                        gameState[prop] = 0;
                        isValid = false;
                    }
                });

                return isValid;
            }

            function saveGame() {
                try {
                    // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®ç¢ºèª
                    if (!Array.isArray(gameState.upgrades)) {
                        gameState.upgrades = [];
                    }

                    // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®é‡è¤‡æ’é™¤ã¨æ¤œè¨¼
                    gameState.upgrades = [...new Set(gameState.upgrades)].filter(
                        upgrade => upgradeDefinitions.hasOwnProperty(upgrade)
                    );

                    // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®ç¢ºèª
                    if (!gameState.unlockedContent) {
                        gameState.unlockedContent = {
                            adventurers: new Set(['Novice Explorer']),
                            monsters: new Set(['Shoggoth']),
                            upgrades: new Set(['Ritual Knowledge']),
                            resources: new Set()
                        };
                    }

                    // ä¿å­˜ç”¨ã®ã‚¹ãƒ†ãƒ¼ãƒˆä½œæˆ
                    const saveState = {
                        ...JSON.parse(JSON.stringify({
                            ...gameState,
                            unlockedContent: null // ä¸€æ™‚çš„ã«é™¤å¤–
                        })),
                        // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’é…åˆ—ã¨ã—ã¦ä¿å­˜
                        unlockedContent: {
                            monsters: Array.from(gameState.unlockedContent.monsters || new Set()),
                            adventurers: Array.from(gameState.unlockedContent.adventurers || new Set()),
                            upgrades: Array.from(gameState.unlockedContent.upgrades || new Set()),
                            resources: Array.from(gameState.unlockedContent.resources || new Set())
                        },
                        // upgradeOrderã‚’ä¿å­˜
                        upgradeOrder: upgradeOrder,
                        // ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±
                        version: gameVersion
                    };

                    // PACTã®çŠ¶æ…‹ã‚’ç¢ºå®Ÿã«ä¿å­˜
                    if (saveState.pacts?.active?.includes('1')) {
                        saveState.pacts.sealedRecruits = true;
                    }

                    // ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                    localStorage.setItem('cultistComplexSave', JSON.stringify(saveState));

                    console.log('[DEBUG] Game saved successfully');

                    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ä½œæˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
                    try {
                        localStorage.setItem('cultistComplexSave_backup', JSON.stringify(saveState));
                    } catch (backupError) {
                        console.warn('Failed to create backup:', backupError);
                    }

                    return true;

                } catch (error) {
                    console.error('Error saving game:', error);
                    logAction("Failed to save game: " + error.message);
                    return false;
                }
            }

            function setupAutoSave() {
                const autoSaveInterval = 5 * 60 * 1000; // 5åˆ†ã”ã¨
                setInterval(saveGame, autoSaveInterval);
            }

            // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
            function createBackup() {
                const currentSave = localStorage.getItem('cultistComplexSave');
                if (currentSave) {
                    localStorage.setItem('cultistComplexSave_backup', currentSave);
                    debug("Backup created");
                }
            }

            // ã‚²ãƒ¼ãƒ ãƒ­ãƒ¼ãƒ‰æ™‚ã®unlockedContentå¾©å…ƒé–¢æ•°
            function loadUnlockedContent(savedContent) {
                return {
                    monsters: new Set(savedContent.monsters || ['Shoggoth']),
                    adventurers: new Set(savedContent.adventurers || ['Novice Explorer']),
                    upgrades: new Set(savedContent.upgrades || ['Ritual Knowledge']),
                    resources: new Set(savedContent.resources || [])
                };
            }

            function loadGame() {
                try {
                    const savedGame = localStorage.getItem('cultistComplexSave');
                    if (!savedGame) {
                        logAction("No saved game found, starting new game");
                        return false;
                    }

                    const loadedState = JSON.parse(savedGame);

        // åŸºæœ¬å€¤ã«ãƒªã‚»ãƒƒãƒˆï¼ˆå¥‘ç´„åŠ¹æœã‚’é©ç”¨ã™ã‚‹å‰ã®åˆæœŸå€¤ï¼‰
        const baseEfficiency = loadedState.followerEfficiency || 0.1; // ä¿å­˜ã•ã‚ŒãŸåŠ¹ç‡å€¤ã‚’ä½¿ç”¨
        const baseMultiplier = 1;

                    // gameStateã‚’æ›´æ–°ã™ã‚‹å‰ã«åŠ¹ç‡å€¤ã‚’ãƒªã‚»ãƒƒãƒˆ
                    gameState = {
                        ...loadedState,
                        followerEfficiency: baseEfficiency,
                        pacts: {
                            ...loadedState.pacts,
                            commonMultiplier: baseMultiplier,
                            tickSpeedMultiplier: baseMultiplier
                        }
                    };

                    // unlockedContentã®å¾©å…ƒ
                    gameState.unlockedContent = {
                        monsters: new Set(loadedState.unlockedContent.monsters || ['Shoggoth']),
                        adventurers: new Set(loadedState.unlockedContent.adventurers || ['Novice Explorer']),
                        upgrades: new Set(loadedState.unlockedContent.upgrades || ['Ritual Knowledge']),
                        resources: new Set(loadedState.unlockedContent.resources || [])
                    };

                    // ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã‚’ä¸€æ™‚ä¿å­˜
                    const savedFollowers = loadedState.followers || 0;

                    // PACTã®çŠ¶æ…‹ã‚’ç¢ºèªã—ã€å¿…è¦ã«å¿œã˜ã¦ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤ºã«
                    if (gameState.pacts?.active?.includes('1')) {
                        hideManualRecruitButtons();
                    }
                    // PACTã®åŠ¹æœã‚’å†é©ç”¨
                    if (gameState.pacts?.active?.length > 0) {
                        gameState.pacts.active.forEach(pactId => {
                            if (PACTS[pactId]) {
                                const pact = PACTS[pactId];
                                if (pact) {
                                    pact.effects.forEach(effect => {
                                        switch (effect.type) {
                                            case "minimumFollowers":
                                                gameState.minimumFollowers = Math.max(gameState.minimumFollowers || 0, effect.value);
                                                break;
                                            case "followerEfficiency":
                                                gameState.followerEfficiency *= (1 + effect.value);
                                                break;
                                            case "globalMultiplier":
                                                gameState.pacts.commonMultiplier *= (1 + effect.value);
                                                break;
                                            case "tickSpeed":
                                                gameState.pacts.tickSpeedMultiplier *= (1 + effect.value);
                                                break;
                                        }
                                    });
                                }
                            }
                        });
                    }

                    // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã‚’æ›´æ–°ï¼ˆæœ€å°å€¤ã‚’è€ƒæ…®ï¼‰
                    gameState.followers = Math.max(savedFollowers, gameState.minimumFollowers || 0);

                    // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ã®å‡¦ç†
                    const lastUpdateTime = gameState.statistics?.lastUpdate || Date.now();
                    const currentTime = Date.now();
                    const offlineTime = currentTime - lastUpdateTime;

                    // æœ€å°ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚é–“ï¼ˆ1åˆ†ï¼‰ã‚’è¶…ãˆã¦ã„ã‚‹å ´åˆã®ã¿å‡¦ç†
                    if (offlineTime >= 60 * 1000) {
                        const progress = processOfflineProgress(offlineTime);

                        // DOMãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
                        if (document.readyState === 'complete') {
                            showOfflineProgressModal(progress);
                        } else {
                            window.addEventListener('load', () => {
                                showOfflineProgressModal(progress);
                            });
                        }
                    }

                    // çµ±è¨ˆæƒ…å ±ã‚’æ›´æ–°
                    if (gameState.statistics) {
                        gameState.statistics.lastUpdate = Date.now();
                    }

                    // è¡¨ç¤ºã‚’æ›´æ–°
                    updateAllDisplays();
                    updateTimeAccelerationDisplay();

                    logAction("Game loaded successfully");
                    return true;

                } catch (error) {
                    console.error("Error loading game:", error);
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯åˆæœŸçŠ¶æ…‹ã‚’è¨­å®š
                    gameState.unlockedContent = {
                        monsters: new Set(['Shoggoth']),
                        adventurers: new Set(['Novice Explorer']),
                        upgrades: new Set(['Ritual Knowledge']),
                        resources: new Set()
                    };
                    return false;
                }
            }

            // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
            function isValidJSON(str) {
                try {
                    JSON.parse(str);
                    return true;
                } catch (e) {
                    return false;
                }
            }

            function validateGameState() {
                try {
                    // unlockedContentã®æ¤œè¨¼ã¨ä¿®æ­£
                    if (!gameState.unlockedContent) {
                        gameState.unlockedContent = {
                            adventurers: new Set(['Novice Explorer']),
                            monsters: new Set(['Shoggoth']),
                            upgrades: new Set(['Ritual Knowledge']),
                            resources: new Set()
                        };
                    } else {
                        // å„ã‚«ãƒ†ã‚´ãƒªãƒ¼ã®å­˜åœ¨ç¢ºèªã¨Setå‹ã¸ã®å¤‰æ›
                        const categories = ['adventurers', 'monsters', 'upgrades', 'resources'];
                        for (const category of categories) {
                            if (!gameState.unlockedContent[category]) {
                                gameState.unlockedContent[category] = new Set();
                            } else if (!(gameState.unlockedContent[category] instanceof Set)) {
                                gameState.unlockedContent[category] = new Set(Array.from(gameState.unlockedContent[category]));
                            }
                        }

                        // åŸºæœ¬è¦ç´ ã®ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã‚’ä¿è¨¼
                        gameState.unlockedContent.adventurers.add('Novice Explorer');
                        gameState.unlockedContent.monsters.add('Shoggoth');
                        gameState.unlockedContent.upgrades.add('Ritual Knowledge');
                    }

                    // æ•°å€¤ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®æ¤œè¨¼ã¨ä¿®æ­£
                    const numericProps = {
                        source: { default: 0, min: 0 },
                        miasma: { default: 0, min: 0 },
                        cultos: { default: 0, min: 0 },
                        cultosRate: { default: 0, min: 0 },
                        followers: { default: 0, min: 0 },
                        followerEfficiency: { default: 0.1, min: 0.1 },
                        followerAccumulator: { default: 0, min: 0 },
                        cosmicAlignmentBonus: { default: 1, min: 1 },
                        astralProjectionRate: { default: 0, min: 0 },
                        quantumEntanglementBonus: { default: 0, min: 0 },
                        temporalManipulationBonus: { default: 1, min: 1 },
                        eldritchEvolutionRate: { default: 0, min: 0 },
                        upgradeCostMultiplier: { default: 1, min: 0.1 }
                    };

                    for (const [prop, config] of Object.entries(numericProps)) {
                        if (typeof gameState[prop] !== 'number' ||
                            isNaN(gameState[prop]) ||
                            !isFinite(gameState[prop]) ||
                            gameState[prop] < config.min) {
                            gameState[prop] = config.default;
                        }
                    }

                    // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼
                    if (!gameState.monsters) {
                        gameState.monsters = JSON.parse(JSON.stringify(initialGameState.monsters));
                    } else {
                        for (const monsterType in initialGameState.monsters) {
                            if (!gameState.monsters[monsterType]) {
                                gameState.monsters[monsterType] = JSON.parse(JSON.stringify(initialGameState.monsters[monsterType]));
                            } else {
                                const monster = gameState.monsters[monsterType];
                                // å¿…é ˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®æ¤œè¨¼
                                const requiredProps = {
                                    count: { default: 0, min: 0 },
                                    sourceEfficiency: { default: monsterEfficiencies[monsterType].sourceEfficiency, min: 0 },
                                    miasmaEfficiency: { default: monsterEfficiencies[monsterType].miasmaEfficiency, min: 0 },
                                    baseFollowerCost: { default: initialGameState.monsters[monsterType].baseFollowerCost, min: 1 },
                                    followerCostGrowth: { default: initialGameState.monsters[monsterType].followerCostGrowth, min: 1 }
                                };

                                for (const [prop, config] of Object.entries(requiredProps)) {
                                    if (typeof monster[prop] !== 'number' ||
                                        isNaN(monster[prop]) ||
                                        !isFinite(monster[prop]) ||
                                        monster[prop] < config.min) {
                                        monster[prop] = config.default;
                                    }
                                }

                                // ã‚·ãƒŠã‚¸ãƒ¼ã¨ã‚¹ãƒšã‚·ãƒ£ãƒ«ã‚¢ãƒ“ãƒªãƒ†ã‚£ã®æ¤œè¨¼
                                if (!monster.synergy || typeof monster.synergy !== 'object') {
                                    monster.synergy = initialGameState.monsters[monsterType].synergy;
                                }
                                if (!monster.specialAbility || typeof monster.specialAbility !== 'object') {
                                    monster.specialAbility = initialGameState.monsters[monsterType].specialAbility;
                                }
                            }
                        }
                    }

                    // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼
                    if (!Array.isArray(gameState.adventurers)) {
                        gameState.adventurers = JSON.parse(JSON.stringify(initialGameState.adventurers));
                    } else {
                        gameState.adventurers = gameState.adventurers.map((adventurer, index) => {
                            const defaultAdventurer = initialGameState.adventurers[index];
                            if (!adventurer || typeof adventurer !== 'object') {
                                return { ...defaultAdventurer };
                            }

                            return {
                                name: adventurer.name || defaultAdventurer.name,
                                miasmaRequired: validateNumber(adventurer.miasmaRequired, defaultAdventurer.miasmaRequired),
                                followerReward: validateNumber(adventurer.followerReward, defaultAdventurer.followerReward),
                                followerProduction: validateNumber(adventurer.followerProduction, defaultAdventurer.followerProduction),
                                madnessChance: validateNumber(adventurer.madnessChance, defaultAdventurer.madnessChance, 0, 1),
                                level: validateNumber(adventurer.level, 0),
                                isMad: !!adventurer.isMad,
                                cooldownEndTime: validateNumber(adventurer.cooldownEndTime, 0),
                                baseCooldown: validateNumber(adventurer.baseCooldown, defaultAdventurer.baseCooldown)
                            };
                        });
                    }

                    // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®æ¤œè¨¼
                    if (!Array.isArray(gameState.upgrades)) {
                        gameState.upgrades = [];
                    } else {
                        gameState.upgrades = gameState.upgrades.filter(upgrade =>
                            upgradeDefinitions.hasOwnProperty(upgrade)
                        );
                    }

                    // å¥‘ç´„ã‚·ã‚¹ãƒ†ãƒ ã®æ¤œè¨¼
                    if (!gameState.pacts || typeof gameState.pacts !== 'object') {
                        gameState.pacts = {
                            active: [],
                            commonMultiplier: 1,
                            tickSpeedMultiplier: 1,
                            showingPactModal: false
                        };
                    } else {
                        if (!Array.isArray(gameState.pacts.active)) gameState.pacts.active = [];
                        gameState.pacts.commonMultiplier = validateNumber(gameState.pacts.commonMultiplier, 1, 1);
                        gameState.pacts.tickSpeedMultiplier = validateNumber(gameState.pacts.tickSpeedMultiplier, 1, 1);
                        gameState.pacts.showingPactModal = !!gameState.pacts.showingPactModal;
                    }

                    // çµ±è¨ˆæƒ…å ±ã®æ¤œè¨¼
                    if (!gameState.statistics || typeof gameState.statistics !== 'object') {
                        gameState.statistics = {
                            startTime: Date.now(),
                            lastUpdate: Date.now(),
                            totalSourceGenerated: 0,
                            totalMiasmaGenerated: 0,
                            totalFollowersRecruited: 0,
                            peakFollowers: 0,
                            totalMonstersSummoned: 0,
                            totalMadnessAttempts: 0,
                            successfulMadness: 0
                        };
                    } else {
                        const now = Date.now();
                        gameState.statistics.startTime = validateNumber(gameState.statistics.startTime, now);
                        gameState.statistics.lastUpdate = validateNumber(gameState.statistics.lastUpdate, now);
                        gameState.statistics.totalSourceGenerated = validateNumber(gameState.statistics.totalSourceGenerated, 0);
                        gameState.statistics.totalMiasmaGenerated = validateNumber(gameState.statistics.totalMiasmaGenerated, 0);
                        gameState.statistics.totalFollowersRecruited = validateNumber(gameState.statistics.totalFollowersRecruited, 0);
                        gameState.statistics.peakFollowers = validateNumber(gameState.statistics.peakFollowers, 0);
                        gameState.statistics.totalMonstersSummoned = validateNumber(gameState.statistics.totalMonstersSummoned, 0);
                        gameState.statistics.totalMadnessAttempts = validateNumber(gameState.statistics.totalMadnessAttempts, 0);
                        gameState.statistics.successfulMadness = validateNumber(gameState.statistics.successfulMadness, 0);
                    }

                    return true;
                } catch (error) {
                    console.error("Error in validateGameState:", error);
                    return false;
                }
            }

            // è£œåŠ©é–¢æ•°: æ•°å€¤ã®æ¤œè¨¼
            function validateNumber(value, defaultValue, min = -Infinity, max = Infinity) {
                if (typeof value !== 'number' || isNaN(value) || !isFinite(value) || value < min || value > max) {
                    return defaultValue;
                }
                return value;
            }

            function showLoadSuccessNotification() {
                const notification = document.createElement('div');
                notification.className = 'load-success-notification';
                notification.textContent = 'Game loaded successfully!';
                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 3000);
            }

            function handleLoadError(error) {
                // ã‚¨ãƒ©ãƒ¼é€šçŸ¥ã‚’è¡¨ç¤º
                const notification = document.createElement('div');
                notification.className = 'load-error-notification';
                notification.innerHTML = `
        <h3>Error Loading Game</h3>
        <p>${error.message}</p>
        <p>The game has been reset to prevent further issues.</p>
        <button onclick="this.parentElement.remove()">Close</button>
    `;
                document.body.appendChild(notification);

                // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                resetGameState();
                rebuildUI();
            }

            // æ–°ã—ã„é–¢æ•°: ã‚¢ãƒ³ãƒ­ãƒƒã‚¯å¾Œã®UIæ›´æ–°å°‚ç”¨
            function updateDisplaysAfterUnlock() {
                updateMonsterGrid();
                updateUpgradeGrid();
                updateMadnessTable();
                updateResourceDisplay();
                updateCultosMiner();
                updateUpgradeSymbols();
            }

            function updateAllDisplays() {
                console.log('Updating all displays');
                updateResourceDisplay();
                updateUpgradeGrid();
                updateMonsterCards();
                updateAdventurerCards();
                updateGameDetails();
                updateMadnessTable();
                updateUnlockStatus(true);
                updateProgressBars();
                updateUpgradeSymbols();
                updateCultosMiner();
                updateRecruitFollowerButton();
            }

            // ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒªã‚«ãƒãƒªãƒ¼å‡¦ç†
            function attemptDataRecovery() {
                const backup = localStorage.getItem('cultistComplexSave_backup');
                if (backup && isValidJSON(backup)) {
                    localStorage.setItem('cultistComplexSave', backup);
                    return true;
                }
                return false;
            }

            function processOfflineProgress(offlineTime) {
                try {
                    const offlineSeconds = offlineTime / 1000;
                    const timeMultiplier = timeAcceleration * (gameState.pacts?.tickSpeedMultiplier || 1);

                    // PACTã®æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯
                    let shouldPauseProduction = false;
                    if (!gameState.pacts.active.includes('1') && gameState.source >= 1e6 - 1) {
                        shouldPauseProduction = true;
                    } else if (gameState.pacts.active.includes('1') && !gameState.pacts.active.includes('2') &&
                        gameState.source >= 1e28 - 1) {
                        shouldPauseProduction = true;
                    }

                    // åŸºæœ¬çš„ãªç”Ÿç”£é‡ã‚’è¨ˆç®—
                    const baseProduction = calculateResourceProduction();
                    const offlineProgress = {
                        source: shouldPauseProduction ? 0 : baseProduction.sourceProduction * offlineSeconds * timeMultiplier,
                        miasma: shouldPauseProduction ? 0 : baseProduction.miasmaProduction * offlineSeconds * timeMultiplier,
                        followers: 0,
                        cultos: 0
                    };

                    // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã®å‡¦ç†ã‚’ä¿®æ­£
                    if (gameState.adventurers) {
                        gameState.adventurers.forEach((adventurer, index) => {
                            const currentTime = Date.now();

                            // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã ã£ãŸå ´åˆã®å‡¦ç†
                            if (adventurer.cooldownEndTime > 0) {
                                if (currentTime >= adventurer.cooldownEndTime) {
                                    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãŒçµ‚äº†ã—ã¦ã„ã‚‹å ´åˆ
                                    adventurer.cooldownEndTime = 0;
                                    if (adventurer.isMad) {
                                        adventurer.isMad = false;
                                        logAction(`${adventurer.name} has returned to sanity!`);
                                    }
                                }
                            }

                            // ç‹‚æ°—çŠ¶æ…‹ã§ã®ç”Ÿç”£è¨ˆç®—
                            if (adventurer.isMad) {
                                const remainingCooldown = Math.max(0, adventurer.cooldownEndTime - currentTime);
                                const activeTime = offlineTime - remainingCooldown;

                                if (activeTime > 0) {
                                    const followerProduction = calculateFollowerProduction(adventurer);
                                    const productionPerSecond = followerProduction / (adventurer.baseCooldown / 1000);
                                    offlineProgress.followers += productionPerSecond * (activeTime / 1000);
                                }
                            }
                        });
                    }

                    // Cultosã®ç”Ÿç”£ã‚’å‡¦ç†
                    if (gameState.unlockedContent?.resources?.has('cultos')) {
                        const cultosRate = calculateCultosRate();
                        offlineProgress.cultos = cultosRate * offlineSeconds * timeMultiplier;
                    }

                    // ãƒªã‚½ãƒ¼ã‚¹ã‚’æ›´æ–°ï¼ˆPACTã®æ¡ä»¶ã‚’è€ƒæ…®ï¼‰
                    if (!shouldPauseProduction) {
                        gameState.source += offlineProgress.source;
                        gameState.miasma += offlineProgress.miasma;
                    }

                    // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã‚’æ›´æ–°ï¼ˆå¥‘ç´„ã®æœ€å°å€¤ã‚’è€ƒæ…®ï¼‰
                    let minimumFollowers = 0;
                    if (gameState.pacts?.active) {
                        gameState.pacts.active.forEach(pactId => {
                            const pact = PACTS[pactId];
                            if (pact) {
                                pact.effects.forEach(effect => {
                                    if (effect.type === "minimumFollowers") {
                                        minimumFollowers = Math.max(minimumFollowers, effect.value);
                                    }
                                });
                            }
                        });
                    }

                    gameState.followers = Math.max(
                        gameState.followers + offlineProgress.followers,
                        minimumFollowers
                    );

                    // Cultosã‚’æ›´æ–°
                    if (offlineProgress.cultos > 0) {
                        gameState.cultos = (gameState.cultos || 0) + offlineProgress.cultos;
                    }

                    // çµ±è¨ˆæƒ…å ±ã‚’æ›´æ–°
                    if (gameState.statistics) {
                        gameState.statistics.totalSourceGenerated += offlineProgress.source;
                        gameState.statistics.totalMiasmaGenerated += offlineProgress.miasma;
                        gameState.statistics.lastUpdate = Date.now();
                    }

                    return {
                        timeAway: formatTime(Math.floor(offlineSeconds)),
                        source: formatNumber(offlineProgress.source),
                        miasma: formatNumber(offlineProgress.miasma),
                        followers: formatNumber(offlineProgress.followers),
                        cultos: formatNumber(offlineProgress.cultos),
                        productionPaused: shouldPauseProduction
                    };

                } catch (error) {
                    console.error("Error processing offline progress:", error);
                    return {
                        timeAway: "Error",
                        source: "0",
                        miasma: "0",
                        followers: "0",
                        cultos: "0",
                        productionPaused: false
                    };
                }
            }

            function showOfflineProgressModal(progress) {
                try {
                    debug("Attempting to show offline progress modal");

                    // æ—¢å­˜ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒã‚ã‚Œã°å‰Šé™¤
                    const existingModal = document.querySelector('.offline-progress-modal');
                    if (existingModal) {
                        existingModal.remove();
                        debug("Removed existing modal");
                    }

                    // æ™‚é–“ã‚’é©åˆ‡ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
                    const timeAway = progress.timeAway;

                    const modalHtml = `
    <div class="offline-progress-modal modal-overlay" style="
        position: fixed !important;
        top: 50% !important;
        left: 50% !important;
        transform: translate(-50%, -50%) !important;
        width: 100vw !important;
        height: 100vh !important;
        background-color: rgba(0, 0, 0, 0.7) !important;
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        z-index: 999999999 !important;
        visibility: visible !important;
        opacity: 1 !important;
        pointer-events: auto !important;">
        <div class="modal-content" style="
            position: relative !important;
            background-color: #1a1a1a !important;
            border: 2px solid #4CAF50 !important;
            border-radius: 8px !important;
            padding: 20px !important;
            max-width: 500px !important;
            width: 90% !important;
            color: #e0e0e0 !important;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.3) !important;
            margin: 0 auto !important;
            transform: none !important;
            top: auto !important;
            left: auto !important;
            right: auto !important;
            bottom: auto !important;">
            <h2 style="color: #4CAF50 !important; margin-bottom: 15px !important; text-align: center !important;">Offline Progress</h2>
            <p style="margin-bottom: 10px !important; text-align: center !important;">Welcome back! You were away for ${progress.timeAway}</p>
            ${progress.productionPaused ?
                            `<p style="color: #ff9800; margin: 10px 0 !important; text-align: center !important;">
                    Resource production is paused until you accept the pending PACT
                </p>` : ''}
            <div class="progress-details" style="margin-bottom: 15px !important;">
                <p style="margin: 5px 0 !important;">Source gained: ${progress.source}</p>
                <p style="margin: 5px 0 !important;">Miasma gained: ${progress.miasma}</p>
                <p style="margin: 5px 0 !important;">Followers gained: ${progress.followers}</p>
                ${progress.cultos > 0 ? `<p style="margin: 5px 0 !important;">Cultos earned: ${progress.cultos}</p>` : ''}
            </div>
            <div class="production-details" style="margin-bottom: 15px !important;">
                <p style="margin: 5px 0 !important;">Current Production Rates:</p>
                <p style="margin: 5px 0 !important;">Source: ${formatNumber(calculateResourceProduction().sourceProduction)}/sec</p>
                <p style="margin: 5px 0 !important;">Miasma: ${formatNumber(calculateResourceProduction().miasmaProduction)}/sec</p>
                <p style="margin: 5px 0 !important;">Followers: ${formatNumber(calculateResourceProduction().followerProduction)}/sec</p>
            </div>
            <div style="text-align: center !important;">
                <button onclick="this.closest('.offline-progress-modal').remove()" style="
                    background-color: #4CAF50 !important;
                    color: white !important;
                    border: none !important;
                    padding: 8px 16px !important;
                    border-radius: 4px !important;
                    cursor: pointer !important;
                    margin-top: 10px !important;
                    font-size: 16px !important;">Close</button>
            </div>
        </div>
    </div>`;

                    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’bodyã«è¿½åŠ 
                    const gameContainer = document.querySelector('.container');
                    if (gameContainer) {
                        gameContainer.insertAdjacentHTML('beforeend', modalHtml);
                        debug("Modal added to game container");
                    } else {
                        document.body.insertAdjacentHTML('beforeend', modalHtml);
                        debug("Modal added to body (fallback)");
                    }
                    debug("Modal HTML inserted and centered");

                    // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒæ­£ã—ãè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
                    const addedModal = document.querySelector('.offline-progress-modal');
                    if (addedModal) {
                        debug("Modal successfully added to DOM");
                    } else {
                        debug("Warning: Modal not found in DOM after insertion");
                    }

                } catch (error) {
                    console.error("Error showing offline progress modal:", error);
                    debug(`Error showing modal: ${error.message}`);

                    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã§ã‚‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥
                    logAction("Failed to show offline progress. Error: " + error.message);

                    // æœ€å°é™ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
                    try {
                        const fallbackModal = document.createElement('div');
                        fallbackModal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                padding: 20px;
                border: 2px solid red;
                z-index: 999999999;
            `;
                        fallbackModal.innerHTML = `
                <h3>Offline Progress Error</h3>
                <p>There was an error showing your offline progress.</p>
                <button onclick="this.parentElement.remove()">Close</button>
            `;
                        document.body.appendChild(fallbackModal);
                    } catch (fallbackError) {
                        console.error("Failed to show fallback error modal:", fallbackError);
                    }
                }
            }

            // handleOfflineProgressé–¢æ•°ã‚‚ä¿®æ­£
            function handleOfflineProgress() {
                try {
                    const lastSaveTime = gameState.statistics?.lastUpdate || Date.now();
                    const currentTime = Date.now();
                    const offlineTime = currentTime - lastSaveTime;

                    debug(`Checking offline progress: ${offlineTime}ms elapsed`);

                    // æœ€å°ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚é–“ã‚’1åˆ†ã«è¨­å®š
                    const minimumOfflineTime = 60 * 1000; // 1åˆ†ã‚’ãƒŸãƒªç§’ã§è¡¨ç¾

                    if (offlineTime >= minimumOfflineTime) {
                        debug("Processing offline progress...");
                        const progress = processOfflineProgress(offlineTime);

                        // ç¢ºå®Ÿã«DOMãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã‹ã‚‰å®Ÿè¡Œ
                        if (document.readyState === 'complete') {
                            debug("DOM is ready, showing modal immediately");
                            showOfflineProgressModal(progress);
                        } else {
                            debug("DOM not ready, waiting for load event");
                            window.addEventListener('load', () => {
                                debug("DOM now loaded, showing modal");
                                showOfflineProgressModal(progress);
                            });
                        }

                        // æœ€çµ‚æ›´æ–°æ™‚åˆ»ã‚’æ›´æ–°
                        if (gameState.statistics) {
                            gameState.statistics.lastUpdate = currentTime;
                        }

                        saveGame();
                    } else {
                        debug("Not enough time elapsed for offline progress");
                    }
                } catch (error) {
                    console.error("Error in handleOfflineProgress:", error);
                    debug(`Error handling offline progress: ${error.message}`);
                }
            }

            function validateMonsters(monsters) {
                const validatedMonsters = {};
                for (let monsterName in monsters) {
                    if (monsters.hasOwnProperty(monsterName)) {
                        validatedMonsters[monsterName] = {
                            count: validateNumber(monsters[monsterName].count, 0),
                            sourceEfficiency: validateNumber(monsters[monsterName].sourceEfficiency, gameState.monsters[monsterName].sourceEfficiency),
                            miasmaEfficiency: validateNumber(monsters[monsterName].miasmaEfficiency, gameState.monsters[monsterName].miasmaEfficiency),
                            baseFollowerCost: validateNumber(monsters[monsterName].baseFollowerCost, gameState.monsters[monsterName].baseFollowerCost),
                            followerCostGrowth: validateNumber(monsters[monsterName].followerCostGrowth, gameState.monsters[monsterName].followerCostGrowth),
                            synergy: monsters[monsterName].synergy || gameState.monsters[monsterName].synergy,
                            specialAbility: validateSpecialAbility(monsters[monsterName].specialAbility, gameState.monsters[monsterName].specialAbility)
                        };
                    }
                }
                return validatedMonsters;
            }

            function validateSpecialAbility(loadedAbility, defaultAbility) {
                if (!loadedAbility) return defaultAbility;

                return {
                    trigger: validateNumber(loadedAbility.trigger, defaultAbility.trigger),
                    effect: {
                        type: loadedAbility.effect.type || defaultAbility.effect.type,
                        value: validateNumber(loadedAbility.effect.value, defaultAbility.effect.value),
                        maxDiscount: loadedAbility.effect.maxDiscount !== undefined ?
                            validateNumber(loadedAbility.effect.maxDiscount, defaultAbility.effect.maxDiscount) :
                            defaultAbility.effect.maxDiscount
                    }
                };
            }

            function resetGameWithPersistentEffects() {
                // æ°¸ç¶šçš„ãªåŠ¹æœã‚’ä¿å­˜
                const persistentState = {
                    pacts: {
                        active: [...gameState.pacts.active],
                        commonMultiplier: gameState.pacts.commonMultiplier,
                        tickSpeedMultiplier: gameState.pacts.tickSpeedMultiplier
                    },
                    unlockedContent: {
                        adventurers: new Set([...gameState.unlockedContent.adventurers]),
                        monsters: new Set([...gameState.unlockedContent.monsters]),
                        upgrades: new Set([...gameState.unlockedContent.upgrades])
                    },
                    upgrades: [], // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã¯å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆ
                    statistics: { ...gameState.statistics },
                    minimumFollowers: 0,
                    followerEfficiency: 0.1 // åŸºæœ¬å€¤
                };

                // å¥‘ç´„ã«ã‚ˆã‚‹æœ€å°ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã¨åŠ¹ç‡ã®è¨ˆç®—
                gameState.pacts.active.forEach(pactId => {
                    const pact = PACTS[pactId];
                    if (pact) {
                        pact.effects.forEach(effect => {
                            switch (effect.type) {
                                case "minimumFollowers":
                                    persistentState.minimumFollowers = Math.max(persistentState.minimumFollowers, effect.value);
                                    break;
                                case "followerEfficiency":
                                    persistentState.followerEfficiency *= (1 + effect.value);
                                    break;
                            }
                        });
                    }
                });

                // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’åˆæœŸçŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆ
                gameState = JSON.parse(JSON.stringify(initialGameState));

                // æ°¸ç¶šçš„ãªåŠ¹æœã‚’å¾©å…ƒ
                gameState.pacts = persistentState.pacts;
                gameState.unlockedContent = persistentState.unlockedContent;
                gameState.upgrades = persistentState.upgrades;
                gameState.statistics = persistentState.statistics;

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼é–¢é€£ã®å€¤ã‚’è¨­å®š
                gameState.followers = persistentState.minimumFollowers;
                gameState.followerEfficiency = persistentState.followerEfficiency;

                // localStorage ã«æ°¸ç¶šçš„ãªçŠ¶æ…‹ã‚’ä¿å­˜
                const persistentData = {
                    pacts: gameState.pacts,
                    followers: gameState.followers,
                    followerEfficiency: gameState.followerEfficiency,
                    unlockedContent: {
                        adventurers: Array.from(gameState.unlockedContent.adventurers),
                        monsters: Array.from(gameState.unlockedContent.monsters),
                        upgrades: Array.from(gameState.unlockedContent.upgrades)
                    }
                };
                localStorage.setItem('cultistComplexPersistent', JSON.stringify(persistentData));

                // UI ã®æ›´æ–°
                if (gameState.pacts.active.includes('1')) {
                    hideManualRecruitButtons();
                }

                // å®Œå…¨ãª UI æ›´æ–°
                updateAllDisplays();
                updateUnlockSystem();
                updateCultosMiner();
                updateUpgradeSymbols();

                logAction("Game has been reset while maintaining permanent effects");
            }

            function resetGameAndClearSave() {
                if (confirm("Are you sure you want to reset the game? This will erase all progress and cannot be undone.")) {
                    const currentTickSpeed = timeAcceleration;
                    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’åˆæœŸçŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆ
                    gameState = JSON.parse(JSON.stringify(initialGameState));

                    // tickSpeedã‚’å¾©å…ƒ
                    timeAcceleration = currentTickSpeed;

                    // Setã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†åˆæœŸåŒ–
                    gameState.unlockedContent = {
                        adventurers: new Set(['Novice Explorer']),
                        monsters: new Set(['Shoggoth']),
                        upgrades: new Set(['Ritual Knowledge']),
                        resources: new Set()
                    };

                    // å¥‘ç´„ã‚·ã‚¹ãƒ†ãƒ ã®ãƒªã‚»ãƒƒãƒˆ
                    gameState.pacts = {
                        active: [],
                        commonMultiplier: 1,
                        tickSpeedMultiplier: 1,
                        showingPactModal: false
                    };

                    // çµ±è¨ˆæƒ…å ±ã®ãƒªã‚»ãƒƒãƒˆ
                    gameState.statistics = {
                        startTime: Date.now(),
                        lastUpdate: Date.now(),
                        totalSourceGenerated: 0,
                        totalMiasmaGenerated: 0,
                        totalFollowersRecruited: 0,
                        peakFollowers: 0,
                        totalMonstersSummoned: 0,
                        totalMadnessAttempts: 0,
                        successfulMadness: 0
                    };

                    // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®åˆæœŸåŒ–
                    for (const monsterName in gameState.monsters) {
                        gameState.monsters[monsterName] = {
                            count: 0,
                            baseSourceCost: gameState.monsters[monsterName].baseSourceCost
                        };
                    }

                    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢
                    localStorage.removeItem('gameState');

                    // DOMã‚’ãƒªã‚»ãƒƒãƒˆ
                    resetDOM();

                    // UIã‚’å®Œå…¨ã«å†æ§‹ç¯‰
                    rebuildUI();

                    // æ‰‹å‹•ãƒªã‚¯ãƒ«ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºã—ã€å°å°çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                    const recruitButton = document.getElementById('recruitFollowerBtn');
                    if (recruitButton) {
                        recruitButton.style.display = 'block';
                        recruitButton.classList.remove('sealed-by-pact');
                        recruitButton.disabled = false;
                        recruitButton.title = '';
                    }

                    // å…¨ã¦ã®è¡¨ç¤ºã‚’æ›´æ–°
                    updateDisplay();
                    updateAllDisplays();

                    // ã‚¨ãƒ³ãƒ–ãƒ¬ãƒ ã‚’æ›´æ–°
                    updateCultosMiner();

                    // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’æ¤œè¨¼
                    validateGameState();

                    logAction("Game has been reset to initial state");
                }
            }


            // æ–°ã—ã„ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–ã‚„ãƒªã‚»ãƒƒãƒˆæ™‚ã«ã¯ã€initialGameStateã®ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼ã‚’ä½¿ç”¨
            function resetGameState() {
                debug("Resetting game state to initial values");
                gameState = JSON.parse(JSON.stringify(initialGameState));

                // Setå‹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å†åˆæœŸåŒ–ï¼ˆã“ã‚Œã‚‰ã¯JSONã§ã¯æ­£ã—ãä¿å­˜/å¾©å…ƒã§ããªã„ãŸã‚ï¼‰
                gameState.unlockedContent = {
                    monsters: new Set(['Shoggoth']),
                    adventurers: new Set(['Novice Explorer']),
                    upgrades: new Set(['Ritual Knowledge']),
                    resources: new Set()
                };

                // çµ±è¨ˆæƒ…å ±ã®åˆæœŸåŒ–
                gameState.statistics = {
                    startTime: Date.now(),
                    lastUpdate: Date.now(),
                    totalSourceGenerated: 0,
                    totalMiasmaGenerated: 0,
                    totalFollowersRecruited: 0,
                    peakFollowers: 0,
                    totalMonstersSummoned: 0,
                    totalMadnessAttempts: 0,
                    successfulMadness: 0
                };

                isSummoning = false;
                debug("Game state reset complete");
                return gameState;
            }

            function resetUIElements() {
                // ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                const collectSourceBtn = document.getElementById('collectSource');
                const recruitFollowerBtn = document.getElementById('recruitFollowerBtn');
                if (collectSourceBtn) {
                    collectSourceBtn.style.display = 'block';
                    collectSourceBtn.classList.remove('sealed-by-pact');
                }
                if (recruitFollowerBtn) {
                    recruitFollowerBtn.style.display = 'block';
                    recruitFollowerBtn.classList.remove('sealed-by-pact');
                }

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®ã‚¢ã‚¹ã‚­ãƒ¼ã‚¢ãƒ¼ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
                const followerArt = document.getElementById('followerAsciiArt');
                if (followerArt) {
                    followerArt.innerHTML = asciiArt['Follower'];
                    followerArt.title = '';
                    followerArt.classList.remove('transforming', 'transformed');
                }

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®å®Œå…¨ãªãƒªã‚»ãƒƒãƒˆ
                const followerSection = document.getElementById('followerSection');
                if (followerSection) {
                    updateFollowerSection();  // å®Œå…¨ãªå†æ§‹ç¯‰ã‚’è¡Œã†
                }

                // ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºçŠ¶æ…‹ã‚’ç¢ºå®Ÿã«ãƒªã‚»ãƒƒãƒˆ
                showManualRecruitButtons();  // æ˜ç¤ºçš„ã«ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º

                // ãã®ä»–ã®UIæ›´æ–°
                updateResourceDisplay();
                updateMonsterCards();
                updateUpgradeCards();
                updateAdventurerCards();
                updateGameDetails();
                updateMadnessTable();
                updateUnlockStatus();
                updateProgressBars();
                updateUpgradeSymbols();
                updateCultosMiner();
            }

            function rebuildUI() {
                // ãƒªã‚½ãƒ¼ã‚¹è¡¨ç¤ºã®æ›´æ–°
                updateResourceDisplay();

                // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®å†æ§‹ç¯‰
                updateFollowerSection();

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚°ãƒªãƒƒãƒ‰ã®å®Œå…¨ãªãƒªã‚»ãƒƒãƒˆã¨å†æ§‹ç¯‰
                const monsterGrid = document.getElementById('monsterGrid');
                if (monsterGrid) {
                    monsterGrid.innerHTML = '';
                    updateMonsterGrid();
                }

                // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚°ãƒªãƒƒãƒ‰ã®å®Œå…¨ãªãƒªã‚»ãƒƒãƒˆã¨å†æ§‹ç¯‰
                const upgradeGrid = document.getElementById('upgradeGrid');
                if (upgradeGrid) {
                    upgradeGrid.innerHTML = '';
                    updateUpgradeGrid();
                }

                // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«ã®å®Œå…¨ãªãƒªã‚»ãƒƒãƒˆã¨å†æ§‹ç¯‰
                const adventurersContainer = document.getElementById('adventurers');
                if (adventurersContainer) {
                    adventurersContainer.innerHTML = '';
                    updateMadnessTable();
                }

                // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚·ãƒ³ãƒœãƒ«ã®å®Œå…¨ãªãƒªã‚»ãƒƒãƒˆ
                const symbolsContainer = document.getElementById('upgradeSymbols');
                if (symbolsContainer) {
                    symbolsContainer.innerHTML = '';
                    updateUpgradeSymbols();
                }

                // ã‚¨ãƒ³ãƒ–ãƒ¬ãƒ ã®æ›´æ–°
                updateCultosMiner();

                // ã‚²ãƒ¼ãƒ è©³ç´°ã®æ›´æ–°
                updateGameDetails();

                // æ‰‹å‹•ãƒªã‚¯ãƒ«ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®è¡¨ç¤ºçŠ¶æ…‹ã‚’æ›´æ–°
                if (gameState.pacts.active.includes('1')) {
                    hideManualRecruitButtons();
                } else {
                    showManualRecruitButtons();
                }

                // å…¨ã¦ã®è¡¨ç¤ºã‚’æœ€çµ‚æ›´æ–°
                updateAllDisplays();
            }

            function resetDOM() {
                debug("Starting DOM reset");

                try {
                    // ãƒªã‚½ãƒ¼ã‚¹è¡¨ç¤ºã®ãƒªã‚»ãƒƒãƒˆ
                    const resourceElements = {
                        'largeSourceCount': '0',
                        'largeSourcePerSecond': '0',
                        'largeMiasmaCount': '0',
                        'largeMiasmaPerSecond': '0'
                    };

                    for (const [id, value] of Object.entries(resourceElements)) {
                        const element = document.getElementById(id);
                        if (element) {
                            element.textContent = value;
                        } else {
                            debug(`Warning: Element ${id} not found`);
                        }
                    }

                    // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®å†æ§‹ç¯‰
                    const followerSection = document.getElementById('followerSection');
                    if (followerSection) {
                        debug("Updating follower section");
                        updateFollowerSection();
                    } else {
                        debug("Warning: Follower section not found");
                    }

                    // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚°ãƒªãƒƒãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
                    const monsterGrid = document.getElementById('monsterGrid');
                    if (monsterGrid) {
                        debug("Resetting monster grid");
                        monsterGrid.innerHTML = '';
                        updateMonsterGrid();
                    } else {
                        debug("Warning: Monster grid not found");
                    }

                    // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚°ãƒªãƒƒãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
                    const upgradeGrid = document.getElementById('upgradeGrid');
                    if (upgradeGrid) {
                        debug("Resetting upgrade grid");
                        upgradeGrid.innerHTML = '';
                        updateUpgradeGrid();
                    } else {
                        debug("Warning: Upgrade grid not found");
                    }

                    // ç‹‚æ°—ãƒ†ãƒ¼ãƒ–ãƒ«ã®ãƒªã‚»ãƒƒãƒˆ
                    const madnessTable = document.getElementById('madnessTable');
                    if (madnessTable) {
                        debug("Updating madness table");
                        updateMadnessTable();
                    } else {
                        debug("Warning: Madness table not found");
                    }

                    // ãƒ­ã‚°ã®ã‚¯ãƒªã‚¢
                    const log = document.getElementById('log');
                    if (log) {
                        debug("Clearing log");
                        log.innerHTML = '';
                    } else {
                        debug("Warning: Log element not found");
                    }

                    // ã‚¨ãƒ³ãƒ–ãƒ¬ãƒ ã®ãƒªã‚»ãƒƒãƒˆ
                    debug("Updating cultosminer");
                    updateCultosMiner();

                    debug("DOM reset completed successfully");
                } catch (error) {
                    console.error("Error during DOM reset:", error);
                    debug(`Error during DOM reset: ${error.message}`);
                }
            }

            function setupEventListeners() {
                debug("Setting up event listeners");

                document.addEventListener('click', (e) => {
                    const target = e.target;
                    if (target.matches('#recruitFollowerBtn')) {
                        recruitFollower();
                    } else if (target.matches('.summon-monster-btn')) {
                        summonMonster(target.dataset.monster);
                    } else if (target.matches('.madness-btn:not([disabled])')) {
                        attemptMadness(parseInt(target.dataset.index));
                    } else if (target.matches('.buy-upgrade-btn')) {
                        const upgradeId = target.dataset.upgrade;
                        if (upgradeId) {
                            buyUpgrade(upgradeId);
                        }
                    }
                });

                const toggleMadnessTableBtn = document.getElementById('toggleMadnessTable');
                if (toggleMadnessTableBtn) {
                    toggleMadnessTableBtn.addEventListener('click', toggleMadnessTable);
                    debug("Jump to Madness Table button listener added");  // ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ›´æ–°
                } else {
                    debug("Jump to Madness Table button not found");  // ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ›´æ–°
                }

                const backToTopBtn = document.getElementById("backToTopBtn");
                if (backToTopBtn) {
                    backToTopBtn.addEventListener("click", backToTop);
                    debug("Back to Top button listener added");
                } else {
                    debug("Back to Top button not found");
                }

                // ã‚»ãƒ¼ãƒ–ãƒ»ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
                const saveLoadButtons = document.getElementById('saveLoadButtons');
                if (saveLoadButtons) {
                    const saveButton = saveLoadButtons.querySelector('button:nth-child(1)');
                    const loadButton = saveLoadButtons.querySelector('button:nth-child(2)');

                    if (saveButton) {
                        saveButton.addEventListener('click', saveGame);
                        debug("Save button listener added");
                    } else {
                        debug("Save button not found");
                    }

                    if (loadButton) {
                        loadButton.addEventListener('click', loadGame);
                        debug("Load button listener added");
                    } else {
                        debug("Load button not found");
                    }
                } else {
                    debug("Save/Load buttons container not found");
                }

                document.getElementById('spinButton')?.addEventListener('click', () => {
                    if (gameState.cultos >= drumState.currentBet) {
                        spinReels();
                    }
                });

                document.getElementById('autoSpinToggle')?.addEventListener('click', () => {
                    drumState.autoSpinEnabled = !drumState.autoSpinEnabled;
                    const button = document.getElementById('autoSpinToggle');
                    if (button) {
                        button.textContent = `AUTO: ${drumState.autoSpinEnabled ? 'ON' : 'OFF'}`;
                    }
                });

                document.getElementById('betButton')?.addEventListener('click', () => {
                    const betValues = [50, 100, 250, 500, 1000];
                    const currentIndex = betValues.indexOf(drumState.currentBet);
                    drumState.currentBet = betValues[(currentIndex + 1) % betValues.length];
                    const button = document.getElementById('betButton');
                    if (button) {
                        button.textContent = `BET: ${drumState.currentBet} Â©ï¸`;
                    }
                });
            }

            document.getElementById('pauseGameBtn').addEventListener('click', function () {
                gamePaused = !gamePaused;
                this.textContent = gamePaused ? 'Resume Game' : 'Pause Game';
                this.style.borderColor = gamePaused ? '#ff0000' : '#4CAF50';
                this.style.color = gamePaused ? '#ff0000' : '#e0e0e0';

                // Use logAction instead of addToLog
                logAction(gamePaused ? 'Game paused' : 'Game resumed');
            });

            let lastUpdateTime = Date.now();
            let accumulatedTime = 0;
            const TICK_RATE = 50; // 20 ticks per second

            let lastFrameTime = Date.now();

            function gameLoop() {
                try {
                    const currentTime = Date.now();

                    if (!gamePaused) {
                        const deltaTime = (currentTime - lastFrameTime) / 1000;
                        lastFrameTime = currentTime;

                        const timeMultiplier = timeAcceleration * (gameState.pacts?.tickSpeedMultiplier || 1);

                        const { sourceProduction, miasmaProduction, followerProduction } = calculateResourceProduction();

                        // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®è“„ç©å‡¦ç†ã‚’è¿½åŠ 
                        if (followerProduction > 0) {
                            gameState.followerAccumulator = (gameState.followerAccumulator || 0) +
                                followerProduction * deltaTime * timeMultiplier;

                            // è“„ç©ãŒ1ä»¥ä¸Šã«ãªã£ãŸã‚‰æ•´æ•°éƒ¨åˆ†ã‚’ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã«è¿½åŠ 
                            if (gameState.followerAccumulator >= 1) {
                                const newFollowers = Math.floor(gameState.followerAccumulator);
                                gameState.followers += newFollowers;
                                gameState.followerAccumulator -= newFollowers;
                            }
                        }
                        // ãƒªã‚½ãƒ¼ã‚¹ã®æ›´æ–°
                        gameState.source += sourceProduction * deltaTime * timeMultiplier;
                        gameState.miasma += miasmaProduction * deltaTime * timeMultiplier;

                        // Cultosç”Ÿç”£ã®å‡¦ç†
                        if (checkUnlockCondition('resources', 'cultos')) {
                            const cultosRate = calculateCultosRate(deltaTime);
                            if (cultosRate > 0) {
                                gameState.cultos += cultosRate * deltaTime * timeMultiplier;
                                gameState.cultos = Number(gameState.cultos.toFixed(12));
                                gameState.cultosRate = cultosRate * timeMultiplier;
                            }
                        }

                        // å¥‘ç´„ã«ã‚ˆã‚‹æœ€å°ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã®ä¿è¨¼
                        if (gameState.pacts?.active) {
                            let minimumFollowers = 0;
                            gameState.pacts.active.forEach(pactId => {
                                const pact = PACTS[pactId];
                                if (pact) {
                                    pact.effects.forEach(effect => {
                                        if (effect.type === "minimumFollowers") {
                                            minimumFollowers = Math.max(minimumFollowers, effect.value);
                                        }
                                    });
                                }
                            });
                            gameState.followers = Math.max(gameState.followers, minimumFollowers);
                        }

                        // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç‰¹æ®Šèƒ½åŠ›ã®é©ç”¨
                        applySpecialAbilities();

                        // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã®çŠ¶æ…‹æ›´æ–°
                        updateAdventurerStates();

                        // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®æ›´æ–°
                        checkNewUnlocks();
                        checkPacts();

                        // çµ±è¨ˆæƒ…å ±ã®æ›´æ–°
                        if (gameState.statistics) {
                            // ç·ç”Ÿç”£é‡ã®è¨˜éŒ²
                            gameState.statistics.totalSourceGenerated += sourceProduction * deltaTime * timeMultiplier;
                            gameState.statistics.totalMiasmaGenerated += miasmaProduction * deltaTime * timeMultiplier;

                            // ãƒ”ãƒ¼ã‚¯ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã®æ›´æ–°
                            gameState.statistics.peakFollowers = Math.max(
                                gameState.statistics.peakFollowers || 0,
                                gameState.followers || 0
                            );

                            // æœ€çµ‚æ›´æ–°æ™‚åˆ»ã®è¨˜éŒ²
                            gameState.statistics.lastUpdate = currentTime;
                        }

                        // è‡ªå‹•ã‚»ãƒ¼ãƒ–ã®å‡¦ç†
                        const autoSaveInterval = 5 * 60 * 1000; // 5åˆ†
                        if (currentTime - (gameState.lastAutoSave || 0) >= autoSaveInterval) {
                            saveGame();
                            gameState.lastAutoSave = currentTime;
                        }

                        // æ•°å€¤ã®æ¤œè¨¼ã¨ä¿®æ­£
                        sanitizeGameState();
                    }

                    // UIæ›´æ–°ã®é–“éš”ç®¡ç†ï¼ˆä¸€æ™‚åœæ­¢ä¸­ã§ã‚‚æ›´æ–°ï¼‰
                    const now = Date.now();
                    Object.keys(UPDATE_INTERVALS).forEach(key => {
                        if (now - lastUpdateTimes[key] >= UPDATE_INTERVALS[key]) {
                            switch (key) {
                                case 'monsterGrid':
                                    updateMonsterGrid();
                                    break;
                                case 'followerSection':
                                    updateFollowerSection();
                                    break;
                                case 'madnessTable':
                                    updateMadnessTable();
                                    break;
                                case 'upgradeGrid':
                                    updateUpgradeGrid();
                                    break;
                                case 'gameDetails':
                                    updateGameDetails();
                                    break;
                            }
                            lastUpdateTimes[key] = now;
                        }
                    });

                    // åŸºæœ¬çš„ãªUIæ›´æ–°ï¼ˆæ¯ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
                    updateResourceDisplay();
                    updateCultosMiner();
                    updateTimeAccelerationDisplay();
                    updateAllDisplays();

                    // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®å‡¦ç†ï¼ˆä¸€æ™‚åœæ­¢ä¸­ã¯å®Ÿè¡Œã—ãªã„ï¼‰
                    if (!gamePaused) {
                        const dialogChance = 0.02; // 2%ã®ç¢ºç‡
                        if (Math.random() < dialogChance) {
                            randomDialogue();
                            showFollowerDialogue();
                        }
                    }

                    // é€šçŸ¥ã®æ•´ç†
                    cleanupNotifications();

                } catch (error) {
                    console.error("Game loop error:", error);
                    handleGameLoopError(error);
                }

                // æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
                requestAnimationFrame(gameLoop);
            }

            // è£œåŠ©é–¢æ•°ï¼šé€šçŸ¥ã®æ•´ç†
            function cleanupNotifications() {
                const container = document.getElementById('notifications-container');
                if (container && container.children.length > 5) {
                    // å¤ã„é€šçŸ¥ã‚’å‰Šé™¤
                    while (container.children.length > 5) {
                        container.removeChild(container.firstChild);
                    }
                }
            }

            // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚¨ãƒ©ãƒ¼ã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
            function handleGameLoopError(error) {
                if (!gamePaused) {
                    // ã‚²ãƒ¼ãƒ ã‚’ä¸€æ™‚åœæ­¢
                    gamePaused = true;

                    // ã‚¨ãƒ©ãƒ¼é€šçŸ¥ã‚’è¡¨ç¤º
                    const errorMessage = `Game paused due to error: ${error.message}. Check console for details.`;
                    logAction(errorMessage);

                    const notification = document.createElement('div');
                    notification.className = 'error-notification';
                    notification.innerHTML = `
            <h3>Game Error</h3>
            <p>${errorMessage}</p>
            <button onclick="resumeGame()">Try to Resume</button>
            <button onclick="this.parentElement.remove()">Close</button>
        `;
                    document.body.appendChild(notification);

                    // ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’å‡ºåŠ›
                    debug(`Game loop error: ${error.message}`);
                    console.error("Game loop error details:", error);

                    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ä½œæˆã‚’è©¦ã¿ã‚‹
                    try {
                        createBackup();
                    } catch (backupError) {
                        console.error("Failed to create backup:", backupError);
                    }
                }
            }

            // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã®é–‹å§‹
            function startGameLoop() {
                lastFrameTime = Date.now();
                requestAnimationFrame(gameLoop);
                debug("Game loop started");
            }

            // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°é–¢æ•°ã‚’è¿½åŠ 
            function handleGameError(error) {
                console.error("Game error:", error);
                logAction(`An error occurred: ${error.message}`);
            }

            function initializeUnlockedContent() {
                return {
                    adventurers: new Set(['Novice Explorer']),
                    monsters: new Set(['Shoggoth']),
                    upgrades: new Set(['Ritual Knowledge'])
                };
            }

            function initializeGame() {
                debug("Initializing game");

                try {
                    // æœ€çµ‚æ›´æ–°æ™‚åˆ»ã®åˆæœŸåŒ–
                    lastUpdateTimes = {
                        monsterGrid: 0,
                        followerSection: 0,
                        madnessTable: 0,
                        upgradeGrid: 0,
                        gameDetails: 0
                    };

                    // ãƒãƒ¼ã‚¸ãƒ§ãƒ³è¡¨ç¤ºã®æ›´æ–°
                    document.getElementById('version-display').textContent = `v${gameVersion}`;

                    // tickSpeedè¡¨ç¤ºã®åˆæœŸåŒ–
                    const tickSpeedDisplay = document.getElementById('tickSpeedDisplay');
                    if (!tickSpeedDisplay) {
                        const container = document.createElement('div');
                        container.innerHTML = `
                <span>Tick Speed: <span id="tickSpeedDisplay" style="color: #4CAF50;">x1.00</span></span>
            `;
                        document.querySelector('#game-header div').appendChild(container);
                    }

                    // PACTã®çŠ¶æ…‹ã‚’ç¢ºèª
                    if (gameState.pacts?.active?.includes('1')) {
                        hideManualRecruitButtons();
                    }


                    // æ—¢å­˜ã®åˆæœŸåŒ–å‡¦ç†
                    initializeGameState();
                    initializePactSystem();
                    setupTopButtons();
                    setupEventListeners();
                    setCultosMiner();

                    // ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã®ãƒ­ãƒ¼ãƒ‰
                    const savedGame = localStorage.getItem('cultistComplexSave');
                    if (savedGame) {
                        loadGame();
                    } else {
                        resetGameState();
                        rebuildUI();
                    }

                    // UIæ›´æ–°
                    updateCultosMiner();
                    updateDisplay();
                    updateTimeAccelerationDisplay();

                    debug("Game initialization complete");
                } catch (error) {
                    console.error("Error during game initialization:", error);
                    handleInitializationError(error);
                }
            }

            // é–¢é€£ã™ã‚‹ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®åˆæœŸåŒ–é–¢æ•°ã‚‚æ›´æ–°
            function initializeGameState() {
                debug("Initializing game state");

                // gameStateãŒæœªå®šç¾©ã®å ´åˆã¯å®Œå…¨ã«æ–°ã—ã„çŠ¶æ…‹ã‚’ä½œæˆ
                if (!gameState) {
                    gameState = JSON.parse(JSON.stringify(initialGameState));
                }

                // åŸºæœ¬ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ç¢ºèªã¨åˆæœŸåŒ–
                const baseProps = {
                    source: 0,
                    miasma: 0,
                    followers: 0,
                    followerEfficiency: 0.1,
                    followerAccumulator: 0,
                    cosmicAlignmentBonus: 1,
                    astralProjectionRate: 0,
                    quantumEntanglementBonus: 0,
                    temporalManipulationBonus: 1,
                    eldritchEvolutionRate: 0,
                    upgradeCostMultiplier: 1
                };

                // åŸºæœ¬ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®åˆæœŸåŒ–
                for (const [prop, defaultValue] of Object.entries(baseProps)) {
                    if (typeof gameState[prop] !== 'number' || isNaN(gameState[prop])) {
                        debug(`Initializing ${prop} to default value: ${defaultValue}`);
                        gameState[prop] = defaultValue;
                    }
                }

                // ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã®è¨­å®š
                gameState.version = gameVersion;

                // unlockedContentã®åˆæœŸåŒ–ã‚’ç¢ºå®Ÿã«è¡Œã†
                if (!gameState.unlockedContent) {
                    gameState.unlockedContent = {
                        adventurers: new Set(['Novice Explorer']),
                        monsters: new Set(['Shoggoth']),
                        upgrades: new Set(['Ritual Knowledge']),
                        resources: new Set()
                    };
                } else {
                    // æ—¢å­˜ã®unlockedContentã‚’ç¢ºå®Ÿã«Setã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›
                    gameState.unlockedContent = {
                        adventurers: new Set(Array.from(gameState.unlockedContent.adventurers || ['Novice Explorer'])),
                        monsters: new Set(Array.from(gameState.unlockedContent.monsters || ['Shoggoth'])),
                        upgrades: new Set(Array.from(gameState.unlockedContent.upgrades || ['Ritual Knowledge'])),
                        resources: new Set(Array.from(gameState.unlockedContent.resources || []))
                    };
                }

                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
                if (!gameState.monsters) {
                    gameState.monsters = JSON.parse(JSON.stringify(initialGameState.monsters));
                }

                // ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã®åˆæœŸåŒ–
                if (!Array.isArray(gameState.adventurers)) {
                    gameState.adventurers = JSON.parse(JSON.stringify(initialGameState.adventurers));
                }

                // çµ±è¨ˆæƒ…å ±ã®åˆæœŸåŒ–
                if (!gameState.statistics) {
                    gameState.statistics = {
                        startTime: Date.now(),
                        lastUpdate: Date.now(),
                        totalSourceGenerated: 0,
                        totalMiasmaGenerated: 0,
                        totalFollowersRecruited: 0,
                        peakFollowers: 0,
                        totalMonstersSummoned: 0,
                        totalMadnessAttempts: 0,
                        successfulMadness: 0
                    };
                }

                // å¥‘ç´„ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
                if (!gameState.pacts) {
                    gameState.pacts = {
                        active: [],
                        commonMultiplier: 1,
                        tickSpeedMultiplier: 1,
                        showingPactModal: false
                    };
                }

                debug("Game state initialization complete");
                return gameState;
            }

            document.addEventListener('DOMContentLoaded', function () {
                const topButtons = document.getElementById('top-buttons');
                const statsButton = document.getElementById('toggleStatistics');

                if (statsButton) {
                    statsButton.addEventListener('click', toggleStatisticsModal);
                }

                // Initialize modal
                const modal = document.getElementById('statisticsModal');
                if (modal) {
                    modal.style.display = 'none';
                    modal.classList.remove('active');
                }
            });

            // Statistics ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹é–‰ã™ã‚‹é–¢æ•°
            function toggleStatisticsModal() {
                const modal = document.getElementById('statisticsModal');
                if (modal) {
                    if (modal.classList.contains('active')) {
                        modal.classList.remove('active');
                        modal.style.display = 'none';
                    } else {
                        modal.classList.add('active');
                        modal.style.display = 'block';
                        updateStatistics(); // çµ±è¨ˆæƒ…å ±ã‚’æ›´æ–°
                    }
                }
            }

            // Modify existing game functions to track statistics
            const originalGameLoop = gameLoop;
            gameLoop = function () {
                const before = {
                    source: gameState.source,
                    miasma: gameState.miasma
                };

                originalGameLoop();

                if (gameState.statistics) {
                    gameState.statistics.totalSourceGenerated += Math.max(0, gameState.source - before.source);
                    gameState.statistics.totalMiasmaGenerated += Math.max(0, gameState.miasma - before.miasma);
                    gameState.statistics.peakFollowers = Math.max(gameState.statistics.peakFollowers, gameState.followers);
                }
            };

            const originalRecruitFollower = recruitFollower;
            recruitFollower = function () {
                const beforeCount = gameState.followers;
                originalRecruitFollower();
                if (gameState.followers > beforeCount && gameState.statistics) {
                    gameState.statistics.totalFollowersRecruited++;
                }
            };

            const originalSummonMonster = summonMonster;
            summonMonster = function (type) {
                const beforeCount = gameState.monsters[type].count;
                originalSummonMonster(type);
                if (gameState.monsters[type].count > beforeCount && gameState.statistics) {
                    gameState.statistics.totalMonstersSummoned++;
                }
            };

            const originalAttemptMadness = attemptMadness;
            attemptMadness = function (index) {
                if (!gameState.statistics) return originalAttemptMadness(index);

                const adventurer = gameState.adventurers[index];
                const wasMad = adventurer.isMad;
                gameState.statistics.totalMadnessAttempts++;

                originalAttemptMadness(index);

                if (!wasMad && adventurer.isMad) {
                    gameState.statistics.successfulMadness++;
                }
            };

            // DOMContentLoadedã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ä¿®æ­£
            document.addEventListener('DOMContentLoaded', function () {
                debug("DOM fully loaded");

                try {
                    // åˆæœŸåŒ–å‡¦ç†ã®å®Ÿè¡Œ
                    initializeGame();

                    // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã®é–‹å§‹
                    startGameLoop();

                    // è‡ªå‹•ã‚»ãƒ¼ãƒ–ã®è¨­å®š
                    setupAutoSave();

                    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®è¨­å®š
                    setInterval(createBackup, 30 * 60 * 1000); // 30åˆ†ã”ã¨

                    debug("Initial setup complete");
                } catch (error) {
                    console.error("Error during initialization:", error);
                    handleInitializationError(error);
                }
            });

            // pauseGameé–¢æ•°ã‚’ä¿®æ­£
            function pauseGame() {
                gamePaused = true;
                debug("Game paused");
                // ä¸€æ™‚åœæ­¢æ™‚ã®æ™‚åˆ»ã‚’è¨˜éŒ²
                gameState.pauseStartTime = Date.now();
            }

            // resumeGameé–¢æ•°ã‚’ä¿®æ­£
            function resumeGame() {
                const pauseDuration = Date.now() - (gameState.pauseStartTime || Date.now());

                // ã™ã¹ã¦ã®ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ©ãƒ¼ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’èª¿æ•´
                gameState.adventurers.forEach(adventurer => {
                    if (adventurer.cooldownEndTime > gameState.pauseStartTime) {
                        adventurer.cooldownEndTime += pauseDuration;
                    }
                });

                gamePaused = false;
                lastFrameTime = Date.now();
                delete gameState.pauseStartTime;
                logAction("Game resumed");
            }

            // ãƒšãƒ¼ã‚¸ã‚’é›¢ã‚Œã‚‹å‰ã®ã‚»ãƒ¼ãƒ–
            window.addEventListener('beforeunload', function () {
                debug("Saving game before unload");
                saveGame();
            });

            // ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
            window.addEventListener('error', function (event) {
                console.error("Game error:", event.error);
                handleGameError(event.error);
            });

            // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°é–¢æ•°ã‚’è¿½åŠ 
            function handleInitializationError(error) {
                console.error("Initialization error:", error);

                // ã‚¨ãƒ©ãƒ¼é€šçŸ¥ã‚’è¡¨ç¤º
                const notification = document.createElement('div');
                notification.className = 'error-notification';
                notification.innerHTML = `
        <h3>Initialization Error</h3>
        <p>An error occurred while loading the game: ${error.message}</p>
        <p>Please try refreshing the page. If the problem persists, you may need to reset the game.</p>
        <button onclick="resetGameAndClearSave()">Reset Game</button>
        <button onclick="this.parentElement.remove()">Close</button>
    `;
                document.body.appendChild(notification);

                // åŸºæœ¬çš„ãªã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®å¾©æ—§ã‚’è©¦ã¿ã‚‹
                try {
                    resetGameState();
                    rebuildUI();
                } catch (recoveryError) {
                    console.error("Recovery failed:", recoveryError);
                }
            }

            // Make sure all required functions are defined
            function updateStatistics() {
                if (!gameState.statistics) return;

                const stats = gameState.statistics;
                const now = Date.now();

                try {
                    // åŸºæœ¬çš„ãªæ™‚é–“çµ±è¨ˆ
                    const timePlayed = Math.floor((now - stats.startTime) / 1000);
                    const activePlayTime = stats.activePlayTime || timePlayed; // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤æ™‚é–“
                    document.getElementById('timePlayed').textContent = formatTime(timePlayed);
                    document.getElementById('activePlayTime').textContent = formatTime(activePlayTime);

                    // ãƒªã‚½ãƒ¼ã‚¹ç”Ÿç”£çµ±è¨ˆ
                    const resourceStats = {
                        'totalSourceGenerated': stats.totalSourceGenerated,
                        'sourcePerSecond': stats.totalSourceGenerated / timePlayed,
                        'totalMiasmaGenerated': stats.totalMiasmaGenerated,
                        'miasmaPerSecond': stats.totalMiasmaGenerated / timePlayed,
                        'totalCultosGenerated': stats.totalCultosGenerated || 0,
                        'cultosPerSecond': (stats.totalCultosGenerated || 0) / timePlayed
                    };

                    // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼é–¢é€£çµ±è¨ˆ
                    const followerStats = {
                        'totalFollowersRecruited': stats.totalFollowersRecruited,
                        'peakFollowers': stats.peakFollowers,
                        'currentFollowers': gameState.followers,
                        'currentFollowerEfficiency': gameState.followerEfficiency,
                        'averageFollowersPerSecond': stats.totalFollowersRecruited / timePlayed
                    };

                    // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼é–¢é€£çµ±è¨ˆ
                    const monsterStats = {
                        'totalMonstersSummoned': stats.totalMonstersSummoned,
                        'uniqueMonsterTypes': Object.values(gameState.monsters).filter(m => m.count > 0).length,
                        'mostCommonMonster': getMostCommonMonster(),
                        'totalMonsterCost': calculateTotalMonsterCost(),
                        'averageMonstersPerMinute': (stats.totalMonstersSummoned / timePlayed) * 60
                    };

                    // ç‹‚æ°—é–¢é€£çµ±è¨ˆ
                    const madnessStats = {
                        'totalMadnessAttempts': stats.totalMadnessAttempts,
                        'successfulMadness': stats.successfulMadness,
                        'madnessSuccessRate': calculateMadnessSuccessRate(stats),
                        'averageMadnessAttemptsPerHour': (stats.totalMadnessAttempts / timePlayed) * 3600
                    };

                    // å¥‘ç´„é–¢é€£çµ±è¨ˆ
                    const pactStats = {
                        'activePacts': gameState.pacts.active.length,
                        'totalPactsSealed': stats.totalPactsSealed || 0,
                        'currentPactMultiplier': gameState.pacts.commonMultiplier,
                        'currentTickSpeedMultiplier': gameState.pacts.tickSpeedMultiplier
                    };

                    // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰é–¢é€£çµ±è¨ˆ
                    const upgradeStats = {
                        'totalUpgradesPurchased': gameState.upgrades.length,
                        'upgradeEfficiency': calculateUpgradeEfficiency(),
                        'totalUpgradeCost': calculateTotalUpgradeCost()
                    };

                    // åŠ¹ç‡æ€§æŒ‡æ¨™
                    const efficiencyStats = {
                        'overallGameEfficiency': calculateOverallEfficiency(),
                        'resourceGenerationEfficiency': calculateResourceEfficiency(),
                        'followerRecruitmentEfficiency': calculateFollowerEfficiency()
                    };

                    // çµ±è¨ˆæƒ…å ±ã®è¡¨ç¤ºã‚’æ›´æ–°
                    updateStatisticsDisplay({
                        resourceStats,
                        followerStats,
                        monsterStats,
                        madnessStats,
                        pactStats,
                        upgradeStats,
                        efficiencyStats
                    });

                    // è¿½åŠ ã®çµ±è¨ˆæƒ…å ±ã®æ›´æ–°
                    updateAdvancedStatistics();
                    updateAchievementProgress();
                    updateHistoricalData();

                } catch (error) {
                    console.error("Error updating statistics:", error);
                    logAction(`Statistics update error: ${error.message}`);
                }
            }

            // è£œåŠ©é–¢æ•°
            function calculateMadnessSuccessRate(stats) {
                return stats.totalMadnessAttempts > 0
                    ? (stats.successfulMadness / stats.totalMadnessAttempts * 100).toFixed(1)
                    : '0.0';
            }

            function calculateTotalMonsterCost() {
                return Object.values(gameState.monsters).reduce((total, monster) => {
                    return total + (monster.count * monster.baseFollowerCost);
                }, 0);
            }

            function calculateUpgradeEfficiency() {
                return gameState.upgrades.reduce((total, upgrade) => {
                    const upgradeData = upgradeDefinitions[upgrade];
                    return total + (upgradeData.efficiency || 1);
                }, 1);
            }

            function updateStatisticsDisplay(stats) {
                // å„çµ±è¨ˆã‚«ãƒ†ã‚´ãƒªãƒ¼ã®è¡¨ç¤ºã‚’æ›´æ–°
                Object.entries(stats).forEach(([category, categoryStats]) => {
                    Object.entries(categoryStats).forEach(([statName, value]) => {
                        const element = document.getElementById(statName);
                        if (element) {
                            element.textContent = typeof value === 'number'
                                ? formatNumber(value)
                                : value;
                        }
                    });
                });
            }

            function updateAdvancedStatistics() {
                // é«˜åº¦ãªçµ±è¨ˆæƒ…å ±ã®æ›´æ–°ï¼ˆã‚°ãƒ©ãƒ•ã€ãƒãƒ£ãƒ¼ãƒˆãªã©ï¼‰
                updateResourceGraph();
                updateEfficiencyTrends();
                updateProgressionMetrics();
            }

            function updateAchievementProgress() {
                // å®Ÿç¸¾ã®é€²æ—çŠ¶æ³ã‚’æ›´æ–°
                const achievements = calculateAchievementProgress();
                displayAchievementProgress(achievements);
            }

            function updateHistoricalData() {
                // å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°ã¨è¡¨ç¤º
                const historicalData = getHistoricalGameData();
                displayHistoricalTrends(historicalData);
            }

            // ç·ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚³ã‚¹ãƒˆã®è¨ˆç®—
            function calculateTotalUpgradeCost() {
                return gameState.upgrades.reduce((total, upgradeId) => {
                    const upgrade = upgradeDefinitions[upgradeId];
                    return total + (upgrade ? upgrade.cost : 0);
                }, 0);
            }

            // å…¨ä½“çš„ãªåŠ¹ç‡æ€§ã®è¨ˆç®—
            function calculateOverallEfficiency() {
                const baseEfficiency = 1;
                const followerBonus = gameState.followerEfficiency || 1;
                const upgradeBonus = calculateUpgradeEfficiency();
                const pactBonus = gameState.pacts?.commonMultiplier || 1;

                return (baseEfficiency * followerBonus * upgradeBonus * pactBonus).toFixed(2);
            }

            // ãƒªã‚½ãƒ¼ã‚¹ç”ŸæˆåŠ¹ç‡ã®è¨ˆç®—
            function calculateResourceEfficiency() {
                const baseRate = gameState.sourcePerSecond || 0;
                const totalTime = (Date.now() - gameState.statistics.startTime) / 1000;
                const averageRate = gameState.statistics.totalSourceGenerated / totalTime;

                return (averageRate / baseRate || 1).toFixed(2);
            }

            // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼å‹Ÿé›†åŠ¹ç‡ã®è¨ˆç®—
            function calculateFollowerEfficiency() {
                const currentFollowers = gameState.followers;
                const totalRecruits = gameState.statistics.totalFollowersRecruited;
                const totalTime = (Date.now() - gameState.statistics.startTime) / 1000;

                return ((currentFollowers / totalRecruits) * (totalRecruits / totalTime)).toFixed(2);
            }

            function calculateFollowerProduction(adventurer) {
    // åŸºæœ¬ç”Ÿç”£é‡
    let production = adventurer.followerProduction;

    // åŸºæœ¬åŠ¹ç‡ã‚’é©ç”¨ï¼ˆ1æœªæº€ã®å€¤ã®å ´åˆã¯åŠ ç®—ã«å¤‰æ›´ï¼‰
    const baseEfficiency = (gameState.followerEfficiency || 0.1);
    production *= (baseEfficiency >= 1 ? baseEfficiency : 1 + baseEfficiency);

    // ãƒ¬ãƒ™ãƒ«ãƒœãƒ¼ãƒŠã‚¹ã¨ãã®ä»–ã®ãƒœãƒ¼ãƒŠã‚¹ã‚’è¨ˆç®—
    let totalBonus = 0;
    
    // ãƒ¬ãƒ™ãƒ«ãƒœãƒ¼ãƒŠã‚¹ï¼ˆ10%ãšã¤åŠ ç®—ï¼‰
    totalBonus += (adventurer.level - 1) * 0.1;

    // å¥‘ç´„åŠ¹æœã‚’åŠ ç®—
    if (gameState.pacts?.commonMultiplier) {
        // å¥‘ç´„ä¹—æ•°ãŒ1æœªæº€ã®å ´åˆã¯ã€ãƒœãƒ¼ãƒŠã‚¹ã¨ã—ã¦é©åˆ‡ã«å¤‰æ›
        const pactBonus = gameState.pacts.commonMultiplier - 1;
        totalBonus += Math.max(pactBonus, 0); // è² ã®å€¤ã‚’é˜²ã
    }

    // ãã®ä»–ã®ãƒœãƒ¼ãƒŠã‚¹ã‚’åŠ ç®—
    if (gameState.followerProductionBonus) {
        // 1æœªæº€ã®å€¤ã®å ´åˆã¯é©åˆ‡ã«ãƒœãƒ¼ãƒŠã‚¹ã¨ã—ã¦å¤‰æ›
        const productionBonus = gameState.followerProductionBonus;
        totalBonus += (productionBonus >= 1 ? productionBonus - 1 : productionBonus);
    }

    // å…¨ã¦ã®ãƒœãƒ¼ãƒŠã‚¹ã‚’é©ç”¨ï¼ˆãƒœãƒ¼ãƒŠã‚¹ã¯å¿…ãšåŠ ç®—ã¨ã—ã¦æ‰±ã†ï¼‰
    production *= (1 + Math.max(totalBonus, 0));

    return production;
}

            // ãƒªã‚½ãƒ¼ã‚¹ã‚°ãƒ©ãƒ•ã®æ›´æ–°
            function updateResourceGraph() {
                // ã‚°ãƒ©ãƒ•æ©Ÿèƒ½ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã“ã“ã§æ›´æ–°
                // ç¾æ™‚ç‚¹ã§ã¯ç©ºã®å®Ÿè£…
            }

            // åŠ¹ç‡æ€§ãƒˆãƒ¬ãƒ³ãƒ‰ã®æ›´æ–°
            function updateEfficiencyTrends() {
                // åŠ¹ç‡æ€§ãƒˆãƒ¬ãƒ³ãƒ‰ã®è¿½è·¡ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã“ã“ã§æ›´æ–°
                // ç¾æ™‚ç‚¹ã§ã¯ç©ºã®å®Ÿè£…
            }

            // é€²è¡Œåº¦ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®æ›´æ–°
            function updateProgressionMetrics() {
                // é€²è¡Œåº¦ã®è¿½è·¡ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã“ã“ã§æ›´æ–°
                // ç¾æ™‚ç‚¹ã§ã¯ç©ºã®å®Ÿè£…
            }

            // å®Ÿç¸¾ã®é€²æ—çŠ¶æ³ã®è¨ˆç®—
            function calculateAchievementProgress() {
                // å®Ÿç¸¾ã‚·ã‚¹ãƒ†ãƒ ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã“ã“ã§è¨ˆç®—
                return {};
            }

            // å®Ÿç¸¾ã®é€²æ—çŠ¶æ³ã®è¡¨ç¤º
            function displayAchievementProgress(achievements) {
                // å®Ÿç¸¾ã®è¡¨ç¤ºãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã“ã“ã§è¡¨ç¤º
                // ç¾æ™‚ç‚¹ã§ã¯ç©ºã®å®Ÿè£…
            }

            // å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
            function getHistoricalGameData() {
                // å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã®è¿½è·¡ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã“ã“ã§ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                return {};
            }

            // å±¥æ­´ãƒˆãƒ¬ãƒ³ãƒ‰ã®è¡¨ç¤º
            function displayHistoricalTrends(historicalData) {
                // å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã®è¡¨ç¤ºãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã“ã“ã§è¡¨ç¤º
                // ç¾æ™‚ç‚¹ã§ã¯ç©ºã®å®Ÿè£…
            }

            // æœ€ã‚‚ä¸€èˆ¬çš„ãªãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®å–å¾—
            function getMostCommonMonster() {
                if (!gameState.monsters || Object.keys(gameState.monsters).length === 0) {
                    return 'None';
                }

                const monsterCounts = Object.entries(gameState.monsters)
                    .map(([id, monster]) => ({
                        id,
                        count: monster.count,
                        name: monster.name || id
                    }))
                    .filter(m => m.count > 0)
                    .sort((a, b) => b.count - a.count);

                return monsterCounts.length > 0 ? monsterCounts[0].name : 'None';
            }

            function getMostCommonMonster() {
                let maxCount = 0;
                let mostCommon = 'None';

                for (const [monster, data] of Object.entries(gameState.monsters)) {
                    if (data.count > maxCount) {
                        maxCount = data.count;
                        mostCommon = monster;
                    }
                }

                return maxCount > 0 ? `${mostCommon} (${formatNumber(maxCount)})` : 'None';
            }

            // ã‚²ãƒ¼ãƒ ãƒ­ãƒ¼ãƒ‰æ™‚ã®PACTçŠ¶æ…‹å¾©å…ƒã‚’æ”¹å–„
            const originalLoadGame = loadGame;
            loadGame = function () {
                const result = originalLoadGame();

                if (result) {
                    // PACTã®çŠ¶æ…‹ã‚’ç¢ºèªã—ã¦åˆæœŸåŒ–
                    if (!gameState.pacts) {
                        gameState.pacts = {
                            active: [],
                            currentFollowerArt: null,
                            commonMultiplier: 1,
                            tickSpeedMultiplier: 1,
                            showingPactModal: false
                        };
                    }

                    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªPACTã«åŸºã¥ã„ã¦ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã®å¤–è¦³ã‚’æ›´æ–°
                    if (gameState.pacts.active.length > 0) {
                        const lastPactId = gameState.pacts.active[gameState.pacts.active.length - 1];
                        const lastPact = PACTS[lastPactId];
                        if (lastPact) {
                            gameState.pacts.currentFollowerArt = lastPact.followerAsciiArt;
                            gameState.pacts.currentTooltipText = lastPact.tooltipText;
                        }
                    }

                    // UIæ›´æ–°
                    updateFollowerAppearance();
                    updateAllDisplays();
                }
                initializeNotificationSystem(); // é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã‚’å†ç¢ºèª
                return result;
            };

            // ã‚»ãƒ¼ãƒ–æ©Ÿèƒ½ã®æ”¹å–„
            const originalSaveGame = saveGame;
            saveGame = function () {
                // PACTã®çŠ¶æ…‹ã‚’ç¢ºå®Ÿã«ä¿å­˜
                if (gameState.pacts?.active?.length > 0) {
                    const lastPactId = gameState.pacts.active[gameState.pacts.active.length - 1];
                    const lastPact = PACTS[lastPactId];
                    if (lastPact) {
                        gameState.pacts.currentFollowerArt = lastPact.followerAsciiArt;
                        gameState.pacts.currentTooltipText = lastPact.tooltipText;
                    }
                }

                originalSaveGame();
                initializeNotificationSystem(); // é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã‚’å†ç¢ºèª
            };

            // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®æ›´æ–°ã‚‚æ”¹å–„
            const originalUpdateFollowerSection = updateFollowerSection;
            updateFollowerSection = function () {
                originalUpdateFollowerSection();
                updateFollowerAppearance();
            };

            // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦åˆæœŸåŒ–ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
            let isInitialized = false;

            document.addEventListener('DOMContentLoaded', function () {
                // é‡è¤‡åˆæœŸåŒ–ã‚’é˜²ã
                if (isInitialized) return;
                isInitialized = true;

                // åˆæœŸåŒ–å‡¦ç†
                initializeGame();
                // ãã®ä»–ã®åˆæœŸåŒ–å‡¦ç†...
            });

        </script>
</body>

</html>
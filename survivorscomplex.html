<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Survivors Complex</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            overflow: hidden;
            background: #000;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-height: 100vh;
            padding: 10px;
            box-sizing: border-box;
            background: #000;
        }

        /* ステータスバー */
        .status-bar {
            flex: 0 0 auto;
            padding: 8px;
            background: #111;
            border: 1px solid #333;
            margin-bottom: 5px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .game-area {
            flex: 1 1 auto;
            position: relative;
            background: rgb(15, 15, 15);
            border: 1px solid #333;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            cursor: none;
        }

        /* 武器選択コンテナ */
        .weapon-select-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgb(24, 24, 24);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
        }

        /* 武器選択画面 */
        .weapon-select {
            font-family: 'courier', monospace;
            white-space: pre;
            line-height: 2;
            letter-spacing: 0.1em;
            font-size: 12px;
            color: #5e9dea;
            transform-origin: center;
            padding: 20px;
        }

        /* ゲーム画面の境界線用スタイルを追加 */
        .game-border {
            position: relative;
            padding: 1px;
            background: #333;
            border-radius: 2px;
        }

        .game-border::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: linear-gradient(45deg, #444, #222);
            border-radius: 3px;
            z-index: -1;
        }

        /* 境界マーカーのスタイル */
        .border-top {
            color: #666;
        }

        .border-bottom {
            color: #666;
        }

        .border-left {
            color: #666;
        }

        .border-right {
            color: #666;
        }

        .border-corner {
            color: #888;
        }

        #game {
            font-family: 'courier', monospace;
            white-space: pre;
            line-height: 1.1;
            letter-spacing: 0.1em;
            font-size: 14px;
            color: rgb(12, 12, 12);
            position: relative;
            transform-origin: top left;
            padding: 1px;
            background: rgb(24, 24, 24);
        }

        /* ステータス表示 */
        #stats {
            color: rgb(200, 199, 199);
            font-family: monospace;
            line-height: 1.1;
        }

        /* レスポンシブ対応 */
        @media (max-height: 800px) {
            .weapon-select {
                font-size: 12px;
                transform: scale(0.9);
            }
        }

        @media (max-height: 600px) {
            .weapon-select {
                font-size: 10px;
                transform: scale(0.8);
            }
        }

        /* 新しいスタイルを追加 */
        .player {
            color: #5e9dea;
            text-shadow: 0 0 10px #adcaee;
        }

        /* プレイヤーは緑色 */
        .enemy {
            color: #ff0000;
            text-shadow: 0 0 10px #000000;
        }

        .unique-enemy {
            transition: transform 0.2s ease-in-out;
            position: relative;
            z-index: 3;
        }

        /* 敵は赤色 */
        .projectile {
            text-shadow: 0 0 10px currentColor;
        }

        /* オービット投射物 */
        .projectile-orbit {
            color: #dae7e8;
            text-shadow: 0 0 10px #0bd6e4;
        }

        /* オービットのダメージ範囲表示 */
        .projectile-orbit-splash {
            color: #dae7e8;
            text-shadow: 0 0 10px #0bd6e4;
            opacity: 0.5;
        }

        .projectile-laser {
            color: #ff74ff;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            animation: laser-pulse 0.15s infinite;
            position: relative;
            z-index: 3;
        }

        /* レーザー消滅アニメーション用のクラスを追加 */
        .projectile-laser-fade {
            animation: laser-fade 0.3s forwards;
        }

        .projectile-laser {
            color: #ff74ff;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            animation: laser-pulse 0.7s infinite;
            position: relative;
            z-index: 3;
            opacity: 0.9;
            /* 基本の不透明度を設定 */
        }

        /* レーザーの広がりエフェクト用の新しいクラス */
        .projectile-laser-spread {
            position: absolute;
            color: #ff74ff;
            text-shadow: 0 0 8px #ff00ff;
            animation: laser-spread 0.3s forwards;
            animation: laser-pulse 0.7s infinite;
            z-index: 2;
            transform-origin: center;
            pointer-events: none;
        }

        @keyframes laser-spread {
            0% {
                transform: scale(1);
                opacity: 0.4;
            }

            100% {
                opacity: 0.2;
            }
        }

        .projectile-laser-energy {
            position: absolute;
            color: #ff99ff;
            text-shadow: 0 0 8px #ff99ff;
            animation: laser-energy 0.3s infinite;
            opacity: 0.7;
            z-index: 2;
            pointer-events: none;
        }

        @keyframes laser-fade {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.5;
                transform: scale(1.2);
            }

            100% {
                opacity: 0;
                transform: scale(0.8);
            }
        }

        @keyframes laser-pulse {
            0% {
                text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            }

            50% {
                text-shadow: 0 0 15px #ff00ff, 0 0 25px #ff00ff;
            }

            100% {
                text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            }
        }

        @keyframes laser-energy {
            0% {
                opacity: 0.3;
                transform: scale(0.8);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.2);
            }

            100% {
                opacity: 0.3;
                transform: scale(0.8);
            }
        }

        @keyframes pulse {
            from {
                text-shadow: 0 0 4px #ff0000;
            }

            to {
                text-shadow: 0 0 8px #ff0000;
            }
        }

        .projectile-missile {
            color: #ff6600;
            text-shadow: 0 0 10px #ff3300;
        }

        .gem {
            transition: transform 0.2s ease-in-out;
            position: relative;
            display: inline-block;
        }

        /* ジェムは水色 */
        .effect {
            color: #ff5555;
            /* 赤みがかった色に変更 */
            text-shadow: 0 0 10px #ff0000;
        }

        .damage-effect {
            color: #ff0000;
            /* より鮮やかな赤色 */
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
            /* より強い発光効果 */
            animation: damage-flash 0.5s linear infinite;
            /* 点滅アニメーション */
            pointer-events: none;
            /* エフェクトが他の要素の操作を邪魔しないように */
        }

        @keyframes damage-flash {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        @keyframes popup {
            0% {
                transform: translate(-50%, -50%);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, calc(-50% - 20px));
                opacity: 0;
            }
        }

        .popup-container {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10000;
        }

        @keyframes popup {
            0% {
                transform: translate(-50%, -100%);
                opacity: 0.8;
            }

            25% {
                transform: translate(-50%, calc(-100% - 15px)) rotate(2deg);
                opacity: 1;
            }

            75% {
                transform: translate(-50%, calc(-100% - 25px)) rotate(-2deg);
                opacity: 0.8;
            }

            100% {
                transform: translate(-50%, calc(-100% - 35px));
                opacity: 0;
            }
        }

        @keyframes criticalPop {
            0% {
                transform: translate(-50%, -100%) scale(0.5);
                opacity: 0;
            }

            15% {
                transform: translate(-52%, -110%) scale(1.2) rotate(4deg);
                opacity: 0.8;
            }

            30% {
                transform: translate(-48%, -65%) scale(1.3) rotate(-3deg);
                opacity: 1;
            }

            45% {
                transform: translate(-51%, -70%) scale(1.2) rotate(2deg);
                opacity: 1;
            }

            60% {
                transform: translate(-49%, -75%) scale(1.1) rotate(-2deg);
                opacity: 0.9;
            }

            75% {
                transform: translate(-50%, -80%) scale(1.0) rotate(1deg);
                opacity: 0.8;
            }

            90% {
                transform: translate(-51%, -90%) scale(0.9) rotate(-1deg);
                opacity: 0.4;
            }

            100% {
                transform: translate(-50%, -150%) scale(0.8);
                opacity: 0;
            }
        }

        .damage-popup {
            position: absolute;
            font-family: monospace;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 1000;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
            animation: popup 1s ease-out forwards;
            transition: transform 0.3s ease-out;
        }

        @keyframes popup {
            0% {
                transform: translate(-50%, -50%);
                opacity: 1;
            }

            20% {
                transform: translate(-50%, -70%);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -100%);
                opacity: 0;
            }
        }

        @keyframes criticalText {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }

            25% {
                transform: translate(-50%, -70%) scale(1.2);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -120%) scale(0.8);
                opacity: 0;
            }
        }

        .damage-flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.3);
            pointer-events: none;
            opacity: 0;
            z-index: 9999;
        }

        /* フラッシュアニメーション */
        @keyframes screen-flash {
            0% {
                opacity: 0;
            }

            25% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        .damage-flash-overlay.active {
            animation: screen-flash 0.3s ease-out;
        }

        /* エフェクトはマゼンタ */
        .hp-high {
            color: #00ff00;
        }

        /* HPバー（高）は緑 */
        .hp-mid {
            color: #ffff00;
        }

        /* HPバー（中）は黄色 */
        .hp-low {
            color: #ff0000;
        }
    </style>
</head>

<body>
    <div class="damage-flash-overlay" id="damageFlashOverlay"></div>
    <div class="game-container">
        <div class="status-bar">
            <div id="stats"></div>
        </div>
        <div class="game-area">
            <div class="game-border">
                <div id="game"></div>
            </div>
            <div class="weapon-select-container" id="weapon-select"></div>
        </div>
    </div>

    <script>
        class Game {
            constructor(width, height) {
                this.inputEnabled = true;  // 入力を明示的に有効化

                // ビューポートサイズに基づいて適切なサイズを計算
                const computeGameSize = () => {
                    const container = document.querySelector('.game-area');
                    if (!container) return { width: 60, height: 40 };

                    const fontWidth = 14;  // フォントの幅（ピクセル）
                    const fontHeight = 15.4;  // フォントの高さ（ピクセル）

                    return {
                        width: Math.floor((container.clientWidth - 40) / fontWidth),
                        height: Math.floor((container.clientHeight - 40) / fontHeight)
                    };
                };

                const gameSize = computeGameSize();
                this.width = 90;  // マップの幅を固定
                this.height = 55; // マップの高さを固定

                // フォントサイズとセルサイズの設定
                this.cellWidth = 14;   // ピクセル単位でのセル幅
                this.cellHeight = 15.4; // ピクセル単位でのセル高さ

                // ビューポートサイズの計算をメソッド化
                this.calculateViewportSize();

                this.portalTimer = 0;
                this.maxPortalTime = 100; // 10秒 (10フレーム/秒)
                this.isPortalActive = false;
                this.portalEffects = [];
                this.gameState = 'title';  // 'home'状態を追加

                this.popupManager = new DamagePopupManager();
                this.uniqueEnemySystem = new UniqueEnemySpawnSystem(this);

                this.dangerLevel = 1; // 危険度 (1-5)
                this.dangerLevelNames = [
                    'PEACEFUL',
                    'DANGEROUS',
                    'HAZARDOUS',
                    'EXTREME',
                    'CATASTROPHIC'
                ];
                this.dangerLevelColors = [
                    '#44ff44', // 緑
                    '#ffff44', // 黄
                    '#ffaa44', // オレンジ
                    '#ff4444', // 赤
                    '#ff44ff'  // マゼンタ
                ];
                this.nextDangerLevelChange = 300; // 30秒 (10フレーム/秒)

                // 武器定義を最初に行う
                this.availableWeapons = {
                    orbit: {
                        name: "Orbital Blades",
                        description: "Rotating energy blades that slice through enemies",
                        type: 'orbit',
                        angle: 0,
                        radius: 3,
                        damage: {
                            base: 5,  // 基本ダメージを調整
                            variationPercent: 0.35    // 基本値の±35%の変動
                        },
                        splashDamage: {
                            base: 2,  // スプラッシュダメージを調整
                            variationPercent: 0.30    // 基本値の±30%の変動
                        },
                        projectiles: 1,
                        damageRadius: 2,
                        splashCooldown: 0,
                        maxSplashCooldown: 5,
                        splashDuration: 3,
                        splashActive: false,
                        ascii: [
                            "  ◢◣  ",
                            "◢━◣╋◢━◣",
                            "  ◥◤  "
                        ]
                    },
                    laser: {
                        name: "Quantum Laser",
                        description: "Piercing beam of concentrated energy",
                        type: 'laser',
                        damage: {
                            base: 2,  // 基本ダメージを調整
                            variationPercent: 0.40
                        },
                        width: 1,
                        cooldown: 0,
                        maxCooldown: 15,
                        range: 10,
                        active: false,
                        duration: 3,
                        spreadLevel: 1,
                        maxSpreadLevel: 6,
                        spreadWidth: 0.05,  // スプレッド幅を0.1から0.05に削減
                        ascii: [
                            "   ┃   ",
                            "═══╋═══",
                            "   ┃   "
                        ]
                    },
                    missile: {
                        name: "Nova Missiles",
                        description: "Smart missiles with explosive damage",
                        type: 'missile',
                        damage: {
                            base: 7,  // 基本ダメージを調整
                            variationPercent: 0.35
                        },
                        splashDamage: {
                            base: 3,  // スプラッシュダメージを調整
                            variationPercent: 0.30
                        },
                        splashRadius: 2,
                        speed: 0.5,
                        cooldown: 0,
                        maxCooldown: 20,
                        projectiles: 1,
                        maxProjectiles: 6,
                        splashDuration: 3,  // スプラッシュの持続時間を追加
                        ascii: [
                            "  ╱|╲  ",
                            "◢━◣║◥━┤",
                            "  ╲|╱  "
                        ]
                    },
                    motorgun: {
                        name: "Motor Gun",
                        description: "Rapid-firing weapon that excels while stationary",
                        type: 'motorgun',
                        ascii: [
                            "  ┍━┑  ",
                            "━━╋━┥▶",
                            "  ┕━┙  "
                        ],
                        // モーターガンのデフォルト設定
                        defaults: {
                            damage: {
                                base: 3,
                                variationPercent: 0.25
                            },
                            fireRate: 2,
                            maxFireRate: 4,
                            spread: 0.3,
                            minSpread: 0.15,
                            maxSpread: 0.5,
                            projectileSpeed: 0.8,
                            maxCooldown: 3,
                            range: 12,
                            maxStabilization: 30,
                            ammo: 30,
                            maxAmmo: 30,
                            reloadTime: 30,
                            waitBonus: 1.5
                        }
                    }
                };

                this.laserSymbols = {
                    horizontal: '━',    // 水平
                    vertical: '┃',      // 垂直
                    diagonalUp: '╱',    // 右上がり斜め
                    diagonalDown: '╲'   // 右下がり斜め
                };

                // 選択された武器を格納するオブジェクト
                this.weapons = {};

                // プレイヤーの初期化を修正
                this.player = {
                    x: Math.floor(width / 2),
                    y: Math.floor(height / 2),
                    level: 1,
                    exp: 0,
                    expToLevel: 10,
                    stats: new PlayerStats()  // PlayerStats インスタンスを使用
                };

                // プレイヤーの基本属性を PlayerStats から取得
                this.player.health = this.player.stats.health;
                this.player.maxHealth = this.player.stats.maxHealth;
                this.player.moveSpeed = this.player.stats.moveSpeed;
                this.player.moveDelay = this.player.stats.moveDelay;
                this.player.gemAttractionRange = this.player.stats.gemAttractionRange;

                // PlayerSetup インスタンスを作成
                this.playerSetup = new PlayerSetup(this);


                this.gemTypes = {
                    common: {
                        symbol: '✦',
                        color: '#6aecfa',  // 水色
                        glow: '0 0 10px #e4fee7',
                        value: 1
                    },
                    uncommon: {
                        symbol: '✧',
                        color: '#4eff4e',  // 緑色
                        glow: '0 0 12px #4eff4e',
                        value: 2
                    },
                    rare: {
                        symbol: '❈',
                        color: '#4e4eff',  // 青色
                        glow: '0 0 15px #4e4eff',
                        value: 3
                    },
                    epic: {
                        symbol: '✥',
                        color: '#b44eff',  // 紫色
                        glow: '0 0 18px #b44eff',
                        value: 4
                    },
                    legendary: {
                        symbol: '✯',
                        color: '#ffcf4e',  // 金色
                        glow: '0 0 20px #ffcf4e',
                        value: 5
                    }
                };

                this.enemyTypes = {
                    grunt: {
                        name: 'Grunt',
                        symbol: 'g',
                        color: '#ff6666',  // 赤: 基本的な敵
                        health: 30,
                        damage: {
                            base: 10,
                            variationPercent: 0.25
                        },
                        moveSpeed: 3,
                        behavior: 'normal',
                        expValue: 1
                    },
                    speeder: {
                        name: 'Speeder',
                        symbol: 's',
                        color: '#66ff66',  // 緑: 素早い動きを表現
                        health: 20,
                        damage: {
                            base: 8,
                            variationPercent: 0.25
                        },
                        moveSpeed: 5,
                        behavior: 'zigzag',
                        expValue: 2,
                        abilities: ['dash']
                    },
                    tank: {
                        name: 'Tank',
                        symbol: 't',
                        color: '#4488ff',  // 青: 防御的な性質
                        health: 60,
                        damage: {
                            base: 15,
                            variationPercent: 0.25
                        },
                        moveSpeed: 2,
                        behavior: 'normal',
                        expValue: 3,
                        abilities: ['heal']
                    },
                    splitter: {
                        name: 'Splitter',
                        symbol: 'p',
                        color: '#aa88ff',  // 紫: 分裂する神秘的な性質
                        health: 40,
                        damage: {
                            base: 12,
                            variationPercent: 0.25
                        },
                        moveSpeed: 3,
                        behavior: 'circular',
                        expValue: 4,
                        abilities: ['split']
                    },
                    berserker: {
                        name: 'Berserker',
                        symbol: 'b',
                        color: '#ff9933',  // オレンジ: 攻撃的な性質
                        health: 45,
                        damage: {
                            base: 20,
                            variationPercent: 0.3
                        },
                        moveSpeed: 4,
                        behavior: 'ambush',
                        expValue: 5,
                        abilities: ['areaAttack', 'dash']
                    },
                    phantom: {
                        name: 'Phantom',
                        symbol: 'f',
                        color: '#66ffff',  // シアン: 幻のような性質
                        health: 35,
                        damage: {
                            base: 15,
                            variationPercent: 0.25
                        },
                        moveSpeed: 4,
                        behavior: 'circular',
                        expValue: 4,
                        abilities: ['dash']
                    },
                    guardian: {
                        name: 'Guardian',
                        symbol: 'u',
                        color: '#ffdd44',  // 金: 守護者としての高貴さ
                        health: 70,
                        damage: {
                            base: 18,
                            variationPercent: 0.25
                        },
                        moveSpeed: 2,
                        behavior: 'normal',
                        expValue: 6,
                        abilities: ['heal', 'areaAttack']
                    },
                    assassin: {
                        name: 'Assassin',
                        symbol: 'a',
                        color: '#ff44aa',  // マゼンタ: 危険な存在
                        health: 25,
                        damage: {
                            base: 25,
                            variationPercent: 0.3
                        },
                        moveSpeed: 5,
                        behavior: 'ambush',
                        expValue: 5,
                        abilities: ['dash']
                    }
                };

                this.tierColors = {
                    grunt: [
                        '#ff4444',  // Tier 0: 暗い赤
                        '#ff5533',  // Tier 1: オレンジ赤
                        '#ff6622',  // Tier 2: 深いオレンジ
                        '#ff7711',  // Tier 3: 明るいオレンジ
                        '#ff8800',  // Tier 4: オレンジ
                        '#ff9900',  // Tier 5: 黄オレンジ
                        '#ffaa00',  // Tier 6: 金色
                        '#ffcc00',  // Tier 7: 明るい金色
                        '#ffee00',  // Tier 8: 黄色
                        '#ffffff'   // Tier 9: 白色
                    ],
                    speeder: [
                        '#33ff33',  // Tier 0: 暗い緑
                        '#44ff44',  // Tier 1
                        '#55ff66',  // Tier 2
                        '#66ff88',  // Tier 3
                        '#77ffaa',  // Tier 4
                        '#88ffcc',  // Tier 5
                        '#99ffee',  // Tier 6
                        '#aaffff',  // Tier 7
                        '#ccffff',  // Tier 8
                        '#ffffff'   // Tier 9: 白色
                    ],
                    tank: [
                        '#2244ff',  // Tier 0: 濃い青
                        '#3355ff',  // Tier 1
                        '#4466ff',  // Tier 2
                        '#5577ff',  // Tier 3
                        '#6688ff',  // Tier 4
                        '#7799ff',  // Tier 5
                        '#88aaff',  // Tier 6
                        '#99bbff',  // Tier 7
                        '#aaccff',  // Tier 8
                        '#ffffff'   // Tier 9: 白色
                    ],
                    splitter: [
                        '#8800ff',  // Tier 0: 濃い紫
                        '#9922ff',  // Tier 1
                        '#aa44ff',  // Tier 2
                        '#bb66ff',  // Tier 3
                        '#cc88ff',  // Tier 4
                        '#ddaaff',  // Tier 5
                        '#eeccff',  // Tier 6
                        '#ffddff',  // Tier 7
                        '#ffeeff',  // Tier 8
                        '#ffffff'   // Tier 9: 白色
                    ],
                    berserker: [
                        '#ff4400',  // Tier 0: 濃いオレンジ赤
                        '#ff5522',  // Tier 1
                        '#ff6644',  // Tier 2
                        '#ff7766',  // Tier 3
                        '#ff8888',  // Tier 4
                        '#ff99aa',  // Tier 5
                        '#ffaacc',  // Tier 6
                        '#ffbbee',  // Tier 7
                        '#ffccff',  // Tier 8
                        '#ffffff'   // Tier 9: 白色
                    ],
                    phantom: [
                        '#00ffff',  // Tier 0: シアン
                        '#22ffff',  // Tier 1
                        '#44ffff',  // Tier 2
                        '#66ffff',  // Tier 3
                        '#88ffff',  // Tier 4
                        '#aaffff',  // Tier 5
                        '#ccffff',  // Tier 6
                        '#ddffff',  // Tier 7
                        '#eeffff',  // Tier 8
                        '#ffffff'   // Tier 9: 白色
                    ],
                    guardian: [
                        '#ffaa00',  // Tier 0: オレンジゴールド
                        '#ffbb22',  // Tier 1
                        '#ffcc44',  // Tier 2
                        '#ffdd66',  // Tier 3
                        '#ffee88',  // Tier 4
                        '#ffffaa',  // Tier 5
                        '#ffffcc',  // Tier 6
                        '#ffffdd',  // Tier 7
                        '#ffffee',  // Tier 8
                        '#ffffff'   // Tier 9: 白色
                    ],
                    assassin: [
                        '#ff0088',  // Tier 0: マゼンタ
                        '#ff229a',  // Tier 1
                        '#ff44ac',  // Tier 2
                        '#ff66be',  // Tier 3
                        '#ff88d0',  // Tier 4
                        '#ffaae2',  // Tier 5
                        '#ffccf4',  // Tier 6
                        '#ffddff',  // Tier 7
                        '#ffeeff',  // Tier 8
                        '#ffffff'   // Tier 9: 白色
                    ]
                };

                // 敵の行動パターン定義を明確化
                this.enemyBehaviors = {
                    normal: (enemy, game) => {
                        if (Math.random() > 0.3) { // 70%の確率で移動
                            const dx = game.player.x - enemy.x;
                            const dy = game.player.y - enemy.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist > 0) {
                                enemy.x += Math.sign(dx);
                                enemy.y += Math.sign(dy);
                            }
                        }
                    },

                    zigzag: (enemy, game) => {
                        // zigzagパターンの初期化
                        if (enemy.zigzagPhase === undefined) {
                            enemy.zigzagPhase = 0;
                            enemy.zigzagDirection = 1;
                        }

                        const dx = game.player.x - enemy.x;
                        const dy = game.player.y - enemy.y;
                        const distToPlayer = Math.sqrt(dx * dx + dy * dy);

                        // プレイヤーとの距離が近い場合は直接追跡
                        if (distToPlayer <= 3) {
                            enemy.x += Math.sign(dx);
                            enemy.y += Math.sign(dy);

                            // 追跡時のエフェクト
                            if (Math.random() > 0.7) {
                                game.effects.push({
                                    type: 'chase_trail',
                                    x: enemy.x,
                                    y: enemy.y,
                                    duration: 2,
                                    symbol: '→',
                                    color: '#ff9900',
                                    opacity: 0.6
                                });
                            }
                        } else {
                            // 通常のジグザグ移動
                            const angle = Math.atan2(dy, dx);
                            const amplitude = 2;
                            const frequency = 0.2;

                            enemy.zigzagPhase += frequency;
                            const offsetX = Math.cos(enemy.zigzagPhase) * amplitude;
                            const offsetY = Math.sin(enemy.zigzagPhase) * amplitude;

                            const targetX = enemy.x + Math.cos(angle) + offsetX;
                            const targetY = enemy.y + Math.sin(angle) + offsetY;

                            enemy.x = Math.max(0, Math.min(game.width - 1, Math.round(targetX)));
                            enemy.y = Math.max(0, Math.min(game.height - 1, Math.round(targetY)));

                            // ジグザグ移動のエフェクト
                            if (Math.random() > 0.7) {
                                game.effects.push({
                                    type: 'zigzag_trail',
                                    x: enemy.x,
                                    y: enemy.y,
                                    duration: 3,
                                    symbol: ['·', ':', '∙'][Math.floor(Math.random() * 3)],
                                    color: '#ffff00',
                                    opacity: 0.7
                                });
                            }
                        }
                    },

                    circular: (enemy, game) => {
                        // circular移動の初期化
                        if (enemy.circlePhase === undefined) {
                            enemy.circlePhase = Math.random() * Math.PI * 2;
                            enemy.circleRadius = Math.random() * 2 + 3;
                            enemy.circleSpeed = 0.1;
                        }

                        const dx = game.player.x - enemy.x;
                        const dy = game.player.y - enemy.y;
                        const distToPlayer = Math.sqrt(dx * dx + dy * dy);

                        // プレイヤーとの距離が近すぎる場合は離れる
                        if (distToPlayer <= 2) {
                            enemy.x -= Math.sign(dx);
                            enemy.y -= Math.sign(dy);

                            // 回避時のエフェクト
                            if (Math.random() > 0.7) {
                                game.effects.push({
                                    type: 'evade_trail',
                                    x: enemy.x,
                                    y: enemy.y,
                                    duration: 2,
                                    symbol: '←',
                                    color: '#ff66ff',
                                    opacity: 0.6
                                });
                            }
                        }
                        // 遠すぎる場合は近づく
                        else if (distToPlayer > enemy.circleRadius * 2) {
                            enemy.x += Math.sign(dx);
                            enemy.y += Math.sign(dy);
                        }
                        // 適正距離の場合は円運動
                        else {
                            enemy.circlePhase += enemy.circleSpeed;
                            const circleX = game.player.x + Math.cos(enemy.circlePhase) * enemy.circleRadius;
                            const circleY = game.player.y + Math.sin(enemy.circlePhase) * enemy.circleRadius;

                            const moveX = circleX - enemy.x;
                            const moveY = circleY - enemy.y;

                            enemy.x += Math.sign(moveX);
                            enemy.y += Math.sign(moveY);

                            // 円運動のエフェクト
                            if (Math.random() > 0.7) {
                                game.effects.push({
                                    type: 'circular_trail',
                                    x: enemy.x,
                                    y: enemy.y,
                                    duration: 3,
                                    symbol: ['○', '∘', '●'][Math.floor(Math.random() * 3)],
                                    color: '#cc66ff',
                                    opacity: 0.7
                                });
                            }
                        }
                    },

                    ambush: (enemy, game) => {
                        const dx = game.player.x - enemy.x;
                        const dy = game.player.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < 5) {
                            // 近距離: 急速接近
                            if (Math.random() > 0.5) {
                                enemy.x += Math.sign(dx);
                                enemy.y += Math.sign(dy);
                            }
                        } else {
                            // 遠距離: 待ち伏せ位置を取る
                            if (Math.random() > 0.7) {
                                enemy.x += Math.sign(dx);
                                enemy.y += Math.sign(dy);
                            }
                        }
                    }
                };

                this.enemyAbilities = {
                    split: {
                        name: 'split',
                        cooldown: 50,
                        execute: (enemy, game) => {
                            // すでに分裂済みの場合は何もしない
                            if (enemy.hasSplit) return;

                            // HPが50%以下になった時のみ分裂
                            if (enemy.health <= enemy.maxHealth * 0.5) {
                                //console.log('Split ability triggered:', enemy);
                                enemy.hasSplit = true;

                                // 分裂する方向（8方向から2つをランダムに選択）
                                const directions = [
                                    { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                                    { x: -1, y: 0 }, { x: 1, y: 0 },
                                    { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
                                ];

                                // ランダムに2つの異なる方向を選択
                                const selectedDirs = game.shuffleArray([...directions]).slice(0, 2);

                                // 2体に分裂
                                selectedDirs.forEach((dir) => {
                                    // 子敵を生成する際にタイプを明示的に設定
                                    const newEnemy = game.createEnemy(enemy.x, enemy.y, enemy.tier - 1);
                                    if (newEnemy) {
                                        // 重要: 親の敵のタイプを引き継ぐ
                                        newEnemy.type = enemy.type;
                                        // 子の体力は親の最大HPの60%
                                        newEnemy.health = Math.floor(enemy.maxHealth * 0.6);
                                        newEnemy.maxHealth = newEnemy.health;
                                        newEnemy.hasSplit = true;  // これ以上分裂しないようにフラグを設定

                                        // 分裂後の位置を設定
                                        newEnemy.x = Math.max(0, Math.min(game.width - 1, enemy.x + dir.x));
                                        newEnemy.y = Math.max(0, Math.min(game.height - 1, enemy.y + dir.y));

                                        game.enemies.push(newEnemy);
                                    }
                                });

                                // 分裂エフェクトを追加
                                game.effects.push({
                                    type: 'split',
                                    x: enemy.x,
                                    y: enemy.y,
                                    duration: 10,
                                    currentFrame: 0,
                                    frames: [
                                        ['◇', '◆'],
                                        ['※', '◈'],
                                        ['★', '☆']
                                    ],
                                    colors: ['#ff33cc', '#ff0099', '#cc0066']
                                });

                                // 親の敵を消滅させる
                                enemy.health = 0;
                            }
                        }
                    },

                    heal: {
                        name: 'heal',
                        cooldown: 40,
                        execute: (enemy, game) => {
                            // 回復範囲の設定
                            const healRadius = 3;
                            let shouldHeal = false;
                            let nearbyAlliesNeedHealing = false;

                            // 自身または周囲の味方のHP状態をチェック
                            const nearbyEnemies = game.enemies.filter(other => {
                                if (other === enemy) return false;
                                const dx = other.x - enemy.x;
                                const dy = other.y - enemy.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                return distance <= healRadius;
                            });

                            // 自身のHP確認
                            if (enemy.health <= enemy.maxHealth * 0.75) {
                                shouldHeal = true;
                            }

                            // 周囲の味方のHP確認
                            nearbyAlliesNeedHealing = nearbyEnemies.some(ally =>
                                ally.health <= ally.maxHealth * 0.75
                            );

                            // 回復判定
                            if (shouldHeal || nearbyAlliesNeedHealing) {
                                const healthPercentage = enemy.health / enemy.maxHealth;
                                const baseHealChance = 0.4;
                                const criticalHealChance = Math.max(0, 1 - healthPercentage);
                                const allyBonus = nearbyAlliesNeedHealing ? 0.2 : 0; // 味方が瀕死の場合、発動確率上昇

                                if (Math.random() < (baseHealChance + criticalHealChance + allyBonus)) {
                                    // 回復実行
                                    const performHeal = (target) => {
                                        const healAmount = Math.floor(target.maxHealth * 0.4);
                                        const oldHealth = target.health;
                                        target.health = Math.min(target.maxHealth, target.health + healAmount);
                                        return target.health - oldHealth;
                                    };

                                    // 自身の回復
                                    const selfHealAmount = performHeal(enemy);

                                    // メイン回復エフェクト（回復実行者）
                                    if (selfHealAmount > 0) {
                                        // 中央の回復エフェクト
                                        game.effects.push({
                                            type: 'heal',
                                            x: enemy.x,
                                            y: enemy.y,
                                            duration: 8,
                                            currentFrame: 0,
                                            frames: [
                                                ['♥'],
                                                ['❤'],
                                                ['♥', '❤'],
                                                ['❤', '♥']
                                            ],
                                            colors: ['#00ff99', '#00cc66', '#009933'],
                                            expandingSymbols: [
                                                ['╋'],
                                                ['╉', '╊'],
                                                ['┿'],
                                                ['╇', '╈']
                                            ],
                                            radius: healRadius
                                        });

                                        // 回復量表示
                                        game.addDamagePopup(enemy.x, enemy.y, selfHealAmount, {
                                            color: '#00ff00',
                                            scale: 1.2,
                                            text: `+${selfHealAmount}`,
                                            style: `
                            color: #00ff00;
                            text-shadow: 0 0 10px #00ff00,
                                        0 0 15px #00ff00,
                                        0 0 20px #00ff00;
                            font-weight: bold;
                        `
                                        });
                                    }

                                    // 範囲回復の波動エフェクト
                                    for (let r = 0; r <= healRadius; r++) {
                                        const circlePoints = 8 * r; // 半径に応じてポイント数を増やす
                                        if (circlePoints > 0) {
                                            for (let i = 0; i < circlePoints; i++) {
                                                const angle = (2 * Math.PI * i) / circlePoints;
                                                const effectX = Math.round(enemy.x + Math.cos(angle) * r);
                                                const effectY = Math.round(enemy.y + Math.sin(angle) * r);

                                                game.effects.push({
                                                    type: 'heal_wave',
                                                    x: effectX,
                                                    y: effectY,
                                                    duration: 5,
                                                    symbol: ['∷', '∴', '∵'][Math.floor(Math.random() * 3)],
                                                    color: '#00ff99',
                                                    opacity: 1 - (r / (healRadius + 1))
                                                });
                                            }
                                        }
                                    }

                                    // 周囲の味方の回復
                                    nearbyEnemies.forEach(ally => {
                                        const healAmount = performHeal(ally);
                                        if (healAmount > 0) {
                                            // 回復エフェクト（周囲の味方）
                                            game.effects.push({
                                                type: 'heal_ally',
                                                x: ally.x,
                                                y: ally.y,
                                                duration: 5,
                                                frames: [['✚'], ['╋'], ['✚']],
                                                colors: ['#44ff88', '#22dd66', '#00bb44'],
                                                currentFrame: 0
                                            });

                                            // 回復量表示（数値を小さめに）
                                            game.addDamagePopup(ally.x, ally.y, healAmount, {
                                                color: '#00ff00',
                                                scale: 0.8,
                                                text: `+${healAmount}`,
                                                style: `
                                color: #00ff00;
                                text-shadow: 0 0 8px #00ff00;
                                font-weight: bold;
                            `
                                            });

                                            // 周囲の味方への回復接続線
                                            const dx = ally.x - enemy.x;
                                            const dy = ally.y - enemy.y;
                                            const distance = Math.sqrt(dx * dx + dy * dy);
                                            const steps = Math.ceil(distance);

                                            for (let i = 1; i < steps; i++) {
                                                const ratio = i / steps;
                                                const connectX = Math.round(enemy.x + dx * ratio);
                                                const connectY = Math.round(enemy.y + dy * ratio);

                                                game.effects.push({
                                                    type: 'heal_connection',
                                                    x: connectX,
                                                    y: connectY,
                                                    duration: 3,
                                                    symbol: ['∙', '·', '⋅'][Math.floor(Math.random() * 3)],
                                                    color: '#00ff99',
                                                    opacity: 0.6
                                                });
                                            }
                                        }
                                    });

                                    // 回復後の防御バフエフェクト（全体）
                                    const buffTargets = [enemy, ...nearbyEnemies];
                                    buffTargets.forEach(target => {
                                        game.effects.push({
                                            type: 'heal_shield',
                                            x: target.x,
                                            y: target.y,
                                            duration: 5,
                                            symbol: '◎',
                                            color: '#88ffaa',
                                            opacity: 0.7
                                        });
                                    });
                                }
                            }
                        }
                    },

                    areaAttack: {
                        name: 'areaAttack',
                        cooldown: 30,
                        execute: (enemy, game) => {
                            const radius = 2;
                            const distToPlayer = Math.sqrt(
                                Math.pow(game.player.x - enemy.x, 2) +
                                Math.pow(game.player.y - enemy.y, 2)
                            );

                            // プレイヤーが範囲内にいる場合のみ発動
                            if (distToPlayer <= radius) {
                                // 警告エフェクトを追加（攻撃前の予告）
                                game.effects.push({
                                    type: 'area_attack_warning',
                                    x: enemy.x,
                                    y: enemy.y,
                                    duration: 5,
                                    currentFrame: 0,
                                    radius: radius,
                                    frames: [
                                        ['!', '¡'],
                                        ['¡', '!'],
                                        ['!', '¡']
                                    ],
                                    color: '#ff6666'
                                });

                                // 少し遅延して実際の攻撃を実行
                                setTimeout(() => {
                                    // ダメージ計算（敵のティアに応じて増加）
                                    const baseDamage = Math.floor(enemy.damage.base * 0.8);
                                    const damageRange = baseDamage * enemy.damage.variationPercent;
                                    const finalDamage = Math.round(
                                        baseDamage + (Math.random() * 2 - 1) * damageRange
                                    );

                                    // プレイヤーが範囲内にいる場合のみダメージを与える
                                    const currentDist = Math.sqrt(
                                        Math.pow(game.player.x - enemy.x, 2) +
                                        Math.pow(game.player.y - enemy.y, 2)
                                    );

                                    if (currentDist <= radius) {
                                        game.player.health -= finalDamage;
                                        game.damageFlash = 2;

                                        // ダメージ表示
                                        game.addDamagePopup(
                                            game.player.x,
                                            game.player.y,
                                            finalDamage,
                                            {
                                                color: '#ff4444',
                                                scale: 1.2,
                                                text: `${finalDamage}!`,
                                                style: `
                                color: #ff4444;
                                text-shadow: 0 0 10px #ff0000,
                                            0 0 20px #ff0000;
                                font-weight: bold;
                            `
                                            }
                                        );
                                    }

                                    // 攻撃エフェクト
                                    game.effects.push({
                                        type: 'area_attack',
                                        x: enemy.x,
                                        y: enemy.y,
                                        radius: radius,
                                        currentFrame: 0,
                                        duration: 10,
                                        frames: [
                                            ['◈', '◇', '◆'],
                                            ['◆', '◈', '◇', '◆'],
                                            ['◇', '◆', '◈', '◇', '◆']
                                        ],
                                        colors: ['#ff6666', '#ff4444', '#ff0000'],
                                        glowIntensity: [20, 15, 10],
                                        expandingSymbols: [
                                            ['→', '←', '↑', '↓'],
                                            ['↗', '↘', '↙', '↖'],
                                            ['◇', '◆', '◈']
                                        ]
                                    });

                                    // 地面に残る効果
                                    for (let i = 0; i < 8; i++) {
                                        const angle = (Math.PI * 2 * i) / 8;
                                        for (let r = 1; r <= radius; r++) {
                                            const effectX = Math.round(enemy.x + Math.cos(angle) * r);
                                            const effectY = Math.round(enemy.y + Math.sin(angle) * r);
                                            game.effects.push({
                                                type: 'area_attack_ground',
                                                x: effectX,
                                                y: effectY,
                                                duration: 5,
                                                symbol: ['░', '▒', '▓'][Math.floor(Math.random() * 3)],
                                                color: '#ff4444',
                                                opacity: 0.7 - (r / (radius + 1) * 0.5)
                                            });
                                        }
                                    }
                                }, 500); // 0.5秒の警告時間
                            }
                        }
                    },

                    dash: {
                        name: 'dash',
                        cooldown: 20,
                        execute: (enemy, game) => {
                            const dx = game.player.x - enemy.x;
                            const dy = game.player.y - enemy.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            // ダッシュ判定の条件を調整
                            const shouldDash = (
                                dist >= 4 && dist <= 8 ||  // 通常の攻撃範囲
                                (enemy.health <= enemy.maxHealth * 0.3 && dist <= 3) // HP30%以下で近すぎる場合は逃走
                            );

                            if (shouldDash) {
                                const startX = enemy.x;
                                const startY = enemy.y;

                                let targetX, targetY;
                                if (enemy.health <= enemy.maxHealth * 0.3 && dist < 3) {
                                    // 逃走時は反対方向へ（距離を少し短く）
                                    targetX = enemy.x - (dx / dist * 3);
                                    targetY = enemy.y - (dy / dist * 3);
                                } else {
                                    // 通常時はプレイヤーへ
                                    targetX = game.player.x;
                                    targetY = game.player.y;
                                }

                                const dashDist = Math.sqrt(
                                    Math.pow(targetX - enemy.x, 2) +
                                    Math.pow(targetY - enemy.y, 2)
                                );

                                if (dashDist > 0) {
                                    const dashDistance = 4;  // ダッシュ距離を短めに調整
                                    const moveX = (targetX - enemy.x) / dashDist * dashDistance;
                                    const moveY = (targetY - enemy.y) / dashDist * dashDistance;

                                    // パス上の衝突判定と予告エフェクト
                                    const steps = Math.ceil(dashDistance);
                                    let collided = false;
                                    let finalX = enemy.x;
                                    let finalY = enemy.y;

                                    // ダッシュ予告エフェクトを追加
                                    if (!enemy.dashWarning) {
                                        // 最終目標地点を計算
                                        finalX = Math.max(0, Math.min(game.width - 1, enemy.x + Math.round(moveX)));
                                        finalY = Math.max(0, Math.min(game.height - 1, enemy.y + Math.round(moveY)));

                                        // メイン警告エフェクト
                                        game.effects.push({
                                            type: 'dash_warning',
                                            x: enemy.x,
                                            y: enemy.y,
                                            targetX: finalX,
                                            targetY: finalY,
                                            duration: 5,
                                            currentFrame: 0,
                                            frames: ['!', '¡', '!'],
                                            color: '#ff6666',
                                            enemy: enemy
                                        });

                                        // パス上の予告マーカー
                                        for (let i = 1; i <= steps; i++) {
                                            const progressX = Math.round(enemy.x + (moveX * i / steps));
                                            const progressY = Math.round(enemy.y + (moveY * i / steps));

                                            // パスの予告エフェクト
                                            game.effects.push({
                                                type: 'dash_path_warning',
                                                x: progressX,
                                                y: progressY,
                                                duration: 5,
                                                currentFrame: 0,
                                                frames: ['·', ':', '·'],
                                                color: '#ff4444',
                                                opacity: 1 - (i / steps) * 0.5
                                            });
                                        }

                                        enemy.dashWarning = true;
                                        enemy.dashDelay = 5; // 予告から実際のダッシュまでの遅延

                                        // 実際のダッシュ処理を遅延実行
                                        setTimeout(() => {
                                            enemy.dashWarning = false;

                                            // 衝突判定とダメージ処理
                                            for (let i = 1; i <= steps; i++) {
                                                const checkX = Math.round(enemy.x + (moveX * i / steps));
                                                const checkY = Math.round(enemy.y + (moveY * i / steps));

                                                const playerDx = game.player.x - checkX;
                                                const playerDy = game.player.y - checkY;
                                                const collisionDist = Math.sqrt(playerDx * playerDx + playerDy * playerDy);

                                                if (collisionDist <= 0.8) {
                                                    collided = true;
                                                    const damageRange = enemy.damage.base * enemy.damage.variationPercent;
                                                    const baseDamage = enemy.damage.base + (Math.random() * 2 - 1) * damageRange;
                                                    const dashDamageMultiplier = 1.5;
                                                    const finalDamage = Math.round(baseDamage * (1 + (enemy.tier || 0) * 0.2) * dashDamageMultiplier);

                                                    game.player.health -= finalDamage;
                                                    game.damageFlash = 2;

                                                    // ダメージ表示
                                                    game.addDamagePopup(
                                                        game.player.x,
                                                        game.player.y,
                                                        finalDamage,
                                                        {
                                                            color: '#ff4444',
                                                            scale: 1.2,
                                                            text: `${finalDamage}!`
                                                        }
                                                    );

                                                    // 衝突エフェクト
                                                    game.effects.push({
                                                        type: 'collision',
                                                        x: checkX,
                                                        y: checkY,
                                                        duration: 5,
                                                        frames: [
                                                            ['◈', '◇'],
                                                            ['◆', '◈'],
                                                            ['◇', '◆']
                                                        ],
                                                        currentFrame: 0,
                                                        color: '#ff4444'
                                                    });

                                                    break;
                                                }
                                            }

                                            // 最終位置の決定と移動
                                            const finalPosition = {
                                                x: collided ? enemy.x : Math.max(0, Math.min(game.width - 1, finalX)),
                                                y: collided ? enemy.y : Math.max(0, Math.min(game.height - 1, finalY))
                                            };

                                            // ダッシュエフェクトの追加
                                            game.addDashEffects(enemy, startX, startY, finalPosition.x, finalPosition.y, dashDistance);

                                            // 敵の位置を更新
                                            enemy.x = finalPosition.x;
                                            enemy.y = finalPosition.y;

                                        }, enemy.dashDelay * 100); // フレーム数から適切なミリ秒に変換
                                    }
                                }
                            }
                        }
                    }
                };

                // ゲーム状態の初期化
                this.gameState = 'title';  // 最初はタイトル画面から
                this.gameStarted = false;
                this.upgradeSystem = new UpgradeSystem(this);
                this.enemies = [];
                this.projectiles = [];
                this.activeProjectiles = [];
                this.gems = [];
                this.gameTime = 0;
                this.score = 0;
                this.moveCounter = 0;
                this.damagedEnemies = [];
                this.effects = [];
                this.damageFlash = 0;
                this.explosions = [];
                this.damagePopups = [];
                this.isPlayerTurn = true;
                this.needsUpdate = false;

                // DOMエレメントの取得
                this.display = document.getElementById('game');
                this.statsDisplay = document.getElementById('stats');

                // ウィンドウを閉じる際のautosave
                window.addEventListener('beforeunload', () => {
                    if (this.gameStarted && this.gameState !== 'title') {
                        this.saveGame();
                    }
                });

                // イベントリスナーの設定
                document.addEventListener('keydown', this.handleInput.bind(this));


                // 背景グリッドの初期化// 背景用の配列とカウンターを追加
                this.backgroundGrid = [];
                this.backgroundUpdateCounter = 0;

                // 背景グリッドの初期化
                this.initializeBackgroundGrid();

                // セーブデータの読み込み
                this.loadGame();

                // 自動セーブの設定（30秒ごと）
                setInterval(() => {
                    if (this.gameStarted) {
                        this.saveGame();
                    }
                }, 10000);

                // メインゲームループ
                setInterval(() => {
                    if (this.gameStarted) {
                        if (this.player.moveDelay > 0) {
                            this.player.moveDelay--;
                            if (this.player.moveDelay === 0) {
                                this.isPlayerTurn = true;
                            }
                        }
                        this.update();
                    }
                    this.render();
                }, 100);
                // リサイズイベントリスナーの追加
                window.addEventListener('resize', () => {
                    this.calculateViewportSize();
                    this.updatePopupContainer();
                });
            }

            initializeBackgroundGrid() {
                const backgroundSymbols = [' ', ' ', ' ', ' ', ' ', '.', '^', '~'];
                this.backgroundGrid = Array(this.height).fill().map(() =>
                    Array(this.width).fill().map(() =>
                        backgroundSymbols[Math.floor(Math.random() * backgroundSymbols.length)]
                    )
                );
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            calculateViewportSize() {
                const container = document.querySelector('.game-area');
                if (!container) return;

                // コンテナのパディングを考慮
                const padding = 20;
                const availableWidth = container.clientWidth - (padding * 2);
                const availableHeight = container.clientHeight - (padding * 2);

                // フォントサイズの自動調整（オプション）
                const widthRatio = availableWidth / (this.width * this.cellWidth);
                const heightRatio = availableHeight / (this.height * this.cellHeight);
                const scale = Math.min(widthRatio, heightRatio, 1);

                // ゲーム表示要素のスタイル更新
                const gameElement = document.getElementById('game');
                if (gameElement) {
                    gameElement.style.transform = `scale(${scale})`;
                    gameElement.style.transformOrigin = 'top left';
                }
            }

            handlePlayerDeath() {
                this.gameState = 'gameover';
                this.gameStarted = false;
                this.inputEnabled = true;  // 死亡時も入力を有効化

                // 専用のゲームオーバーコンテナを作成
                const gameOverContainer = document.createElement('div');
                gameOverContainer.id = 'game-over-container';
                gameOverContainer.style.position = 'absolute';
                gameOverContainer.style.top = '0';
                gameOverContainer.style.left = '0';
                gameOverContainer.style.width = '100%';
                gameOverContainer.style.height = '100%';
                gameOverContainer.style.display = 'flex';
                gameOverContainer.style.justifyContent = 'center';
                gameOverContainer.style.alignItems = 'center';
                gameOverContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                gameOverContainer.style.zIndex = '1000';

                const display = [
                    "",
                    "GAME OVER",
                    "",
                    `Score: ${this.formatNumber(this.score).padStart(10)}`,
                    `Time Survived: ${this.formatTime(this.gameTime)}`,
                    "",
                    `Wave Reached: ${(Math.floor(this.gameTime / 300) + 1).toString().padStart(2)}`,
                    `Enemies Defeated: ${Math.floor(this.score / 100).toString().padStart(3)}`,
                    "",
                    "Press SPACE to Title Screen",
                    "",
                    ""
                ].join('\n');

                const preElement = document.createElement('pre');
                preElement.className = 'game-over-screen';
                preElement.style.backgroundColor = 'rgba(24, 24, 24, 0.95)';
                preElement.style.padding = '2em';
                preElement.style.borderRadius = '8px';
                preElement.style.color = '#ff4444';
                preElement.style.textShadow = '0 0 10px #ff0000';
                preElement.innerHTML = display;

                // 既存のゲームオーバー画面があれば削除
                const existingGameOver = document.getElementById('game-over-container');
                if (existingGameOver) {
                    existingGameOver.remove();
                }

                // weapon-select を非表示に
                const weaponSelect = document.getElementById('weapon-select');
                if (weaponSelect) {
                    weaponSelect.style.display = 'none';
                }

                gameOverContainer.appendChild(preElement);
                document.querySelector('.game-area').appendChild(gameOverContainer);

                // セーブデータを削除
                this.clearSaveData();

                // gameStateがgameoverの時のキー入力処理を追加
                const handleGameOverInput = (event) => {
                    if (event.code === 'Space') {
                        document.removeEventListener('keydown', handleGameOverInput);
                        gameOverContainer.remove();
                        this.resetGame();
                        this.gameState = 'title';
                        this.showTitle();
                    }
                };
                // 新しいイベントリスナーを追加
                document.addEventListener('keydown', handleGameOverInput);
            }

            // 数値フォーマット用のヘルパーメソッド
            formatNumber(num) {
                return num.toString().padStart(7);
            }

            // 時間フォーマット用のヘルパーメソッド
            formatTime(frames) {
                const seconds = Math.floor(frames / 10);
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
            }

            showTitle() {
                const weaponSelect = document.getElementById('weapon-select');
                weaponSelect.style.display = 'flex';
                const titleArt = [
                    "███████ ██    ██ ██████  ██    ██ ██ ██    ██  ██████  ██████  ███████",
                    "██      ██    ██ ██   ██ ██    ██ ██ ██    ██ ██    ██ ██   ██ ██     ",
                    "███████ ██    ██ ██████  ██    ██ ██ ██    ██ ██    ██ ██████  ███████",
                    "     ██ ██    ██ ██   ██  ██  ██  ██  ██  ██  ██    ██ ██   ██      ██",
                    "███████  ██████  ██   ██   ████   ██   ████    ██████  ██   ██ ███████",
                    "",
                    "       ██████   ████  ███     ███ ██████  ██      ███████ ██    ██",
                    "       ██     ██    ██ ████  ████ ██   ██ ██      ██       ██ ██ ",
                    "       ██     ██    ██ ██ ████ ██ ██████  ██      █████     ███  ",
                    "       ██     ██    ██ ██  ██  ██ ██      ██      ██       ██ ██ ",
                    "       ██████   ████  ██       ██ ██      ███████ █████████     ██",
                    "",
                    "",
                    "                          Press SPACE to Start                    ",
                    "",
                    "                       [←↑↓→] or [HJKL] to Move",
                    "                     [YUBN] for Diagonal Movement",
                    "                             [.] to Wait",
                    "                             [;] to Look",
                    "                          [p] to Use Portal",
                    "                         [ctl + Q] to Reset Game",
                    ""
                ].join('\n');

                const preElement = document.createElement('pre');
                preElement.className = 'weapon-select';
                preElement.style.backgroundColor = 'rgba(24, 24, 24, 0.95)';
                preElement.style.padding = '2em';
                preElement.style.borderRadius = '8px';
                preElement.style.color = '#5e9dea';
                preElement.style.textShadow = '0 0 10px #adcaee';
                preElement.innerHTML = titleArt;

                weaponSelect.innerHTML = '';
                weaponSelect.appendChild(preElement);

                // タイトル画面のイベントハンドラー
                const handleTitleInput = (event) => {
                    if (event.code === 'Space') {
                        document.removeEventListener('keydown', handleTitleInput);

                        const titleElement = document.querySelector('.weapon-select');
                        if (!titleElement) return;

                        // アニメーション用のコンテナ
                        const asciiContainer = document.createElement('pre');
                        asciiContainer.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            color: #5e9dea;
            font-family: monospace;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            overflow: hidden;
            z-index: 1000;
        `;
                        document.querySelector('.game-area').appendChild(asciiContainer);

                        // 量子回路パターンのコンテナ
                        const circuitContainer = document.createElement('div');
                        circuitContainer.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #5e9dea;
            text-shadow: 0 0 10px #5e9dea;
            opacity: 0.3;
            pointer-events: none;
            text-align: center;
            z-index: 1;
        `;
                        asciiContainer.appendChild(circuitContainer);

                        // テキストアニメーションのコンテナ
                        const textContainer = document.createElement('div');
                        textContainer.style.cssText = `
            position: absolute;
            font-size: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.2em;
            z-index: 2;
            background: rgba(0, 0, 0, 0.4);
            padding: 1em;
            border-radius: 4px;
        `;
                        asciiContainer.appendChild(textContainer);

                        // スキャン効果のアニメーション
                        const createScanEffect = (text, delay = 0) => {
                            setTimeout(() => {
                                const scanLine = document.createElement('div');
                                scanLine.style.cssText = `
                    color: #5e9dea;
                    text-shadow: 0 0 10px #5e9dea;
                    white-space: pre;
                    height: 1.2em;
                    text-align: center;
                `;
                                textContainer.appendChild(scanLine);

                                let frame = 0;
                                const animate = () => {
                                    if (frame > text.length + 5) {
                                        return;
                                    }

                                    let line = '';
                                    for (let i = 0; i < text.length; i++) {
                                        if (i === frame || i === frame - 1) {
                                            line += '█';
                                        } else if (i < frame) {
                                            line += text[i];
                                        } else {
                                            line += ' ';
                                        }
                                    }
                                    scanLine.textContent = line;
                                    frame++;
                                    requestAnimationFrame(animate);
                                };
                                animate();
                            }, delay);
                        };

                        // 量子回路パターンのアニメーション
                        const createQuantumCircuit = () => {
                            const width = 50;
                            const height = 20;
                            const symbols = ['═', '║', '╔', '╗', '╚', '╝', '╠', '╣', '╦', '╩', '╬'];
                            let frame = 0;

                            const animate = () => {
                                if (frame > 150) {
                                    return;
                                }

                                let pattern = '';
                                for (let y = 0; y < height; y++) {
                                    let line = '';
                                    for (let x = 0; x < width; x++) {
                                        if (Math.random() < 0.15) {
                                            line += symbols[Math.floor(Math.random() * symbols.length)];
                                        } else {
                                            line += ' ';
                                        }
                                    }
                                    pattern += line + '\n';
                                }
                                circuitContainer.textContent = pattern;
                                frame++;
                                requestAnimationFrame(animate);
                            };
                            animate();
                        };

                        // システム起動メッセージ
                        const messages = [
                            "INITIALIZING SYSTEM COMPONENTS...",
                            "LOADING NEURAL INTERFACE...",
                            "CALIBRATING QUANTUM PROCESSORS...",
                            "ESTABLISHING DIMENSIONAL LINK...",
                            "SYNCING COMBAT PROTOCOLS...",
                            "ACTIVATING SURVIVOR COMPLEX..."
                        ];

                        // 量子回路を先に表示
                        createQuantumCircuit();

                        // メッセージを順次表示
                        messages.forEach((msg, i) => {
                            createScanEffect(msg, i * 400);
                        });

                        // アニメーション完了後に次の画面へ
                        setTimeout(() => {
                            asciiContainer.style.transition = 'opacity 0.5s';
                            asciiContainer.style.opacity = '0';
                            setTimeout(() => {
                                asciiContainer.remove();
                                this.gameState = 'nameInput';
                                this.playerSetup.showNameInput();
                            }, 500);
                        }, 3000);
                    }
                };
                // 新しいイベントリスナーを追加
                document.addEventListener('keydown', handleTitleInput);
            }

            // ポータル使用メソッド
            usePortal() {
                if (!this.isPortalActive) {
                    this.isPortalActive = true;
                    this.portalTimer = this.maxPortalTime;
                    this.portalPosition = { x: this.player.x, y: this.player.y };
                    this.addPortalEffect(this.player.x, this.player.y, 'open');
                }
            }

            // プレイヤーがポータル範囲内にいるかチェック
            isPlayerInPortal() {
                if (!this.portalPosition) return false;

                const dx = this.player.x - this.portalPosition.x;
                const dy = this.player.y - this.portalPosition.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                return distance <= 2;
            }

            // ポータルエフェクトの追加
            // ポータルエフェクト生成を改善
            addPortalEffect(x, y, type, customSettings = null) {
                const settings = customSettings || {
                    symbols: {
                        open: [
                            ['◎', '○', '◌'],
                            ['○', '◎', '○'],
                            ['◌', '○', '◎']
                        ],
                        close: [
                            ['◎', '○', '◌'],
                            ['○', '◌', '○'],
                            ['◌', '○', '◎']
                        ]
                    },
                    colors: ['#4488ff', '#44aaff', '#44ddff']
                };

                const portalSymbols = settings.symbols;
                const portalColors = settings.colors;

                this.portalEffects.push({
                    x: x,
                    y: y,
                    type: type,
                    duration: 15,
                    currentFrame: 0,
                    radius: 2,
                    rotationAngle: 0,
                    symbols: settings.symbols,
                    colors: settings.colors
                });
            }

            // ホーム画面表示
            showHome() {
                const weaponSelect = document.getElementById('weapon-select');
                weaponSelect.style.display = 'flex';

                const homeScreen = [
                    "",
                    "      === HOME BASE ===",
                    "",
                    "      Current Status:",
                    `      Level: ${this.player.level}`,
                    `      Experience: ${this.player.exp}/${this.player.expToLevel}`,
                    `      HP: ${Math.round(this.player.health)}/${this.player.maxHealth}`,
                    `      Max Health: ${this.player.maxHealth}`,
                    "",
                    "      Active Weapons:",
                    ...Object.entries(this.weapons)
                        .filter(([_, weapon]) => weapon.active)
                        .map(([type, _]) => `      • ${this.availableWeapons[type].name}`),
                    "",
                    "      [SPACE] Return to Field",
                    "      [E] Equipment (Coming Soon)",
                    "      [U] Upgrades (Coming Soon)",
                    ""
                ].join('\n');

                const preElement = document.createElement('pre');
                preElement.className = 'weapon-select';
                preElement.style.backgroundColor = 'rgba(24, 24, 24, 0.95)';
                preElement.style.padding = '2em';
                preElement.style.borderRadius = '8px';
                preElement.style.color = '#5e9dea';
                preElement.innerHTML = homeScreen;

                weaponSelect.innerHTML = '';
                weaponSelect.appendChild(preElement);

                // ホーム画面用のイベントリスナー設定
                const handleHomeInput = (event) => {
                    if (event.code === 'Space') {
                        document.removeEventListener('keydown', handleHomeInput);
                        this.returnToField();
                    }
                };
                document.addEventListener('keydown', handleHomeInput);
            }

            returnToField() {
                this.gameState = 'playing';
                this.gameStarted = true;
                this.gameTime = 0;

                // エフェクトをクリーンアップ
                this.portalEffects = [];
                this.effects = this.effects.filter(e => e.type !== 'portal_particle');
                this.portalPosition = null;
                this.isPortalActive = false;

                // 敵をクリーンアップ
                this.enemies = [];

                // 危険度を再抽選（1-5の範囲）
                this.dangerLevel = Math.floor(Math.random() * 5) + 1;

                // 新しい敵を生成
                const initialEnemies = Math.floor(3 + (this.dangerLevel * 2));
                for (let i = 0; i < initialEnemies; i++) {
                    this.spawnEnemy();
                }

                document.getElementById('weapon-select').style.display = 'none';
                this.addPortalEffect(this.player.x, this.player.y, 'open');
            }

            showWeaponSelection() {
                const weaponTypes = ['orbit', 'laser', 'missile', 'motorgun'];

                let display = [
                    "",
                    "                  === WEAPON SELECT ===",
                    "      Choose your primary weapon to defend the complex",
                    ""
                ];

                // 各武器の情報を追加
                weaponTypes.forEach((type, index) => {
                    const weapon = this.availableWeapons[type];
                    if (!weapon) {
                        console.error(`Weapon type ${type} not found in availableWeapons`);
                        return;
                    }

                    display.push(`      [${index + 1}] ${weapon.name}`);
                    weapon.ascii.forEach(line => {
                        display.push(`          ${line}`);
                    });
                    display.push(`          ${weapon.description}`);
                    display.push("");
                });

                display.push("      Press 1-4 to select your weapon");
                display.push("");

                // 表示を更新
                const weaponSelect = document.getElementById('weapon-select');
                weaponSelect.innerHTML = '';
                weaponSelect.style.display = 'flex';
                weaponSelect.style.justifyContent = 'center';
                weaponSelect.style.alignItems = 'center';
                weaponSelect.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';

                const preElement = document.createElement('pre');
                preElement.className = 'weapon-select';
                preElement.style.backgroundColor = 'rgb(24, 24, 24)';
                preElement.style.padding = '2em';
                preElement.style.borderRadius = '8px';
                preElement.style.maxWidth = '90%';
                preElement.style.maxHeight = '90%';
                preElement.style.overflow = 'auto';
                preElement.innerHTML = display.join('\n');

                weaponSelect.appendChild(preElement);
            }

            handleWeaponSelection(key) {
                let selectedWeapon = null;

                switch (key) {
                    case '1':
                        selectedWeapon = 'orbit';
                        break;
                    case '2':
                        selectedWeapon = 'laser';
                        break;
                    case '3':
                        selectedWeapon = 'missile';
                        break;
                    case '4':
                        selectedWeapon = 'motorgun';
                        break;
                    default:
                        return;
                }

                if (selectedWeapon) {
                    const weaponSelect = document.getElementById('weapon-select');
                    weaponSelect.style.display = 'none';
                    weaponSelect.innerHTML = '';

                    this.gameState = 'playing';
                    this.gameStarted = true;

                    // 武器の初期化を改善
                    this.weapons = {
                        orbit: {
                            ...this.availableWeapons.orbit,
                            active: selectedWeapon === 'orbit',
                            angle: 0,
                            radius: 3,
                            projectiles: 1,
                            damageRadius: 1,
                            splashCooldown: 0,
                            maxSplashCooldown: 5,
                            splashDuration: 3,
                            splashActive: false,
                            damage: {
                                base: 5,
                                variationPercent: 0.35
                            },
                            splashDamage: {
                                base: 2,
                                variationPercent: 0.30
                            }
                        },
                        laser: {
                            ...this.availableWeapons.laser,
                            active: selectedWeapon === 'laser',
                            cooldown: 0,
                            maxCooldown: 15,
                            range: 10,
                            damage: {
                                base: 2,
                                variationPercent: 0.40
                            },
                            duration: 3,
                            spreadLevel: 1,
                            maxSpreadLevel: 6,
                            spreadWidth: 0.1,
                            width: 1
                        },
                        missile: {
                            ...this.availableWeapons.missile,
                            active: selectedWeapon === 'missile',
                            cooldown: 0,
                            maxCooldown: 15,
                            projectiles: 1,
                            maxProjectiles: 6,
                            damage: {
                                base: 7,
                                variationPercent: 0.35
                            },
                            splashDamage: {
                                base: 3,
                                variationPercent: 0.30
                            },
                            splashRadius: 2,
                            speed: 0.5,
                            splashDuration: 3
                        },
                        motorgun: {
                            ...this.availableWeapons.motorgun,
                            active: selectedWeapon === 'motorgun',
                            cooldown: 0,
                            stabilizationTime: 0,
                            damage: {
                                base: 3,
                                variationPercent: 0.25
                            },
                            fireRate: 2,              // 基本発射レート（通常時）
                            maxFireRate: 4,           // 待機時の最大発射レート
                            spread: 0.3,              // 基本散布界
                            minSpread: 0.15,          // 最小散布界（待機時）
                            maxSpread: 0.5,           // 最大散布界（移動時）
                            projectileSpeed: 0.8,     // 弾速
                            maxCooldown: 3,           // 連射間隔
                            range: 12,                // 射程距離
                            maxStabilization: 30,     // 最大待機時間
                            ammo: 30,                 // 弾薬数
                            maxAmmo: 30,              // 最大弾薬数
                            reloadTime: 30,           // リロード時間（フレーム数）
                            reloadCooldown: 0,        // リロードクールダウン
                            waitBonus: 1.5           // 待機時の発射レートボーナス
                        }
                    };

                    // デバッグログ追加
                    //console.log('Initialized weapons:', this.weapons);
                    // console.log('Selected weapon:', selectedWeapon);

                    // ゲーム開始処理
                    this.gameStarted = true;
                    this.gameTime = 0;
                    this.score = 0;
                    this.enemies = [];
                    this.projectiles = [];
                    this.activeProjectiles = [];
                    this.gems = [];
                    this.isPlayerTurn = true;

                    // 最初の敵を生成
                    this.spawnEnemy();
                }
            }

            async levelUp() {
                // console.log('Level Up called. Current level:', this.player.level);
                // console.log('Current stats:', {
                //     ATK: this.player.stats.ATK,
                //     DEF: this.player.stats.DEF,
                //     SPD: this.player.stats.SPD
                //});

                // レベルアップ前の状態を保存
                this.saveGame();

                // 入力を一時的に無効化
                this.inputEnabled = false;

                const maxLevel = 50;
                if (this.player.level >= maxLevel) {
                    this.player.exp = this.player.expToLevel;
                    this.inputEnabled = true;
                    return;
                }

                this.player.level++;

                // HP増加の計算を調整
                const minIncrease = 0.05;  // 5%
                const maxIncrease = 0.10;  // 10%
                const defBonus = this.player.stats.DEF * 0.003; // 0.3%/DEF

                // 成長の計算方法を改善
                let hpIncreaseRate = minIncrease + (Math.random() * (maxIncrease - minIncrease));

                // DEFボーナスを加算（上限付き）
                hpIncreaseRate += Math.min(defBonus, 0.05); // DEFボーナスの上限を5%に

                // レベルが高くなるほど成長率が緩やかになる
                const levelFactor = Math.max(0.5, 1 - (this.player.level * 0.01)); // レベルごとに1%ずつ減少（最低50%まで）
                hpIncreaseRate *= levelFactor;

                // HP増加量の計算
                const oldMaxHP = this.player.maxHealth;
                const increase = Math.max(1, Math.floor(oldMaxHP * hpIncreaseRate)); // 最低1は増加
                this.player.maxHealth = oldMaxHP + increase;

                // 回復量も調整
                const healPercentage = 0.2; // 20%
                const healAmount = Math.floor(this.player.maxHealth * healPercentage);
                const oldHealth = this.player.health;
                this.player.health = Math.min(this.player.maxHealth, oldHealth + healAmount);

                // 次のレベルアップに必要な経験値を設定
                const oldExpToLevel = this.player.expToLevel;
                this.player.expToLevel = Math.floor(oldExpToLevel * 1.5);

                // レベルアップ後の状態を保存
                this.saveGame();

                // エフェクトの再生を待機
                await this.playLevelUpSequence(increase);

                // アップグレード選択画面を表示する前に少し待機
                await new Promise(resolve => setTimeout(resolve, 500));

                // アップグレード選択画面を表示
                this.upgradeSystem.showUpgradeSelection();

                // 入力を再度有効化（アップグレード選択用）
                this.inputEnabled = true;
            }

            async playLevelUpSequence(hpIncrease, statGrowth) { // 引数名を修正
                return new Promise(resolve => {
                    // 時間制御用の変数
                    let frame = 0;
                    const totalFrames = 30;
                    const effectRadius = 8;

                    // エフェクト用の一時的な配列
                    const levelUpEffects = [];

                    // 敵のノックバック処理
                    this.enemies.forEach(enemy => {
                        const dx = enemy.x - this.player.x;
                        const dy = enemy.y - this.player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < effectRadius * 1.5) {
                            const angle = Math.atan2(dy, dx);
                            const knockbackForce = (effectRadius * 1.5 - distance) * 0.5;

                            // 敵の新しい位置を計算（境界チェック付き）
                            const newX = Math.max(0, Math.min(this.width - 1,
                                enemy.x + Math.round(Math.cos(angle) * knockbackForce)));
                            const newY = Math.max(0, Math.min(this.height - 1,
                                enemy.y + Math.round(Math.sin(angle) * knockbackForce)));

                            // ノックバックの軌跡エフェクトを追加
                            const steps = Math.ceil(knockbackForce);
                            for (let i = 0; i < steps; i++) {
                                const ratio = i / steps;
                                const effectX = Math.round(enemy.x + (newX - enemy.x) * ratio);
                                const effectY = Math.round(enemy.y + (newY - enemy.y) * ratio);
                                this.effects.push({
                                    type: 'knockback_trail',
                                    x: effectX,
                                    y: effectY,
                                    duration: 5,
                                    symbol: '∴',
                                    opacity: 0.7 - (ratio * 0.5)
                                });
                            }

                            // 敵の位置を更新
                            enemy.x = newX;
                            enemy.y = newY;
                        }
                    });

                    // レベルアップアニメーションの実行
                    const animationInterval = setInterval(() => {
                        // 既存のレベルアップエフェクトをクリア
                        this.effects = this.effects.filter(effect => effect.type !== 'levelup');

                        // 中心の光柱エフェクト
                        this.effects.push({
                            type: 'levelup',
                            x: this.player.x,
                            y: this.player.y,
                            duration: 5,
                            frame: frame,
                            symbol: '║',
                            color: '#00ffff',
                            intensity: 1 - (frame / totalFrames)
                        });

                        // 拡大する円形エフェクト
                        const currentRadius = (frame / totalFrames) * effectRadius;
                        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 16) {
                            const effectX = Math.round(this.player.x + Math.cos(angle) * currentRadius);
                            const effectY = Math.round(this.player.y + Math.sin(angle) * currentRadius);

                            if (effectX >= 0 && effectX < this.width && effectY >= 0 && effectY < this.height) {
                                const symbols = ['✧', '✦', '✯', '✶', '⋇'];
                                this.effects.push({
                                    type: 'levelup',
                                    x: effectX,
                                    y: effectY,
                                    duration: 3,
                                    symbol: symbols[Math.floor(Math.random() * symbols.length)],
                                    color: '#00ffff',
                                    intensity: 1 - (frame / totalFrames)
                                });
                            }
                        }

                        // 上昇する数字エフェクト
                        if (frame % 5 === 0) {
                            const offset = Math.floor(frame / 5);
                            this.effects.push({
                                type: 'levelup_text',
                                x: this.player.x,
                                y: this.player.y - offset,
                                duration: 5,
                                text: `LEVEL UP!`,
                                color: '#ffff00',
                                intensity: 1 - (frame / totalFrames)
                            });
                        }

                        // HP増加の表示
                        if (frame === Math.floor(totalFrames / 2)) {
                            this.addDamagePopup(
                                this.player.x,
                                this.player.y - 1,
                                `Max HP +${hpIncrease}`, // 正しい変数名を使用
                                {
                                    color: '#00ffff',
                                    scale: 1.2,
                                    text: `Max HP +${hpIncrease}`, // ここも同様
                                    style: `
                        color: #00ffff;
                        text-shadow: 0 0 10px #00ffff,
                                    0 0 20px #00ffff,
                                    2px 2px 2px rgba(0,0,0,0.5);
                        font-weight: bold;
                    `
                                }
                            );
                        }


                        frame++;

                        // アニメーション終了処理
                        if (frame >= totalFrames) {
                            clearInterval(animationInterval);
                            setTimeout(resolve, 500); // 最後のエフェクトが見えるよう少し待つ
                        }
                    }, 33); // 約30FPS
                });
            }

            saveGame() {
                try {
                    // ユニークエネミーシステムの状態を保存
                    const uniqueEnemySystemState = {
                        spawnCooldown: this.uniqueEnemySystem?.spawnCooldown || 0,
                        portalTimer: this.uniqueEnemySystem?.portalTimer || 0,
                        maxPortalTime: this.uniqueEnemySystem?.maxPortalTime || 0,
                        isPortalActive: this.uniqueEnemySystem?.isPortalActive || false,
                        portalPosition: this.uniqueEnemySystem?.portalPosition || null,
                        uniqueColor: this.uniqueEnemySystem?.uniqueColor || null
                    };

                    // 保存する状態をクリーンに構築
                    const saveData = {
                        version: 'v0.0.1',
                        timestamp: Date.now(),
                        gameState: {
                            gameStarted: this.gameStarted,
                            gameState: this.gameState,
                            gameTime: this.gameTime,
                            score: this.score,
                            dangerLevel: this.dangerLevel,
                            nextDangerLevelChange: this.nextDangerLevelChange,
                            isPortalActive: this.isPortalActive,
                            portalTimer: this.portalTimer,
                            portalPosition: this.portalPosition
                        },
                        player: {
                            name: this.player.name,
                            x: this.player.x,
                            y: this.player.y,
                            health: this.player.health,
                            maxHealth: this.player.maxHealth,
                            level: this.player.level,
                            exp: this.player.exp,
                            expToLevel: this.player.expToLevel,
                            moveDelay: this.player.moveDelay,
                            gemAttractionRange: this.player.gemAttractionRange,
                            moveSpeed: this.player.moveSpeed,
                            stats: {
                                ATK: this.player.stats.ATK,
                                DEF: this.player.stats.DEF,
                                SPD: this.player.stats.SPD,
                                damageMultiplier: this.player.stats.damageMultiplier,
                                defenseMultiplier: this.player.stats.defenseMultiplier,
                                criticalChance: this.player.stats.criticalChance,
                                criticalMultiplier: this.player.stats.criticalMultiplier,
                                dodgeChance: this.player.stats.dodgeChance,
                                health: this.player.stats.health,
                                maxHealth: this.player.stats.maxHealth,
                                moveSpeed: this.player.stats.moveSpeed,
                                moveDelay: this.player.stats.moveDelay,
                                gemAttractionRange: this.player.stats.gemAttractionRange
                            }
                        },
                        weapons: Object.entries(this.weapons).reduce((acc, [type, weapon]) => {
                            acc[type] = {
                                ...weapon,
                                game: undefined // game参照を除外
                            };
                            return acc;
                        }, {}),
                        enemies: this.enemies.map(enemy => this.serializeEnemy(enemy)),
                        gems: this.gems.map(gem => ({
                            ...gem,
                            game: undefined
                        })),
                        uniqueEnemySystem: uniqueEnemySystemState,
                        upgradeState: {
                            isInUpgradeSelection: this.upgradeSystem?.selectedOptions?.length > 0,
                            pendingUpgradeType: this.upgradeSystem?.currentSelectionType,
                            levelUpPending: this.player.exp >= this.player.expToLevel
                        }
                    };

                    localStorage.setItem('survivorsComplexSave', JSON.stringify(saveData));
                    //console.log('Game saved successfully:', saveData);
                    return true;
                } catch (error) {
                    console.error('Failed to save game:', error);
                    return false;
                }
            }

            loadGame() {
                try {
                    const savedData = localStorage.getItem('survivorsComplexSave');
                    if (!savedData) {
                        console.log('No save data found');
                        return false;
                    }

                    const data = JSON.parse(savedData);

                    // バージョンチェック
                    if (data.version !== 'v0.0.1') {
                        console.warn('Save data version mismatch');
                        return false;
                    }

                    // 表示関連の初期化を先に行う
                    this.initializeBackgroundGrid();
                    this.calculateViewportSize();

                    // ゲーム状態の復元前にゲーム進行を一時停止
                    const wasGameStarted = this.gameStarted;
                    this.gameStarted = false;

                    // ゲーム状態の復元
                    Object.assign(this, data.gameState);

                    // プレイヤーの復元
                    this.player = {
                        ...this.player,
                        ...data.player,
                        stats: new PlayerStats()
                    };
                    Object.assign(this.player.stats, data.player.stats);
                    this.player.stats.updateDerivedStats();

                    // 武器の復元
                    this.weapons = {};
                    Object.entries(data.weapons).forEach(([type, weaponData]) => {
                        this.weapons[type] = {
                            ...this.availableWeapons[type],
                            ...weaponData,
                            game: this
                        };
                    });

                    // エンティティの復元
                    this.enemies = data.enemies.map(enemyData =>
                        enemyData.isUnique ?
                            UniqueEnemy.fromSaveData(enemyData, this) :
                            this.deserializeEnemy(enemyData)
                    );

                    this.gems = data.gems.map(gemData => ({
                        ...gemData,
                        game: this
                    }));

                    // システムの復元
                    this.uniqueEnemySystem = new UniqueEnemySpawnSystem(this);
                    Object.assign(this.uniqueEnemySystem, data.uniqueEnemySystem);

                    this.upgradeSystem = new UpgradeSystem(this);
                    if (data.upgradeState?.isInUpgradeSelection) {
                        this.upgradeSystem.currentSelectionType = data.upgradeState.pendingUpgradeType;
                        this.gameState = 'upgrade';
                    }

                    // エフェクトと一時的な状態をリセット
                    this.effects = [];
                    this.projectiles = [];
                    this.activeProjectiles = [];
                    this.damagePopups = [];
                    this.explosions = [];
                    this.portalEffects = [];
                    this.isPlayerTurn = true;
                    this.needsUpdate = false;
                    this.inputEnabled = true;

                    // DOMエレメントの再取得と初期化
                    this.display = document.getElementById('game');
                    this.statsDisplay = document.getElementById('stats');

                    // weapon-selectの状態を適切に設定
                    const weaponSelect = document.getElementById('weapon-select');
                    if (weaponSelect) {
                        weaponSelect.style.display = this.gameState === 'playing' ? 'none' : 'flex';
                    }

                    // ダメージフラッシュのリセット
                    this.damageFlash = 0;
                    const overlay = document.getElementById('damageFlashOverlay');
                    if (overlay) {
                        overlay.classList.remove('active');
                    }

                    // ポップアップコンテナの更新
                    this.updatePopupContainer();

                    // ゲームの進行を再開（保存時の状態を反映）
                    this.gameStarted = data.gameState.gameStarted;

                    // 即座に描画を更新
                    this.render();

                    console.log('Game loaded successfully', {
                        gameState: this.gameState,
                        playerStats: this.player.stats,
                        enemyCount: this.enemies.length
                    });

                    return true;
                } catch (error) {
                    console.error('Failed to load game:', error);
                    // エラー時はゲームをリセット
                    this.resetGame();
                    return false;
                }
            }

            resetGame() {
                try {
                    // 基本的なゲーム状態のリセット
                    this.gameState = 'title';
                    this.gameStarted = false;
                    this.gameTime = 0;
                    this.score = 0;
                    this.dangerLevel = 1;
                    this.nextDangerLevelChange = 300;
                    this.inputEnabled = true;
                    this.needsUpdate = false;
                    this.moveCounter = 0;

                    // プレイヤーの初期化を確実に行う
                    this.player = {
                        x: Math.floor(this.width / 2),
                        y: Math.floor(this.height / 2),
                        level: 1,
                        exp: 0,
                        expToLevel: 10,
                        name: '',
                        stats: new PlayerStats(),
                        moveDelay: 0,
                        isPlayerTurn: true,
                        lastDamageTime: 0,
                        invulnerableTime: 0
                    };

                    // プレイヤーの基本属性を PlayerStats から確実に設定
                    this.player.health = this.player.stats.health;
                    this.player.maxHealth = this.player.stats.maxHealth;
                    this.player.moveSpeed = this.player.stats.moveSpeed;
                    this.player.moveDelay = this.player.stats.moveDelay;
                    this.player.gemAttractionRange = this.player.stats.gemAttractionRange;

                    // 武器システムの初期化
                    this.weapons = {};
                    Object.keys(this.availableWeapons).forEach(type => {
                        this.weapons[type] = {
                            ...this.availableWeapons[type],
                            active: false,
                            game: this,
                            cooldown: 0,
                            angle: 0
                        };
                    });

                    // エンティティのクリア
                    this.enemies = [];
                    this.gems = [];
                    this.effects = [];
                    this.projectiles = [];
                    this.activeProjectiles = [];
                    this.explosions = [];
                    this.damagePopups = [];
                    this.damagedEnemies = [];
                    this.portalEffects = [];

                    // システムの再初期化
                    this.uniqueEnemySystem = new UniqueEnemySpawnSystem(this);
                    this.upgradeSystem = new UpgradeSystem(this);
                    this.playerSetup = new PlayerSetup(this);

                    // ポータル関連の状態をリセット
                    this.isPortalActive = false;
                    this.portalPosition = null;
                    this.portalTimer = 0;
                    this.maxPortalTime = 100;

                    // lookモード関連の初期化
                    this.lookCursor = null;

                    // 表示関連の初期化
                    this.initializeBackgroundGrid();
                    this.calculateViewportSize();

                    // UI要素のクリア
                    const popupContainer = document.querySelector('.popup-container');
                    if (popupContainer) {
                        popupContainer.innerHTML = '';
                    }

                    // 武器選択UIの初期化
                    const weaponSelect = document.getElementById('weapon-select');
                    if (weaponSelect) {
                        weaponSelect.style.display = 'none';
                        weaponSelect.innerHTML = '';
                    }

                    // ダメージフラッシュをリセット
                    this.damageFlash = 0;
                    const overlay = document.getElementById('damageFlashOverlay');
                    if (overlay) {
                        overlay.classList.remove('active');
                    }

                    // DOMエレメントの再取得と初期化
                    this.display = document.getElementById('game');
                    this.statsDisplay = document.getElementById('stats');
                    if (this.display) {
                        this.display.innerHTML = '';
                    }
                    if (this.statsDisplay) {
                        this.statsDisplay.innerHTML = '';
                    }

                    // セーブデータのクリア
                    this.clearSaveData();

                    // タイトル画面の表示
                    this.showTitle();

                    // 即座に描画を更新
                    this.render();

                    console.log('Game reset completed', {
                        playerPosition: { x: this.player.x, y: this.player.y },
                        gameState: this.gameState,
                        playerStats: this.player.stats
                    });

                    return true;
                } catch (error) {
                    console.error('Failed to reset game:', error);
                    return false;
                }
            }

            // また、以下のヘルパーメソッドを追加して、プレイヤーの初期化を確実にします
            initializePlayer() {
                const stats = new PlayerStats();
                return {
                    x: Math.floor(this.width / 2),
                    y: Math.floor(this.height / 2),
                    level: 1,
                    exp: 0,
                    expToLevel: 100,
                    name: '',
                    stats: stats,
                    health: stats.health,
                    maxHealth: stats.maxHealth,
                    moveSpeed: stats.moveSpeed,
                    moveDelay: stats.moveDelay,
                    gemAttractionRange: stats.gemAttractionRange,
                    isPlayerTurn: true,
                    lastDamageTime: 0,
                    invulnerableTime: 0
                };
            }

            // エンティティのシリアライズ/デシリアライズヘルパー
            serializeEnemy(enemy) {
                if (enemy.isUnique) {
                    return {
                        ...enemy,
                        game: undefined,
                        stats: {
                            ATK: enemy.stats.ATK,
                            DEF: enemy.stats.DEF,
                            SPD: enemy.stats.SPD,
                            maxHealth: enemy.stats.maxHealth,
                            damageMultiplier: enemy.stats.damageMultiplier,
                            defenseMultiplier: enemy.stats.defenseMultiplier
                        },
                        weapons: Object.entries(enemy.weapons).reduce((acc, [type, weapon]) => {
                            acc[type] = {
                                ...weapon,
                                game: undefined
                            };
                            return acc;
                        }, {})
                    };
                }
                return {
                    ...enemy,
                    game: undefined
                };
            }

            deserializeEnemy(enemyData) {
                const enemy = new Enemy(
                    enemyData.x,
                    enemyData.y,
                    this.enemyTypes[enemyData.type],
                    enemyData.tier || 0
                );
                Object.assign(enemy, enemyData);
                enemy.game = this;
                return enemy;
            }

            clearSaveData() {
                try {
                    localStorage.removeItem('survivorsComplexSave');
                    console.log('Save data cleared');
                    return true;
                } catch (error) {
                    console.error('Failed to clear save data:', error);
                    return false;
                }
            }

            resetUI() {
                // ダメージフラッシュオーバーレイのリセット
                const overlay = document.getElementById('damageFlashOverlay');
                if (overlay) {
                    overlay.classList.remove('active');
                }

                // 武器選択画面の初期化
                const weaponSelect = document.getElementById('weapon-select');
                if (weaponSelect) {
                    weaponSelect.style.display = 'none';
                    weaponSelect.innerHTML = '';
                }

                // ゲーム画面とステータス表示のクリア
                if (this.display) {
                    this.display.innerHTML = '';
                }
                if (this.statsDisplay) {
                    this.statsDisplay.innerHTML = '';
                }

                // gameStateに応じた適切な画面を表示
                if (this.gameState === 'title') {
                    this.showTitle();
                }
            }

            // ゲームオーバー時にセーブデータを削除
            clearSaveData() {
                try {
                    localStorage.removeItem('survivorsComplexSave');
                    console.log('Save data cleared');
                } catch (error) {
                    console.error('Failed to clear save data:', error);
                }
            }

            handleInput(event) {
                if (!this.inputEnabled) {
                    return;
                }

                // ゲーム状態に応じた入力処理
                switch (this.gameState) {
                    case 'title':
                        if (event.code === 'Space') {
                            this.gameState = 'nameInput';
                            this.playerSetup.showNameInput();
                        }
                        break;

                    case 'nameInput':
                        // プレイヤー名入力処理
                        if (event.key === 'Enter' && this.playerSetup.playerName.length > 0) {
                            this.gameState = 'statAllocation';
                            this.playerSetup.showStatAllocation();
                        } else if (event.key === 'Backspace') {
                            this.playerSetup.handleNameBackspace();
                        } else if (event.key.length === 1 && this.playerSetup.playerName.length < 15) {
                            this.playerSetup.handleNameInput(event.key);
                        }
                        break;

                    case 'statAllocation':
                        // ステータス振り分け処理
                        switch (event.key) {
                            case 'ArrowUp':
                            case 'ArrowDown':
                                this.playerSetup.handleStatSelection(event.key);
                                break;
                            case 'ArrowLeft':
                            case 'ArrowRight':
                                this.playerSetup.handleStatAdjustment(event.key);
                                break;
                            case 'Enter':
                                if (this.playerSetup.remainingPoints === 0) {
                                    this.playerSetup.applyStats();
                                }
                                break;
                        }
                        break;

                    case 'weaponSelect':
                        this.handleWeaponSelection(event.key);
                        break;

                    case 'playing':
                        // CTL+Qキー処理
                        if (event.key === 'q' && event.ctrlKey) {
                            if (confirm('Do you want to reset the game?')) {
                                this.resetGame();
                                return;
                            }
                        }

                        // ポータルのキー判定を追加
                        if (event.key.toLowerCase() === 'p') {
                            // console.log('Portal key pressed'); // デバッグログ
                            this.usePortal();
                            return;
                        }

                        // ルックモードの処理を追加
                        if (event.key.toLowerCase() === ';') {
                            this.enterLookMode();
                            return;
                        }

                        if (!this.gameStarted || !this.isPlayerTurn || this.player.moveDelay > 0) {
                            return;
                        }

                        let moved = false;
                        const key = event.key.toLowerCase();

                        // 移動処理
                        switch (key) {
                            case '.':
                                moved = true;
                                break;

                            case 'arrowup':
                            case 'k':
                            case 'w':
                                this.player.y = Math.max(0, this.player.y - 1);
                                moved = true;
                                break;

                            case 'arrowdown':
                            case 'j':
                            case 's':
                                this.player.y = Math.min(this.height - 1, this.player.y + 1);
                                moved = true;
                                break;

                            case 'arrowleft':
                            case 'h':
                            case 'a':
                                this.player.x = Math.max(0, this.player.x - 1);
                                moved = true;
                                break;

                            case 'arrowright':
                            case 'l':
                            case 'd':
                                this.player.x = Math.min(this.width - 1, this.player.x + 1);
                                moved = true;
                                break;

                            case 'y':  // 左上
                                this.player.x = Math.max(0, this.player.x - 1);
                                this.player.y = Math.max(0, this.player.y - 1);
                                moved = true;
                                break;

                            case 'u':  // 右上
                                this.player.x = Math.min(this.width - 1, this.player.x + 1);
                                this.player.y = Math.max(0, this.player.y - 1);
                                moved = true;
                                break;

                            case 'b':  // 左下
                                this.player.x = Math.max(0, this.player.x - 1);
                                this.player.y = Math.min(this.height - 1, this.player.y + 1);
                                moved = true;
                                break;

                            case 'n':  // 右下
                                this.player.x = Math.min(this.width - 1, this.player.x + 1);
                                this.player.y = Math.min(this.height - 1, this.player.y + 1);
                                moved = true;
                                break;
                        }

                        if (moved) {
                            // moveDelay を PlayerStats から取得
                            this.player.moveDelay = this.player.stats.moveDelay;
                            this.isPlayerTurn = false;
                            this.needsUpdate = true;
                        }
                        break;

                    case 'home':
                        if (event.code === 'Space') {
                            this.returnToField();
                        }
                        break;

                    // looking 状態の処理も追加
                    case 'looking':
                        const lookKey = event.key.toLowerCase();
                        switch (lookKey) {
                            case 'escape':
                            case ';':
                                // ルックモードを終了
                                this.gameState = 'playing';
                                const infoOverlay = document.getElementById('look-info-overlay');
                                if (infoOverlay) {
                                    infoOverlay.style.display = 'none';
                                }
                                break;

                            case 'arrowup':
                            case 'k':
                                this.lookCursor.y = Math.max(0, this.lookCursor.y - 1);
                                this.showLookInfo();
                                break;

                            case 'arrowdown':
                            case 'j':
                                this.lookCursor.y = Math.min(this.height - 1, this.lookCursor.y + 1);
                                this.showLookInfo();
                                break;

                            case 'arrowleft':
                            case 'h':
                                this.lookCursor.x = Math.max(0, this.lookCursor.x - 1);
                                this.showLookInfo();
                                break;

                            case 'arrowright':
                            case 'l':
                                this.lookCursor.x = Math.min(this.width - 1, this.lookCursor.x + 1);
                                this.showLookInfo();
                                break;

                            case 'home':
                            case 'y':
                                this.lookCursor.x = Math.max(0, this.lookCursor.x - 1);
                                this.lookCursor.y = Math.max(0, this.lookCursor.y - 1);
                                this.showLookInfo();
                                break;

                            case 'end':
                            case 'n':
                                this.lookCursor.x = Math.min(this.width - 1, this.lookCursor.x + 1);
                                this.lookCursor.y = Math.min(this.height - 1, this.lookCursor.y + 1);
                                this.showLookInfo();
                                break;

                            case 'pageup':
                            case 'u':
                                this.lookCursor.x = Math.min(this.width - 1, this.lookCursor.x + 1);
                                this.lookCursor.y = Math.max(0, this.lookCursor.y - 1);
                                this.showLookInfo();
                                break;

                            case 'pagedown':
                            case 'b':
                                this.lookCursor.x = Math.max(0, this.lookCursor.x - 1);
                                this.lookCursor.y = Math.min(this.height - 1, this.lookCursor.y + 1);
                                this.showLookInfo();
                                break;
                        }
                        break;

                    default:
                        // アップグレード選択中などの特殊な状態
                        if (this.upgradeSystem?.currentSelectionType) {
                            const upgradeOptions = document.querySelectorAll('.upgrade-option');
                            const keyNum = parseInt(event.key);
                            if (!isNaN(keyNum) && keyNum > 0 && keyNum <= upgradeOptions.length) {
                                this.upgradeSystem.selectUpgrade(keyNum - 1);
                            }
                        }
                        break;
                }
            }

            enterLookMode() {
                this.gameState = 'looking';
                this.lookCursor = {
                    x: this.player.x,
                    y: this.player.y
                };
                this.showLookInfo();
            }

            showLookInfo() {
                // カーソル位置の敵を探す
                const enemy = this.enemies.find(e =>
                    Math.round(e.x) === this.lookCursor.x &&
                    Math.round(e.y) === this.lookCursor.y
                );

                if (enemy) {
                    let info;

                    // ユニークエネミーかどうかで表示内容を分岐
                    if (enemy.isUnique) {
                        info = enemy.getDisplayInfo();
                    } else {
                        // 通常の敵用の既存の表示ロジック
                        const healthPercentage = Math.round((enemy.health / enemy.maxHealth) * 100);
                        const enemyType = this.enemyTypes[enemy.type];
                        info = [
                            `Type: ${enemyType.name}`,
                            `Health: ${enemy.health}/${enemy.maxHealth} (${healthPercentage}%)`,
                            `Tier: ${enemy.tier + 1}`,
                            `Base Damage: ${enemy.damage.base}`,
                            `Special Abilities: ${enemy.abilities?.length ? enemy.abilities.join(', ') : 'None'}`
                        ];
                    }

                    // 情報表示用のオーバーレイを作成/更新
                    let infoOverlay = document.getElementById('look-info-overlay');
                    if (!infoOverlay) {
                        infoOverlay = document.createElement('div');
                        infoOverlay.id = 'look-info-overlay';
                        infoOverlay.style.cssText = `
                position: absolute;
                background: rgba(0, 0, 0, 0.85);
                padding: 10px;
                border: 1px solid ${enemy.isUnique ? enemy.uniqueColor.primary : '#444'};
                color: #fff;
                font-family: monospace;
                font-size: 10px;
                line-height: 1.5;
                z-index: 1000;
                white-space: pre;
                pointer-events: none;
                box-shadow: 0 0 10px ${enemy.isUnique ? enemy.uniqueColor.secondary : 'rgba(0,0,0,0.5)'};
                transition: top 0.2s ease-out, left 0.2s ease-out;
            `;
                        document.querySelector('.game-area').appendChild(infoOverlay);
                    }

                    infoOverlay.innerHTML = info.join('\n');
                    infoOverlay.style.display = 'block';

                    // 位置計算のための要素取得
                    const gameElement = document.getElementById('game');
                    const gameArea = document.querySelector('.game-area');
                    const gameRect = gameElement.getBoundingClientRect();
                    const gameAreaRect = gameArea.getBoundingClientRect();
                    const cellWidth = gameRect.width / this.width;
                    const cellHeight = gameRect.height / this.height;

                    // オーバーレイのサイズを計算（非表示で計測）
                    infoOverlay.style.visibility = 'hidden';
                    infoOverlay.style.display = 'block';
                    const overlayRect = infoOverlay.getBoundingClientRect();
                    infoOverlay.style.visibility = 'visible';

                    // マージン設定
                    const margin = 10;

                    // カーソル位置の相対座標を計算
                    const cursorScreenX = this.lookCursor.x * cellWidth + gameRect.left;
                    const cursorScreenY = this.lookCursor.y * cellHeight + gameRect.top;

                    // 画面の中央よりも下にカーソルがある場合は上に表示
                    const isInLowerHalf = cursorScreenY > (gameAreaRect.top + gameAreaRect.bottom) / 2;

                    // 左右位置の決定
                    let left;
                    // 画面の右半分にある場合は左側に表示
                    if (cursorScreenX > (gameAreaRect.left + gameAreaRect.right) / 2) {
                        left = Math.max(
                            gameAreaRect.left + margin,
                            cursorScreenX - overlayRect.width - margin
                        );
                    } else {
                        left = Math.min(
                            gameAreaRect.right - overlayRect.width - margin,
                            cursorScreenX + cellWidth + margin
                        );
                    }

                    // 上下位置の決定
                    let top;
                    if (isInLowerHalf) {
                        // カーソルが下半分にある場合は上に表示
                        top = Math.max(
                            gameAreaRect.top + margin,
                            cursorScreenY - overlayRect.height - margin
                        );
                    } else {
                        // カーソルが上半分にある場合は下に表示
                        top = Math.min(
                            gameAreaRect.bottom - overlayRect.height - margin,
                            cursorScreenY + cellHeight + margin
                        );
                    }

                    // 位置の適用
                    infoOverlay.style.left = `${left}px`;
                    infoOverlay.style.top = `${top}px`;

                } else {
                    // 敵がいない場合は情報を非表示
                    const infoOverlay = document.getElementById('look-info-overlay');
                    if (infoOverlay) {
                        infoOverlay.style.display = 'none';
                    }
                }

                // カーソル表示の更新
                this.render();
            }

            createEnemy(x, y, tier = 0) {
                // 危険度に基づくステータス補正
                const dangerMultiplier = 1 + ((this.dangerLevel - 1) * 0.2);
                const time = this.gameTime;  // 10フレーム = 1秒
                // 時間閾値を調整（秒数で表記）
                // 現在: time < 100 (10秒) -> 300 (30秒) -> 600 (60秒)
                // 変更: time < 300 (30秒) -> 900 (90秒) -> 1800 (180秒)

                let enemyPool = [];

                if (time < 300) {  // 開始から30秒まで - 初期段階
                    enemyPool.push(
                        { type: 'grunt', weight: 80 },    // 80% の確率
                        { type: 'speeder', weight: 20 }   // 20% の確率
                    );
                }
                else if (time < 900) {  // 30秒から90秒まで - 第2段階
                    enemyPool.push(
                        { type: 'grunt', weight: 60 },    // 60% の確率
                        { type: 'speeder', weight: 25 },  // 25% の確率
                        { type: 'tank', weight: 15 }      // 15% の確率
                    );
                }
                else if (time < 1800) {  // 90秒から180秒まで - 第3段階
                    enemyPool.push(
                        { type: 'grunt', weight: 35 },    // 35% の確率
                        { type: 'speeder', weight: 25 },  // 25% の確率
                        { type: 'tank', weight: 20 },     // 20% の確率
                        { type: 'splitter', weight: 10 }, // 10% の確率
                        { type: 'phantom', weight: 10 }   // 10% の確率
                    );
                }
                else {  // 180秒以降 - 最終段階
                    enemyPool.push(
                        { type: 'grunt', weight: 15 },     // 15% の確率
                        { type: 'speeder', weight: 15 },   // 15% の確率
                        { type: 'tank', weight: 15 },      // 15% の確率
                        { type: 'splitter', weight: 15 },  // 15% の確率
                        { type: 'berserker', weight: 15 }, // 15% の確率
                        { type: 'phantom', weight: 10 },   // 10% の確率
                        { type: 'guardian', weight: 10 },  // 10% の確率
                        { type: 'assassin', weight: 5 }    //  5% の確率
                    );
                }

                // ティアの計算も調整（60秒ごとに1ティア上昇）
                const newTier = Math.min(Math.floor(time / 600), 9);  // 600フレーム = 60秒
                tier = Math.max(tier, newTier);  // 渡されたティアと計算したティアの大きい方を採用

                // 選択された敵タイプの取得とベースステータスの設定
                const totalWeight = enemyPool.reduce((sum, enemy) => sum + enemy.weight, 0);
                let random = Math.random() * totalWeight;
                let selectedType = 'grunt';  // デフォルト値

                for (const enemy of enemyPool) {
                    if (random < enemy.weight) {
                        selectedType = enemy.type;
                        break;
                    }
                    random -= enemy.weight;
                }

                // 選択された敵タイプの取得
                const baseStats = this.enemyTypes[selectedType];
                if (!baseStats) {
                    console.error('Invalid enemy type:', selectedType);
                    return null;
                }

                const enemy = {
                    x: x,
                    y: y,
                    type: selectedType,
                    tier: tier,
                    moveDelay: 0,
                    health: Math.round(baseStats.health * (1 + tier * 0.5) * dangerMultiplier),
                    maxHealth: Math.round(baseStats.health * (1 + tier * 0.5) * dangerMultiplier),
                    damage: {
                        base: Math.round(baseStats.damage.base * (1 + tier * 0.4) * dangerMultiplier),
                        variationPercent: baseStats.damage.variationPercent
                    },
                    moveSpeed: Math.min(baseStats.moveSpeed * dangerMultiplier, 8), // 最大速度を制限
                    symbol: baseStats.symbol,
                    behavior: baseStats.behavior,
                    color: baseStats.color,
                    abilities: baseStats.abilities ? [...baseStats.abilities] : [],
                    expValue: Math.round(baseStats.expValue * (1 + tier * 0.3)),
                    abilityTimers: {},
                    lastDamageTime: 0,
                    hasSplit: false  // 分裂フラグを追加
                };

                // デバッグログ
                //console.log(`Spawning ${selectedType} (Tier ${tier}) at time ${Math.floor(time / 10)}s`);

                return enemy;
            }

            updateEnemyBehavior(enemy) {
                const behavior = this.enemyBehaviors[enemy.behavior];
                if (behavior) {
                    behavior(enemy, this);
                }

                // 能力の更新
                if (enemy.abilities) {
                    enemy.abilities.forEach(abilityName => {
                        const ability = this.enemyAbilities[abilityName];
                        if (ability && enemy.abilityTimers[abilityName] <= 0) {
                            ability.execute(enemy, this);
                            enemy.abilityTimers[abilityName] = ability.cooldown;
                        } else if (enemy.abilityTimers[abilityName] > 0) {
                            enemy.abilityTimers[abilityName]--;
                        }
                    });
                }
            }

            updateEnemyAbilities(enemy) {
                if (!enemy.abilities) return;

                enemy.abilities.forEach(abilityName => {
                    const ability = this.enemyAbilities[abilityName];
                    if (!ability) return;

                    // クールダウンの初期化（存在しない場合）
                    if (!enemy.abilityTimers[abilityName]) {
                        enemy.abilityTimers[abilityName] = 0;
                    }

                    // クールダウンチェックと能力実行
                    if (enemy.abilityTimers[abilityName] <= 0) {
                        ability.execute(enemy, this);
                        enemy.abilityTimers[abilityName] = ability.cooldown;

                        // デバッグログ
                        //console.log(`Enemy ${enemy.type} used ability ${abilityName}`);
                    } else {
                        enemy.abilityTimers[abilityName]--;
                    }
                });
            }


            moveEnemyTowardsPlayer(enemy, speed = null) {
                // 最も近い攻撃対象（プレイヤーまたはユニークエネミー）を見つける
                let nearestTarget = null;
                let shortestDist = Infinity;

                // プレイヤーまでの距離を計算
                const playerDx = this.player.x - enemy.x;
                const playerDy = this.player.y - enemy.y;
                const playerDist = Math.sqrt(playerDx * playerDx + playerDy * playerDy);

                if (playerDist < shortestDist) {
                    shortestDist = playerDist;
                    nearestTarget = this.player;
                }

                // ユニークエネミーまでの距離を計算
                this.enemies.forEach(otherEnemy => {
                    if (otherEnemy.isUnique && otherEnemy !== enemy) {
                        const dx = otherEnemy.x - enemy.x;
                        const dy = otherEnemy.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < shortestDist) {
                            shortestDist = dist;
                            nearestTarget = otherEnemy;
                        }
                    }
                });

                // 最も近い対象に向かって移動
                if (nearestTarget && shortestDist > 0) {
                    const moveSpeed = speed || enemy.moveSpeed * 0.15;
                    const dx = nearestTarget.x - enemy.x;
                    const dy = nearestTarget.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    enemy.x += (dx / dist) * moveSpeed;
                    enemy.y += (dy / dist) * moveSpeed;

                    const margin = 3;
                    enemy.x = Math.max(-margin, Math.min(this.width + margin, enemy.x));
                    enemy.y = Math.max(-margin, Math.min(this.height + margin, enemy.y));

                    if (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01) {
                        enemy.lastX = enemy.x;
                        enemy.lastY = enemy.y;
                    }
                }
            }

            moveEnemyCircular(enemy) {
                const dx = this.player.x - enemy.x;
                const dy = this.player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    const angle = Math.atan2(dy, dx) + Math.sin(this.gameTime * 0.1) * 0.5;
                    const moveX = Math.round(Math.cos(angle));
                    const moveY = Math.round(Math.sin(angle));

                    enemy.x = Math.max(0, Math.min(this.width - 1, enemy.x + moveX));
                    enemy.y = Math.max(0, Math.min(this.height - 1, enemy.y + moveY));
                }
            }

            moveEnemyAmbush(enemy) {
                const dx = this.player.x - enemy.x;
                const dy = this.player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 5 && Math.random() > 0.7) {
                    const moveX = Math.round((dx / dist) * 2);
                    const moveY = Math.round((dy / dist) * 2);

                    enemy.x = Math.max(0, Math.min(this.width - 1, enemy.x + moveX));
                    enemy.y = Math.max(0, Math.min(this.height - 1, enemy.y + moveY));
                }
            }

            updateDangerLevel() {
                // 1-5のランダムな危険度を設定
                this.dangerLevel = Math.floor(Math.random() * 5) + 1;

                // 危険度変更エフェクトを追加
                const effectColor = this.dangerLevelColors[this.dangerLevel - 1];
                for (let i = 0; i < this.width; i += 2) {
                    this.effects.push({
                        type: 'danger_level',
                        x: i,
                        y: 0,
                        duration: 20,
                        symbol: '▼',
                        color: effectColor,
                        opacity: 0.8
                    });
                    this.effects.push({
                        type: 'danger_level',
                        x: i,
                        y: this.height - 1,
                        duration: 20,
                        symbol: '▲',
                        color: effectColor,
                        opacity: 0.8
                    });
                }
            }

            // spawnEnemy メソッドを修正（既存のメソッド内に追加）
            spawnEnemy() {
                if (!this.gameStarted) return;

                // 危険度に基づくスポーン確率の調整
                const baseSpawnChance = 0.1; // 基本スポーン確率
                const dangerMultiplier = 1 + ((this.dangerLevel - 1) * 0.3); // 危険度による倍率

                if (Math.random() > baseSpawnChance * dangerMultiplier) {
                    return;
                }

                // スポーン位置の決定
                let side = Math.floor(Math.random() * 4);
                let x, y;

                switch (side) {
                    case 0: // 上
                        x = Math.floor(Math.random() * this.width);
                        y = 0;
                        break;
                    case 1: // 右
                        x = this.width - 1;
                        y = Math.floor(Math.random() * this.height);
                        break;
                    case 2: // 下
                        x = Math.floor(Math.random() * this.width);
                        y = this.height - 1;
                        break;
                    case 3: // 左
                        x = 0;
                        y = Math.floor(Math.random() * this.height);
                        break;
                }

                // ティア計算
                const tier = Math.min(Math.floor(this.gameTime / 300), 9);

                // enemyPoolの作成とタイプ選択を確実に行う
                const time = this.gameTime;
                let enemyPool = [];

                // デバッグログを追加
                //console.log('Spawning enemy at time:', time);

                if (time < 100) {
                    enemyPool.push(['grunt', 80], ['speeder', 20]);
                } else if (time < 300) {
                    enemyPool.push(['grunt', 50], ['speeder', 30], ['tank', 20]);
                } else if (time < 600) {
                    enemyPool.push(
                        ['grunt', 30],
                        ['speeder', 20],
                        ['tank', 20],
                        ['splitter', 15],
                        ['phantom', 15]
                    );
                } else {
                    enemyPool.push(
                        ['grunt', 15],
                        ['speeder', 15],
                        ['tank', 15],
                        ['splitter', 15],
                        ['berserker', 15],
                        ['phantom', 10],
                        ['guardian', 10],
                        ['assassin', 5]
                    );
                }

                // 重み付き抽選の実装を確実に
                const totalWeight = enemyPool.reduce((sum, [_, weight]) => sum + weight, 0);
                let random = Math.random() * totalWeight;
                let selectedType = 'grunt'; // デフォルト値を設定

                for (const [type, weight] of enemyPool) {
                    if (random < weight) {
                        selectedType = type;
                        break;
                    }
                    random -= weight;
                }

                //console.log('Selected enemy type:', selectedType); // デバッグログ

                // 敵の生成
                const enemy = this.createEnemy(x, y, tier);
                if (enemy) {
                    //console.log('Created enemy:', enemy); // デバッグログ
                    this.enemies.push(enemy);
                } else {
                    console.error('Failed to create enemy');
                }
            }

            handleEnemyDeath(enemy, index) {
                this.addDeathEffect(enemy.x, enemy.y);

                // 敵のティアと種類に基づいてジェムタイプを決定
                let gemType = this.determineGemType(enemy);

                // 新しいジェムを生成（出現確率を下方修正）
                if (Math.random() < 0.8) { // 20%の確率でジェムがドロップしない
                    const newGem = {
                        x: enemy.x,
                        y: enemy.y,
                        type: gemType.type,
                        symbol: gemType.symbol,
                        color: gemType.color,
                        glow: gemType.glow,
                        value: gemType.value,
                        spawnTime: this.gameTime
                    };
                    this.gems.push(newGem);
                }

                this.enemies.splice(index, 1);
                this.score += 100;
            }

            determineGemType(enemy) {
                let rarityRoll = Math.random();
                // ティアボーナスを大幅に下方修正（0.03 → 0.015）
                rarityRoll += (enemy.tier || 0) * 0.015;

                // 敵タイプによるボーナスを下方修正
                const typeBonus = {
                    grunt: 0,
                    speeder: 0.005,     // 0.01 → 0.005
                    tank: 0.01,         // 0.02 → 0.01
                    splitter: 0.015,    // 0.03 → 0.015
                    berserker: 0.02,    // 0.04 → 0.02
                    phantom: 0.015,     // 0.03 → 0.015
                    guardian: 0.025,    // 0.05 → 0.025
                    assassin: 0.03      // 0.06 → 0.03
                };

                rarityRoll += typeBonus[enemy.type] || 0;

                // 経験値の値を大幅に下方修正
                const gemTypes = {
                    common: {
                        ...this.gemTypes.common,
                        value: 1        // 変更なし
                    },
                    uncommon: {
                        ...this.gemTypes.uncommon,
                        value: 1        // 2 → 1
                    },
                    rare: {
                        ...this.gemTypes.rare,
                        value: 2        // 3 → 2
                    },
                    epic: {
                        ...this.gemTypes.epic,
                        value: 3        // 4 → 3
                    },
                    legendary: {
                        ...this.gemTypes.legendary,
                        value: 4        // 5 → 4
                    }
                };

                // 出現確率の閾値をより厳しく調整
                if (rarityRoll >= 0.998) {         // 0.995 → 0.998 (0.2%)
                    return { type: 'legendary', ...gemTypes.legendary };
                } else if (rarityRoll >= 0.98) {   // 0.95 → 0.98 (1.8%)
                    return { type: 'epic', ...gemTypes.epic };
                } else if (rarityRoll >= 0.93) {   // 0.85 → 0.93 (5%)
                    return { type: 'rare', ...gemTypes.rare };
                } else if (rarityRoll >= 0.80) {   // 0.60 → 0.80 (13%)
                    return { type: 'uncommon', ...gemTypes.uncommon };
                } else {                           // 残り80%
                    return { type: 'common', ...gemTypes.common };
                }
            }

            addGemCollectEffect(gem) {
                const color = gem.color;
                this.effects.push({
                    x: gem.x,
                    y: gem.y,
                    frames: [
                        ['∴'],
                        ['⋰', '⋱'],
                        ['⋰', '∴', '⋱']
                    ],
                    fontSize: 12,
                    currentFrame: 0,
                    duration: 3,
                    color: color,
                    glow: `0 0 15px ${color}`
                });

                // ジェムのレアリティに基づいてポップアップスタイルを設定
                const popupStyles = {
                    common: {
                        color: '#6aecfa',
                        glow: '0 0 6px #6aecfa',
                        scale: 1.0
                    },
                    uncommon: {
                        color: '#4eff4e',
                        glow: '0 0 8px #4eff4e',
                        scale: 1.1
                    },
                    rare: {
                        color: '#4e4eff',
                        glow: '0 0 10px #4e4eff',
                        scale: 1.2
                    },
                    epic: {
                        color: '#b44eff',
                        glow: '0 0 12px #b44eff',
                        scale: 1.3
                    },
                    legendary: {
                        color: '#ffcf4e',
                        glow: '0 0 15px #ffcf4e',
                        scale: 1.4
                    }
                };

                // ジェムのタイプに応じたスタイルを取得
                const style = popupStyles[gem.type] || popupStyles.common;

                // 数値の前に"+"を付けて、expを追加
                const formattedValue = `+${gem.value}exp`;

                // ポップアップを追加（影付きテキストで視認性を向上）
                this.addDamagePopup(
                    gem.x,
                    gem.y,
                    formattedValue,
                    {
                        color: style.color,
                        scale: style.scale,
                        text: formattedValue,
                        style: `color: ${style.color}; 
                   text-shadow: ${style.glow}, 
                               0 0 1px #000, 
                               1px 1px 1px rgba(0,0,0,0.5);
                   font-weight: bold;`
                    }
                );
            }

            updateWeapons() {
                if (!this.weapons) return;

                // オービタルブレードの更新
                this.projectiles = []; // プロジェクタイルのクリア
                if (this.weapons.orbit?.active) {
                    // クールダウンの更新
                    if (this.weapons.orbit.splashCooldown > 0) {
                        this.weapons.orbit.splashCooldown--;
                    }

                    // 回転速度を0.2から0.4に増加
                    this.weapons.orbit.angle += 0.4;

                    // 回転エフェクトのパターンの更新頻度も調整
                    const orbitPatterns = [
                        { outer: '◢', inner: '━' },
                        { outer: '◣', inner: '═' },
                        { outer: '◥', inner: '━' },
                        { outer: '◤', inner: '═' }
                    ];
                    // パターンの更新頻度を2から3に増加（より速い視覚的な回転）
                    const currentPattern = orbitPatterns[Math.floor((this.gameTime / 3) % 4)];

                    for (let i = 0; i < this.weapons.orbit.projectiles; i++) {
                        let angle = this.weapons.orbit.angle + (i * (2 * Math.PI / this.weapons.orbit.projectiles));
                        let x = this.player.x + Math.cos(angle) * this.weapons.orbit.radius;
                        let y = this.player.y + Math.sin(angle) * this.weapons.orbit.radius;

                        // メインのプロジェクタイル
                        this.projectiles.push({
                            x: Math.round(x),
                            y: Math.round(y),
                            damage: this.weapons.orbit.damage,
                            splashDamage: this.weapons.orbit.splashDamage,
                            symbol: currentPattern.outer,
                            type: 'orbit'
                        });

                        // 軌道エフェクト
                        if (this.weapons.orbit.projectiles > 1) {
                            let nextI = (i + 1) % this.weapons.orbit.projectiles;
                            let nextAngle = this.weapons.orbit.angle + (nextI * (2 * Math.PI / this.weapons.orbit.projectiles));
                            let midX = this.player.x + Math.cos((angle + nextAngle) / 2) * this.weapons.orbit.radius;
                            let midY = this.player.y + Math.sin((angle + nextAngle) / 2) * this.weapons.orbit.radius;

                            this.projectiles.push({
                                x: Math.round(midX),
                                y: Math.round(midY),
                                damage: this.weapons.orbit.splashDamage,
                                splashDamage: this.weapons.orbit.splashDamage / 2,
                                symbol: currentPattern.inner,
                                type: 'orbit-trail'
                            });
                        }
                    }
                }

                // レーザーの更新処理
                if (this.weapons.laser?.active) {
                    // クールダウンの更新
                    if (this.weapons.laser.cooldown > 0) {
                        this.weapons.laser.cooldown--;
                    }

                    // アクティブなレーザープロジェクタイルの更新と削除
                    this.activeProjectiles = this.activeProjectiles.filter(proj => {
                        if (proj.type === 'laser' || proj.type === 'laser-energy') {
                            proj.duration--;
                            return proj.duration > 0;
                        }
                        return true;
                    });

                    // レーザー発射処理
                    if (this.weapons.laser.cooldown <= 0) {
                        const nearestEnemy = this.findNearestEnemy();

                        if (nearestEnemy) {
                            const dx = nearestEnemy.x - this.player.x;
                            const dy = nearestEnemy.y - this.player.y;
                            const angle = Math.atan2(dy, dx);

                            // スプレッドレベルに基づいて追加のレーザービームを生成
                            const spreadAngles = [angle];  // まずは中央のビーム
                            const spreadLevel = this.weapons.laser.spreadLevel;
                            const angleStep = 0.05;  // 基本の拡散角度

                            // スプレッドレベルに応じて左右にビームを追加
                            for (let i = 1; i <= spreadLevel; i++) {
                                spreadAngles.push(angle + (angleStep * i));
                                spreadAngles.push(angle - (angleStep * i));
                            }

                            // 各角度でレーザービームを生成
                            spreadAngles.forEach(beamAngle => {
                                let currentX = this.player.x;
                                let currentY = this.player.y;
                                const stepX = Math.cos(beamAngle);
                                const stepY = Math.sin(beamAngle);

                                for (let i = 1; i <= this.weapons.laser.range; i++) {
                                    currentX += stepX;
                                    currentY += stepY;

                                    const x = Math.floor(currentX);
                                    const y = Math.floor(currentY);

                                    if (x < 0 || x >= this.width || y < 0 || y >= this.height) break;

                                    this.activeProjectiles.push({
                                        type: 'laser',
                                        x: x,
                                        y: y,
                                        damage: this.weapons.laser.damage,
                                        angle: beamAngle,
                                        duration: this.weapons.laser.duration,
                                        maxDuration: this.weapons.laser.duration,
                                        hasDealtDamage: false,
                                        opacity: 1,
                                        createdAt: this.gameTime
                                    });

                                    // エネルギーパルスの生成（30%の確率）
                                    if (Math.random() < 0.3) {
                                        const energyDamage = {
                                            base: Math.round(this.weapons.laser.damage.base * 0.3),
                                            variationPercent: this.weapons.laser.damage.variationPercent
                                        };

                                        this.activeProjectiles.push({
                                            type: 'laser-energy',
                                            x: x,
                                            y: y,
                                            damage: energyDamage,
                                            angle: beamAngle,
                                            duration: 2,
                                            maxDuration: 2,
                                            hasDealtDamage: false,
                                            opacity: 0.7,
                                            createdAt: this.gameTime
                                        });
                                    }
                                }
                            });

                            // クールダウンをリセット
                            this.weapons.laser.cooldown = this.weapons.laser.maxCooldown;
                        }
                    }
                }

                if (this.weapons.missile?.active) {
                    // クールダウン処理
                    if (this.weapons.missile.cooldown <= 0) {
                        // アクティブなミサイルの数をカウント
                        const activeMissiles = this.activeProjectiles.filter(p => p && p.type === 'missile').length;

                        // 発射可能な数を計算
                        const availableSlots = this.weapons.missile.projectiles - activeMissiles;

                        if (availableSlots > 0) {
                            // 最も近い敵から順に指定数までターゲット
                            const targets = this.findNearestEnemies(availableSlots);

                            targets.forEach(target => {
                                this.activeProjectiles.push({
                                    type: 'missile',
                                    x: this.player.x,
                                    y: this.player.y,
                                    targetX: target.x,
                                    targetY: target.y,
                                    damage: this.weapons.missile.damage,
                                    splashRadius: this.weapons.missile.splashRadius,
                                    splashDamage: this.weapons.missile.splashDamage,
                                    speed: this.weapons.missile.speed,
                                    trail: []
                                });
                            });

                            if (targets.length > 0) {
                                this.weapons.missile.cooldown = this.weapons.missile.maxCooldown;
                            }
                        }
                    }

                    this.weapons.missile.cooldown = Math.max(0, this.weapons.missile.cooldown - 1);

                    // アクティブなミサイルの位置更新
                    this.activeProjectiles = this.activeProjectiles
                        .map(proj => {
                            if (!proj) return null;

                            if (proj.type === 'missile') {
                                // ターゲットの位置を保存
                                const targetX = proj.targetX;
                                const targetY = proj.targetY;

                                // ミサイルの移動処理
                                const dx = targetX - proj.x;
                                const dy = targetY - proj.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);

                                if (distance < proj.speed || distance < 0.5) {
                                    // 目標位置に到達したら爆発
                                    this.createExplosionAtPoint(targetX, targetY, proj.splashRadius, proj.splashDamage);
                                    return null;  // projectilesToRemoveの代わりにnullを返す
                                } else {
                                    // 移動処理
                                    proj.x += (dx / distance) * proj.speed;
                                    proj.y += (dy / distance) * proj.speed;

                                    // 軌跡の更新
                                    if (!proj.trail) proj.trail = [];
                                    proj.trail.unshift({ x: proj.x, y: proj.y });
                                    if (proj.trail.length > 5) proj.trail.pop();
                                }
                            }
                            return proj;
                        })
                        .filter(proj => proj !== null);  // nullを除外
                }

                if (this.weapons.motorgun?.active) {
                    const weapon = this.weapons.motorgun;

                    // リロード処理
                    if (weapon.reloadCooldown > 0) {
                        weapon.reloadCooldown--;
                        if (weapon.reloadCooldown === 0) {
                            weapon.ammo = weapon.maxAmmo;
                            // リロード完了エフェクト
                            this.effects.push({
                                type: 'reload_complete',
                                x: this.player.x,
                                y: this.player.y,
                                duration: 10,
                                frames: [['↺'], ['⟳'], ['⟲']],
                                color: '#44ff44',
                                opacity: 1
                            });
                        }
                        return;
                    }

                    // 弾切れチェック
                    if (weapon.ammo <= 0) {
                        weapon.reloadCooldown = weapon.reloadTime;
                        // リロード開始エフェクト
                        this.effects.push({
                            type: 'reload_start',
                            x: this.player.x,
                            y: this.player.y,
                            duration: 5,
                            frames: [['⌛'], ['⏳']],
                            color: '#ffaa44',
                            opacity: 1
                        });
                        return;
                    }

                    // クールダウンの更新
                    if (weapon.cooldown > 0) {
                        weapon.cooldown--;
                    }

                    // プレイヤーの移動状態とwait状態に基づく安定性の更新
                    const isWaiting = this.player.moveDelay === 0 && !this.isPlayerMoving;
                    if (this.player.moveDelay > 0) {
                        weapon.stabilizationTime = Math.max(0, weapon.stabilizationTime - 2);
                    } else {
                        const stabilizationIncrease = isWaiting ? 2 : 1; // wait時は安定性が早く上昇
                        weapon.stabilizationTime = Math.min(weapon.maxStabilization,
                            weapon.stabilizationTime + stabilizationIncrease);
                    }

                    // 発射処理
                    if (weapon.cooldown <= 0 && weapon.ammo > 0) {
                        // 安定性とwait状態に基づく発射レートと精度の計算
                        const stabilizationRatio = weapon.stabilizationTime / weapon.maxStabilization;
                        const waitMultiplier = isWaiting ? weapon.waitBonus : 1;
                        const currentFireRate = Math.floor((weapon.fireRate +
                            (weapon.maxFireRate - weapon.fireRate) * stabilizationRatio) * waitMultiplier);
                        const currentSpread = weapon.maxSpread -
                            (weapon.maxSpread - weapon.minSpread) * stabilizationRatio;

                        // 複数の弾を発射
                        for (let i = 0; i < currentFireRate; i++) {
                            if (weapon.ammo <= 0) break;

                            const nearestEnemy = this.findNearestEnemy();
                            if (nearestEnemy) {
                                const dx = nearestEnemy.x - this.player.x;
                                const dy = nearestEnemy.y - this.player.y;
                                const baseAngle = Math.atan2(dy, dx);
                                const spreadAngle = (Math.random() - 0.5) * currentSpread;
                                const finalAngle = baseAngle + spreadAngle;

                                this.activeProjectiles.push({
                                    type: 'motorgun',
                                    x: this.player.x,
                                    y: this.player.y,
                                    angle: finalAngle,
                                    speed: weapon.projectileSpeed,
                                    damage: weapon.damage,
                                    range: weapon.range,
                                    traveled: 0,
                                    hasHit: false,
                                    trail: [],
                                    trailLength: 3,
                                    hitEffect: {
                                        duration: 5,
                                        symbols: ['※', '◇', '◆'],
                                        colors: ['#ffaa44', '#ff8800', '#ff6600']
                                    }
                                });

                                weapon.ammo--;

                                // 発射エフェクト
                                this.effects.push({
                                    type: 'muzzle_flash',
                                    x: this.player.x,
                                    y: this.player.y,
                                    duration: 3,
                                    frames: [['⊕'], ['⊗'], ['⊙']],
                                    color: '#ffaa44',
                                    opacity: 0.8
                                });
                            }
                        }

                        // クールダウンの設定
                        const cooldownReduction = stabilizationRatio * 0.3;
                        weapon.cooldown = Math.max(2, Math.floor(weapon.maxCooldown * (1 - cooldownReduction)));
                    }
                }

            }

            // findNearestEnemy メソッドも追加
            findNearestEnemy() {
                if (!this.enemies || this.enemies.length === 0) return null;

                let nearestDist = Infinity;
                let nearestEnemy = null;

                for (let enemy of this.enemies) {
                    const dx = enemy.x - this.player.x;
                    const dy = enemy.y - this.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                }

                return nearestEnemy;
            }

            findNearestEnemies(count) {
                if (!this.enemies || this.enemies.length === 0) return [];

                // プレイヤーからの距離でソートした敵の配列を作成
                const sortedEnemies = [...this.enemies].sort((a, b) => {
                    const distA = Math.sqrt(
                        Math.pow(a.x - this.player.x, 2) +
                        Math.pow(a.y - this.player.y, 2)
                    );
                    const distB = Math.sqrt(
                        Math.pow(b.x - this.player.x, 2) +
                        Math.pow(b.y - this.player.y, 2)
                    );
                    return distA - distB;
                });

                // 指定数だけ返す（もしくは利用可能な敵の数だけ）
                return sortedEnemies.slice(0, count);
            }

            // Game クラスの update メソッド内の敵の更新部分を修正

            // 敵の移動
            moveEnemies() {
                this.moveCounter++;
                const baseUpdateInterval = 3;  // 基本の更新間隔

                // 移動更新のタイミング
                if (this.moveCounter % baseUpdateInterval === 0) {
                    this.enemies.forEach(enemy => {
                        if (enemy.isUnique) {
                            // ユニークエネミーは独自の update メソッドを使用
                            enemy.update(this);
                        } else {
                            // 通常の敵の処理
                            const isOutsideScreen =
                                enemy.x < 0 || enemy.x >= this.width ||
                                enemy.y < 0 || enemy.y >= this.height;

                            if (isOutsideScreen) {
                                const dx = this.player.x - enemy.x;
                                const dy = this.player.y - enemy.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist > 0) {
                                    const speed = enemy.moveSpeed * 0.2;
                                    const moveX = (dx / dist) * speed;
                                    const moveY = (dy / dist) * speed;

                                    enemy.x += moveX;
                                    enemy.y += moveY;
                                    enemy.x = Math.max(-3, Math.min(this.width + 3, enemy.x));
                                    enemy.y = Math.max(-3, Math.min(this.height + 3, enemy.y));
                                }
                            } else {
                                const behavior = this.enemyBehaviors[enemy.behavior];
                                if (behavior) {
                                    behavior(enemy, this);
                                }
                                this.checkEnemyPlayerCollision(enemy);
                            }

                            // 特殊能力の更新
                            this.updateEnemyAbilities(enemy);
                        }
                    });
                }
            }

            // 敵の行動パターン定義を明確化
            enemyBehaviors = {
                normal: (enemy, game) => {
                    // 基本的な追跡: プレイヤーに向かってまっすぐ移動
                    if (Math.random() > 0.3) { // 70%の確率で移動
                        game.moveEnemyTowardsPlayer(enemy);
                    }
                },

                zigzag: (enemy, game) => {
                    // ジグザグ移動: 横方向にずれながらプレイヤーを追跡
                    if (Math.random() > 0.3) {
                        const offset = Math.random() > 0.5 ? 1 : -1;
                        enemy.x += offset;
                        game.moveEnemyTowardsPlayer(enemy, true);
                    }
                },

                circular: (enemy, game) => {
                    // 円運動: プレイヤーの周りを回るような動き
                    if (Math.random() > 0.3) {
                        const angle = (game.gameTime * 0.1) + (enemy.initialAngle || 0);
                        const radius = 5;
                        const targetX = game.player.x + Math.cos(angle) * radius;
                        const targetY = game.player.y + Math.sin(angle) * radius;

                        // 目標地点に向かって移動
                        const dx = targetX - enemy.x;
                        const dy = targetY - enemy.y;
                        enemy.x += Math.sign(dx);
                        enemy.y += Math.sign(dy);
                    }
                },

                ambush: (enemy, game) => {
                    // 待ち伏せ: 距離に応じて行動を変える
                    const dx = game.player.x - enemy.x;
                    const dy = game.player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 5) {
                        // 近距離: 急速接近
                        if (Math.random() > 0.5) {
                            game.moveEnemyTowardsPlayer(enemy);
                            enemy.x += Math.sign(dx);
                            enemy.y += Math.sign(dy);
                        }
                    } else {
                        // 遠距離: ゆっくり接近
                        if (Math.random() > 0.7) {
                            game.moveEnemyTowardsPlayer(enemy);
                        }
                    }
                }
            };

            executeEnemyAbility(enemy, ability) {
                const abilityData = this.enemyAbilities[ability];
                if (!abilityData) return;

                const timer = enemy.abilityTimers[ability] || 0;
                if (timer <= 0) {
                    abilityData.execute(enemy, this);
                    enemy.abilityTimers[ability] = abilityData.cooldown;
                } else {
                    enemy.abilityTimers[ability]--;
                }
            }

            addDashEffects(enemy, startX, startY, finalX, finalY, dashDistance) {
                // moveSpeedに基づいてダッシュ距離を計算
                const baseDashDistance = 5; // 基本ダッシュ距離
                const speedMultiplier = enemy.moveSpeed / 10; // moveSpeedを正規化
                const actualDashDistance = Math.round(baseDashDistance * (1 + speedMultiplier));

                // 残像エフェクト
                const numberOfAfterImages = Math.min(5, Math.ceil(actualDashDistance / 2));
                for (let i = 1; i <= numberOfAfterImages; i++) {
                    const ratio = i / (numberOfAfterImages + 1);
                    const afterImageX = Math.round(startX + (finalX - startX) * ratio);
                    const afterImageY = Math.round(startY + (finalY - startY) * ratio);

                    // エフェクト生成時に必要な情報だけを保存
                    this.effects.push({
                        type: 'afterimage',
                        x: afterImageX,
                        y: afterImageY,
                        duration: 5,
                        symbol: enemy.symbol || '◆',  // デフォルト値を設定
                        baseColor: enemy.color || '#aa88ff',  // デフォルト値を設定
                        opacity: 0.7 - (ratio * 0.5),
                        tier: enemy.tier || 0
                    });
                }

                // 軌跡エフェクト
                const dashSymbols = ['╌', '┄', '┈', '═'];
                for (let i = 0; i < actualDashDistance; i++) {
                    const ratio = i / actualDashDistance;
                    const effectX = Math.round(startX + (finalX - startX) * ratio);
                    const effectY = Math.round(startY + (finalY - startY) * ratio);

                    this.effects.push({
                        type: 'dash_trail',
                        x: effectX,
                        y: effectY,
                        duration: 3,
                        symbol: dashSymbols[Math.floor(Math.random() * dashSymbols.length)],
                        opacity: 0.6 - (ratio * 0.4)
                    });
                }
            }

            renderEnemy(enemy) {
                // enemyType が undefined の場合のフォールバック
                const enemyType = this.enemyTypes[enemy.type] || this.enemyTypes.grunt;
                const glowIntensity = Math.min((enemy.tier || 0) * 2, 20);
                const color = this.tierColors[enemy.type][Math.min(enemy.tier || 0, this.tierColors[enemy.type].length - 1)];

                return `<span class="enemy" style="color: ${color}; text-shadow: 0 0 ${glowIntensity}px ${color}">${enemyType.symbol}</span>`;
            }
            // ダメージ計算などでの PlayerStats の使用例
            calculateDamage(damageObj) {
                const stats = this.player.stats;
                const variationRange = damageObj.base * damageObj.variationPercent;
                const variation = (Math.random() * 2 - 1) * variationRange;
                const baseDamage = Math.max(1, Math.round(damageObj.base + variation));

                // PlayerStats の damageMultiplier を使用
                return Math.round(baseDamage * stats.damageMultiplier * stats.globalDamageMultiplier);
            }

            isCriticalHit(additionalChance = 0) {
                const stats = this.player.stats;
                const totalChance = stats.criticalChance + (additionalChance * 0.5);
                return Math.random() < totalChance;
            }

            // 回避判定での PlayerStats の使用例
            checkDodge() {
                return this.player.stats.checkDodge(this.gameTime, 0);
            }

            // ダメージ適用メソッドの更新
            applyDamage(enemy, damageObj, isSplash = false, forceCrit = false) {
                const stats = this.player.stats;
                const baseDamage = this.calculateDamage(damageObj);

                // クリティカル判定を PlayerStats から取得
                const isCrit = forceCrit || Math.random() < stats.criticalChance;
                const critMultiplier = isCrit ? stats.criticalMultiplier : 1.0;
                const finalDamage = Math.round(baseDamage * critMultiplier * stats.globalDamageMultiplier);

                const oldHealth = enemy.health;
                enemy.health -= Math.round(finalDamage);
                const actualDamage = oldHealth - Math.max(0, enemy.health);
                if (actualDamage > 0) {
                    if (isCrit) {
                        // クリティカルヒットのポップアップ
                        this.addDamagePopup(enemy.x, enemy.y, actualDamage, {
                            color: '#ff0000',
                            scale: 3,
                            text: `${actualDamage}`,
                            style: `
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000,
                        0 0 20px #ff0000,
                        0 0 30px #ff0000,
                        2px 2px 2px rgba(0,0,0,0.5);
            font-weight: bold;
        `,
                            className: 'critical'  // クラス名を追加
                        });

                        // クリティカルヒットエフェクトを追加（エフェクトは敵の位置に）
                        this.effects.push({
                            type: 'critical',
                            x: enemy.x,
                            y: enemy.y,
                            frames: [
                                ['✦', '★', '✦'],
                                ['★', '✯', '★'],
                                ['✦', '★', '✦']
                            ],
                            colors: ['#ff0000', '#ff4400', '#ff8800'],
                            glowIntensity: [20, 15, 10],
                            currentFrame: 0,
                            duration: 10
                        });
                    } else if (isSplash) {
                        // スプラッシュダメージの表示
                        this.addDamagePopup(enemy.x, enemy.y, actualDamage, {
                            color: '#88ccff',
                            scale: 0.6,
                            text: actualDamage.toString(),
                            style: 'text-shadow: 0 0 5px #4488ff'
                        });
                    } else {
                        // 通常ダメージの表示
                        this.addDamagePopup(enemy.x, enemy.y, actualDamage, {
                            color: '#ffff00',
                            scale: 1.0,
                            text: actualDamage.toString(),
                            style: 'text-shadow: 0 0 5px #888800'
                        });
                    }

                    // ダメージエフェクトの追加
                    this.damagedEnemies.push({
                        x: enemy.x,
                        y: enemy.y,
                        duration: isCrit ? 4 : 2,
                        intensity: isCrit ? 1.5 : 1.0
                    });
                }

                return actualDamage;
            }

            updatePopupContainer() {
                const popupContainer = document.querySelector('.popup-container');
                if (!popupContainer) return;

                const gameElement = document.getElementById('game');
                if (!gameElement) return;

                const gameRect = gameElement.getBoundingClientRect();
                const scale = gameRect.width / (this.width * this.cellWidth);

                // ポップアップコンテナのスタイル更新
                Object.assign(popupContainer.style, {
                    width: `${this.width * this.cellWidth * scale}px`,
                    height: `${this.height * this.cellHeight * scale}px`,
                    position: 'absolute',
                    top: '0',
                    left: '0',
                    pointerEvents: 'none'
                });
            }

            addDamagePopup(x, y, damage, style = {}) {
                // 既存の同じ位置・同じスタイルのポップアップを探す
                const existingPopup = this.damagePopups.find(popup =>
                    popup.x === x &&
                    popup.y === y &&
                    popup.style?.color === style.color &&
                    popup.animating
                );

                if (existingPopup) {
                    // 既存のポップアップがある場合は合計値を更新
                    const newDamage = parseInt(existingPopup.damage) + parseInt(damage);
                    existingPopup.damage = newDamage;
                    existingPopup.duration = 5; // durationをリセット
                    existingPopup.element.textContent = style.text || newDamage.toString();

                    // スケールアニメーションを追加して更新を強調
                    existingPopup.element.style.transform = `scale(${(style.scale || 1) * 1.2})`;
                    setTimeout(() => {
                        if (existingPopup.element) {
                            existingPopup.element.style.transform = `scale(${style.scale || 1})`;
                        }
                    }, 100);

                    return;
                }

                // 新しいポップアップの作成（既存のコード）
                const { offsetX, offsetY } = this.popupManager.calculatePopupPosition(x, y);
                const popupElement = document.createElement('div');
                popupElement.className = 'damage-popup';
                if (style.className) {
                    popupElement.classList.add(style.className);
                }
                popupElement.textContent = style.text || damage.toString();

                // スタイルの適用
                if (style.color) {
                    popupElement.style.color = style.color;
                }
                if (style.scale && style.scale !== 1.0) {
                    popupElement.style.transform = `scale(${style.scale})`;
                }
                if (style.style) {
                    const styles = style.style.split(';')
                        .filter(s => s.trim())
                        .reduce((acc, curr) => {
                            const [key, value] = curr.split(':').map(s => s.trim());
                            if (key && value) {
                                acc[key] = value;
                            }
                            return acc;
                        }, {});

                    Object.assign(popupElement.style, styles);
                }

                // 位置の計算（オフセットを適用）
                const gameElement = document.getElementById('game');
                if (gameElement) {
                    const gameRect = gameElement.getBoundingClientRect();
                    const scale = gameRect.width / (this.width * this.cellWidth);

                    const posX = (x + offsetX) * this.cellWidth * scale;
                    const posY = (y + offsetY) * this.cellHeight * scale;

                    popupElement.style.left = `${posX}px`;
                    popupElement.style.top = `${posY}px`;
                }

                this.damagePopups.push({
                    x: x,
                    y: y,
                    damage: damage,
                    duration: 5,
                    element: popupElement,
                    animating: true,
                    style: style // スタイル情報を保存
                });

                // ポップアップ削除時の処理
                setTimeout(() => {
                    const popup = this.damagePopups.find(p => p.element === popupElement);
                    if (popup) {
                        popup.animating = false;
                    }
                    this.popupManager.removePopup(x, y);
                }, 1000);
            }

            checkCollisions() {
                // ジェム収集の判定
                this.gems = this.gems.filter(gem => {
                    const dx = this.player.x - gem.x;
                    const dy = this.player.y - gem.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= this.player.gemAttractionRange) {
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length > 0) {
                            const normalizedDx = dx / length;
                            const normalizedDy = dy / length;
                            gem.exactX = (gem.exactX || gem.x) + normalizedDx;
                            gem.exactY = (gem.exactY || gem.y) + normalizedDy;
                            gem.x = Math.round(gem.exactX);
                            gem.y = Math.round(gem.exactY);
                        }
                    }

                    if (gem.x === this.player.x && gem.y === this.player.y) {
                        const newExp = this.player.exp + gem.value;

                        if (newExp >= this.player.expToLevel) {
                            while (newExp >= this.player.expToLevel) {
                                const currentLevelExp = this.player.expToLevel;
                                this.levelUp();
                                this.player.exp = newExp - currentLevelExp;
                            }
                        } else {
                            this.player.exp = newExp;
                        }

                        this.addGemCollectEffect(gem);
                        return false;
                    }
                    return true;
                });

                // オービタルブレードの衝突判定
                this.projectiles.forEach(proj => {
                    if (proj.type === 'orbit' || proj.type === 'orbit-trail') {
                        this.enemies.forEach((enemy, index) => {
                            // ユニークエネミーの自己ダメージを防ぐ
                            if (enemy.isUnique && proj.owner === 'unique_enemy' && proj.sourceId === enemy.id) {
                                return; // この敵へのダメージ判定をスキップ
                            }

                            // 前回の位置も考慮した軌跡上での判定
                            const prevX = proj.x - Math.cos(this.weapons.orbit.angle) * this.weapons.orbit.radius;
                            const prevY = proj.y - Math.sin(this.weapons.orbit.angle) * this.weapons.orbit.radius;

                            const distance = this.pointToLineSegmentDistance(
                                enemy.x, enemy.y,
                                prevX, prevY,
                                proj.x, proj.y
                            );

                            if (distance < 1.2) {
                                const damageObj = {
                                    base: proj.damage.base,
                                    variationPercent: proj.damage.variationPercent
                                };
                                const actualDamage = enemy.isUnique ?
                                    enemy.takeDamage(damageObj.base) :
                                    this.applyDamage(enemy, damageObj);

                                if (actualDamage > 0 && this.weapons.orbit.splashCooldown <= 0) {
                                    // スプラッシュダメージの処理
                                    this.enemies.forEach((targetEnemy, targetIndex) => {
                                        if (targetIndex !== index) {
                                            const splashDx = targetEnemy.x - enemy.x;
                                            const splashDy = targetEnemy.y - enemy.y;
                                            const splashDistance = Math.sqrt(splashDx * splashDx + splashDy * splashDy);

                                            if (splashDistance <= this.weapons.orbit.damageRadius) {
                                                const splashDamageObj = {
                                                    base: proj.splashDamage.base,
                                                    variationPercent: proj.splashDamage.variationPercent
                                                };
                                                this.applyDamage(targetEnemy, splashDamageObj, true);
                                            }
                                        }
                                    });

                                    // スプラッシュエフェクト
                                    this.effects.push({
                                        type: 'areaAttack',
                                        x: enemy.x,
                                        y: enemy.y,
                                        radius: this.weapons.orbit.damageRadius,
                                        duration: 10,
                                        currentFrame: 0,
                                        frames: [
                                            ['○', '◎', '●'],
                                            ['◇', '◆', '◈'],
                                            ['※', '⁂', '☆']
                                        ],
                                        colors: ['#88ccff', '#44aaff', '#2288ff'],
                                        glowIntensity: [15, 10, 5]
                                    });

                                    this.weapons.orbit.splashCooldown = this.weapons.orbit.maxSplashCooldown;
                                }

                                if (enemy.health <= 0) {
                                    if (enemy.isUnique) {
                                        enemy.onDeath();
                                    }
                                    this.handleEnemyDeath(enemy, index);
                                }
                            }
                        });
                    }
                });

                // アクティブプロジェクタイルの衝突判定
                this.activeProjectiles = this.activeProjectiles.map(proj => {
                    if (!proj) return null;

                    this.enemies.forEach((enemy, index) => {
                        // ユニークエネミーの自己ダメージを防ぐ
                        if (enemy.isUnique && proj.owner === 'unique_enemy' && proj.sourceId === enemy.id) {
                            return; // この敵へのダメージ判定をスキップ
                        }

                        if (proj.type === 'laser' || proj.type === 'laser-energy') {
                            const currentX = Math.round(proj.x);
                            const currentY = Math.round(proj.y);
                            const prevX = currentX - Math.cos(proj.angle) * 0.5;
                            const prevY = currentY - Math.sin(proj.angle) * 0.5;

                            if (!proj.hasDealtDamage) {
                                const distance = this.pointToLineSegmentDistance(
                                    enemy.x, enemy.y,
                                    prevX, prevY,
                                    currentX, currentY
                                );

                                const weapon = this.weapons.laser;
                                const spreadWidth = weapon.spreadWidth * weapon.spreadLevel;
                                const hitRange = 1 + spreadWidth * (1 + (Math.min(weapon.spreadLevel + 1, Math.floor((proj.maxDuration - proj.duration) / 2)) * 0.1));

                                if (distance <= hitRange) {
                                    const damageFalloff = 1 - (distance / hitRange);
                                    let damageDealt = this.calculateDamage(proj.damage);
                                    damageDealt = Math.round(damageDealt * damageFalloff);

                                    const isCrit = this.isCriticalHit(0.15);
                                    const damageObj = {
                                        base: damageDealt,
                                        variationPercent: proj.damage.variationPercent
                                    };

                                    const actualDamage = enemy.isUnique ?
                                        enemy.takeDamage(damageObj.base) :
                                        this.applyDamage(enemy, damageObj, false, isCrit);

                                    if (actualDamage > 0) {
                                        this.effects.push({
                                            type: 'laser_hit',
                                            x: enemy.x,
                                            y: enemy.y,
                                            duration: 3,
                                            frames: [['※', '◆'], ['◇', '※'], ['◆', '◇']],
                                            currentFrame: 0,
                                            color: proj.type === 'laser' ? '#ff99ff' : '#bb99ff'
                                        });

                                        proj.hasDealtDamage = true;
                                    }

                                    if (enemy.health <= 0) {
                                        if (enemy.isUnique) {
                                            enemy.onDeath();
                                        }
                                        this.handleEnemyDeath(enemy, index);
                                    }
                                }
                            }
                        } else if (proj.type === 'missile') {
                            const distance = this.pointToLineSegmentDistance(
                                enemy.x, enemy.y,
                                proj.x, proj.y,
                                proj.x + Math.cos(proj.angle) * proj.speed,
                                proj.y + Math.sin(proj.angle) * proj.speed
                            );

                            if (distance < 1.5 && !proj.hasHit) {
                                // ユニークエネミーの自己ダメージを防ぐ
                                if (enemy.isUnique && proj.owner === 'unique_enemy' && proj.sourceId === enemy.id) {
                                    return; // この敵へのダメージ判定をスキップ
                                }

                                // 直撃ダメージの処理
                                const actualDamage = enemy.isUnique ?
                                    enemy.takeDamage(proj.damage.base) :
                                    this.applyDamage(enemy, proj.damage);

                                if (actualDamage > 0) {
                                    // 爆発エフェクトを生成
                                    this.createExplosionAtPoint(
                                        Math.round(proj.x),
                                        Math.round(proj.y),
                                        proj.splashRadius,
                                        proj.splashDamage
                                    );

                                    // 範囲ダメージの処理
                                    this.enemies.forEach((splashTarget, splashIndex) => {
                                        if (splashIndex !== index) {  // 直撃対象以外の敵に対して
                                            // ソースチェックを追加
                                            if (splashTarget.isUnique && proj.owner === 'unique_enemy' && proj.sourceId === splashTarget.id) {
                                                return; // 自分自身へのスプラッシュダメージをスキップ
                                            }

                                            const splashDx = splashTarget.x - Math.round(proj.x);
                                            const splashDy = splashTarget.y - Math.round(proj.y);
                                            const splashDistance = Math.sqrt(splashDx * splashDx + splashDy * splashDy);

                                            if (splashDistance <= proj.splashRadius) {
                                                const splashDamageObj = {
                                                    base: proj.splashDamage.base,
                                                    variationPercent: proj.splashDamage.variationPercent
                                                };

                                                const splashDamage = splashTarget.isUnique ?
                                                    splashTarget.takeDamage(splashDamageObj.base) :
                                                    this.applyDamage(splashTarget, splashDamageObj, true);

                                                if (splashTarget.health <= 0) {
                                                    if (splashTarget.isUnique) {
                                                        splashTarget.onDeath();
                                                    }
                                                    this.handleEnemyDeath(splashTarget, splashIndex);
                                                }
                                            }
                                        }
                                    });

                                    // 直撃したミサイルのフラグを設定
                                    proj.hasHit = true;
                                }

                                // 直撃対象の死亡判定
                                if (enemy.health <= 0) {
                                    if (enemy.isUnique) {
                                        enemy.onDeath();
                                    }
                                    this.handleEnemyDeath(enemy, index);
                                }
                            }
                        }
                    });

                    return proj.hasHit ? null : proj;
                }).filter(proj => proj !== null);
            }

            processOrbitSplashDamage(sourceEnemy, sourceIndex) {
                this.weapons.orbit.splashActive = true;

                this.enemies.forEach((targetEnemy, targetIndex) => {
                    if (targetIndex !== sourceIndex) {
                        const splashDistance = this.pointToLineSegmentDistance(
                            targetEnemy.x, targetEnemy.y,
                            sourceEnemy.x, sourceEnemy.y,
                            sourceEnemy.x, sourceEnemy.y  // 点として扱う場合は同じ座標を指定
                        );

                        if (splashDistance <= this.weapons.orbit.damageRadius) {
                            const splashDamageObj = {
                                base: this.weapons.orbit.splashDamage.base,
                                variationPercent: this.weapons.orbit.splashDamage.variationPercent
                            };
                            this.applyDamage(targetEnemy, splashDamageObj, true);
                        }
                    }
                });

                this.weapons.orbit.splashCooldown = this.weapons.orbit.maxSplashCooldown;
            }

            pointToLineSegmentDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;

                if (lenSq !== 0) {
                    param = dot / lenSq;
                }

                let xx, yy;

                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }

                const dx = px - xx;
                const dy = py - yy;

                return Math.sqrt(dx * dx + dy * dy);
            }

            triggerDamageFlash() {
                const overlay = document.getElementById('damageFlashOverlay');
                if (overlay) {
                    // 現在のアニメーションをリセット
                    overlay.classList.remove('active');
                    void overlay.offsetWidth; // リフロー強制
                    overlay.classList.add('active');
                }
            }

            checkEnemyPlayerCollision(enemy) {
                const dx = enemy.x - this.player.x;
                const dy = enemy.y - this.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 1.0) {
                    const currentTime = this.gameTime;
                    const lastDamageTime = enemy.lastDamageTime || 0;
                    const damageInterval = 3;

                    if (currentTime - lastDamageTime >= damageInterval) {
                        // 回避判定
                        if (Math.random() < this.player.stats.finalDodgeChance) {
                            // 基本のドッジエフェクト
                            this.effects.push({
                                type: 'dodge',
                                x: this.player.x,
                                y: this.player.y,
                                currentFrame: 0,
                                duration: 5,
                                frames: [
                                    ['∵'],
                                    ['∴'],
                                    ['∷'],
                                    ['∵'],
                                    ['∴']
                                ],
                                color: '#88ffff',
                                opacity: 0.8
                            });

                            // 波動エフェクト
                            const numWaves = 8;
                            for (let i = 0; i < numWaves; i++) {
                                const angle = (Math.PI * 2 * i) / numWaves;
                                const radius = 2;
                                this.effects.push({
                                    type: 'dodge_wave',
                                    x: this.player.x + Math.cos(angle) * radius,
                                    y: this.player.y + Math.sin(angle) * radius,
                                    currentFrame: 0,
                                    duration: 10,
                                    frames: [['◇'], ['◆'], ['◈'], ['◆']],
                                    color: '#88ffff',
                                    opacity: 0.6,
                                    angle: angle
                                });
                            }

                            // DODGEテキストは一つだけ表示（ダメージポップアップとして）
                            this.addDamagePopup(
                                this.player.x,
                                this.player.y - 1,
                                'DODGE!',
                                {
                                    color: '#88ffff',
                                    scale: 1.2,
                                    text: 'DODGE!',
                                    style: `
                            color: #88ffff;
                            text-shadow: 0 0 10px #88ffff,
                                        0 0 20px #88ffff,
                                        2px 2px 2px rgba(0,0,0,0.5);
                            font-weight: bold;
                        `
                                }
                            );

                            return true; // 回避成功
                        }

                        // 回避失敗時は通常のダメージ処理
                        const damageRange = enemy.damage.base * enemy.damage.variationPercent;
                        const baseDamage = enemy.damage.base + (Math.random() * 2 - 1) * damageRange;
                        const finalDamage = Math.round(baseDamage * (1 + (enemy.tier || 0) * 0.2));

                        // プレイヤーへのダメージ適用
                        this.player.health -= Math.round(finalDamage / this.player.stats.defenseMultiplier);
                        enemy.lastDamageTime = currentTime;

                        // ダメージフラッシュ
                        this.triggerDamageFlash();

                        // プレイヤーへのダメージ表示
                        this.addDamagePopup(
                            this.player.x,
                            this.player.y,
                            finalDamage,
                            {
                                color: '#ff4444',
                                scale: 1.2,
                                text: `-${finalDamage}`
                            }
                        );

                        // 反射ダメージの処理
                        if (Math.random() < this.player.stats.reflectChance) {
                            const reflectDamage = Math.round(this.player.stats.reflectDamage);
                            enemy.health -= reflectDamage;

                            // 反射ダメージのエフェクト
                            this.effects.push({
                                type: 'reflect',
                                x: enemy.x,
                                y: enemy.y,
                                duration: 3,
                                frames: [['◇'], ['◆'], ['◈']],
                                color: '#4488ff',
                                opacity: 0.8
                            });

                            // 反射ダメージの数値表示
                            this.addDamagePopup(
                                enemy.x,
                                enemy.y,
                                reflectDamage,
                                {
                                    color: '#4488ff',
                                    scale: 1.0,
                                    text: `${reflectDamage}`
                                }
                            );

                            // 敵の死亡判定
                            if (enemy.health <= 0) {
                                this.handleEnemyDeath(enemy);
                            }
                        }
                    }
                }

                // ユニークエネミーとの衝突判定を追加
                for (const otherEnemy of this.enemies) {
                    if (otherEnemy.isUnique && otherEnemy !== enemy) {
                        const targetDx = otherEnemy.x - enemy.x;
                        const targetDy = otherEnemy.y - enemy.y;
                        const uniqueDistance = Math.sqrt(targetDx * targetDx + targetDy * targetDy);

                        if (uniqueDistance < 1.0) {
                            this.handleEnemyAttack(enemy, otherEnemy);
                            return true;
                        }
                    }
                }

                return distance < 1.0;
            }

            handleEnemyAttack(attacker, target) {
                const currentTime = this.gameTime;
                const lastDamageTime = attacker.lastDamageTime || 0;
                const damageInterval = 3;

                if (currentTime - lastDamageTime >= damageInterval) {
                    const damageRange = attacker.damage.base * attacker.damage.variationPercent;
                    const baseDamage = attacker.damage.base + (Math.random() * 2 - 1) * damageRange;
                    const finalDamage = Math.round(baseDamage * (1 + (attacker.tier || 0) * 0.2));

                    // ターゲットがプレイヤーかユニークエネミーかで処理を分岐
                    if (target === this.player) {
                        target.health -= Math.round(finalDamage / target.stats.defenseMultiplier);
                        this.triggerDamageFlash();
                    } else {
                        // ユニークエネミーへの攻撃
                        target.takeDamage(finalDamage, attacker);
                    }

                    // ダメージ表示
                    this.addDamagePopup(
                        target.x,
                        target.y,
                        finalDamage,
                        {
                            color: '#ff4444',
                            scale: 1.2,
                            text: `-${finalDamage}`
                        }
                    );

                    attacker.lastDamageTime = currentTime;
                }
            }

            addExplosion(explosion) {
                const explosionPatterns = [
                    ['※', '◆', '◇', '△', '▲'],  // パターン1
                    ['✺', '✹', '✸', '✶', '✴'],   // パターン2
                    ['❋', '❊', '❉', '❈', '❇'],   // パターン3
                    ['⚡', '☆', '★', '✯', '✮']    // パターン4
                ];

                this.explosions.push({
                    x: explosion.x,
                    y: explosion.y,
                    radius: explosion.radius,
                    duration: explosion.duration || 5,
                    pattern: explosionPatterns[Math.floor(Math.random() * explosionPatterns.length)],
                    frame: 0
                });
            }

            createExplosionAtPoint(x, y, radius, splashDamage) {
                // 爆発エフェクトを追加
                this.addExplosion({
                    x: x,
                    y: y,
                    radius: radius,
                    duration: 3
                });

                // 範囲内の敵にダメージを与える
                this.enemies.forEach((enemy, index) => {
                    const dx = x - enemy.x;
                    const dy = y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= radius) {
                        // 距離に応じたダメージ計算
                        const damageMultiplier = 1 - (distance / radius); // 距離による減衰
                        const calculatedDamage = {
                            base: Math.round(splashDamage.base * Math.max(0.5, damageMultiplier)),
                            variationPercent: splashDamage.variationPercent
                        };

                        // スプラッシュダメージを適用
                        const actualDamage = this.applyDamage(enemy, calculatedDamage, true);

                        if (actualDamage > 0) {
                            // ダメージエフェクトとポップアップを追加
                            this.addDamagePopup(
                                enemy.x,
                                enemy.y,
                                actualDamage,
                                {
                                    color: '#ff9966',
                                    scale: 0.9,
                                    text: actualDamage.toString(),
                                    style: 'text-shadow: 0 0 5px #ff6600;'
                                }
                            );

                            this.damagedEnemies.push({
                                x: enemy.x,
                                y: enemy.y,
                                duration: 2,
                                intensity: damageMultiplier
                            });
                        }

                        // 敵の死亡判定
                        if (enemy.health <= 0) {
                            this.handleEnemyDeath(enemy, index);
                        }
                    }
                });

                // 爆発の視覚効果を強化
                const explosionColors = ['#ff6600', '#ff3300', '#ff0000'];
                const explosionSymbols = ['※', '◆', '◇', '△', '▲'];

                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i) / 8;
                    for (let r = 1; r <= radius; r++) {
                        const effectX = Math.round(x + Math.cos(angle) * r);
                        const effectY = Math.round(y + Math.sin(angle) * r);

                        this.effects.push({
                            type: 'explosion',
                            x: effectX,
                            y: effectY,
                            duration: 3 + Math.random() * 2,
                            symbol: explosionSymbols[Math.floor(Math.random() * explosionSymbols.length)],
                            color: explosionColors[Math.floor(Math.random() * explosionColors.length)],
                            opacity: 1 - (r / radius)
                        });
                    }
                }
            }

            // ミサイル爆発時にスプラッシュdurationを設定
            createMissileExplosion(missile) {
                this.addExplosion({
                    x: Math.round(missile.x),
                    y: Math.round(missile.y),
                    radius: missile.splashRadius,
                    duration: this.weapons.missile.splashDuration  // 設定したsplashDurationを使用
                });

                // スプラッシュ範囲内の敵にダメージを与える
                this.enemies.forEach((enemy, index) => {
                    const dx = Math.round(missile.x) - enemy.x;
                    const dy = Math.round(missile.y) - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= missile.splashRadius) {
                        const oldHealth = enemy.health;
                        enemy.health -= missile.splashDamage;

                        const actualDamage = oldHealth - Math.max(0, enemy.health);
                        if (actualDamage > 0) {
                            this.addDamagePopup(enemy.x, enemy.y, actualDamage);

                            // ダメージエフェクトを追加
                            this.damagedEnemies.push({
                                x: enemy.x,
                                y: enemy.y,
                                duration: 3
                            });
                        }

                        if (enemy.health <= 0) {
                            this.addDeathEffect(enemy.x, enemy.y);
                            this.gems.push({ x: enemy.x, y: enemy.y, value: 1 });
                            this.enemies.splice(index, 1);
                            this.score += 100;
                        }
                    }
                });
            }

            // addDeathEffect メソッドを追加（または修正）
            addDeathEffect(x, y) {
                //console.log("Death effect added at", x, y); // デバッグ用
                const effectPatterns = [
                    // 爆発パターン1
                    [
                        ['×'],
                        ['╋', '┼'],
                        ['╬', '═', '║']
                    ],
                    // 爆発パターン2: 円形の広がり
                    [
                        ['◇'],
                        ['◆', '◇'],
                        ['※', '◆', '◇']
                    ],
                    // 爆発パターン3: 星型の爆発
                    [
                        ['＊'],
                        ['★', '＊'],
                        ['✦', '★', '＊']
                    ],
                    // 爆発パターン4: 幾何学的なパターン
                    [
                        ['○'],
                        ['◎', '○'],
                        ['●', '◎', '○']
                    ]
                ];
                // ランダムにパターンを選択
                const selectedPattern = effectPatterns[Math.floor(Math.random() * effectPatterns.length)];

                this.effects.push({
                    x: x,
                    y: y,
                    frames: selectedPattern,
                    currentFrame: 0,
                    duration: 6
                });
            }

            update() {
                if (!this.gameStarted) return;

                // プレイヤーの死亡判定を最初に行う
                if (this.player.health <= 0) {
                    this.handlePlayerDeath();
                    return;
                }

                // プレイヤーのターンではない時の更新処理
                if (!this.isPlayerTurn) {
                    this.gameTime++;

                    // 武器の更新
                    this.updateWeapons();

                    this.uniqueEnemySystem.update();

                    // 敵の生成（5フレームごと）
                    if (this.gameTime % 5 === 0) {
                        this.spawnEnemy();
                    }

                    // 敵の移動
                    this.moveEnemies();

                    // 衝突判定
                    this.checkCollisions();

                    // 全ての敵との衝突判定を毎フレーム行う
                    this.enemies.forEach(enemy => {
                        this.checkEnemyPlayerCollision(enemy);
                    });

                    // アクティブなプロジェクタイルの更新
                    if (this.activeProjectiles && this.activeProjectiles.length > 0) {
                        this.activeProjectiles = this.activeProjectiles.filter(proj => {
                            if (!proj) return false;

                            switch (proj.type) {
                                case 'laser':
                                case 'laser-energy':
                                    proj.duration--;
                                    if (proj.maxDuration) {
                                        proj.opacity = Math.max(0.2, proj.duration / proj.maxDuration);
                                    }
                                    return proj.duration > 0;

                                case 'missile':
                                    if (!proj.trail) proj.trail = [];
                                    proj.trail.push({ x: proj.x, y: proj.y });
                                    if (proj.trail.length > 5) {
                                        proj.trail.shift();
                                    }

                                    const dx = proj.targetX - proj.x;
                                    const dy = proj.targetY - proj.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);

                                    let shouldExplode = false;

                                    // 敵との衝突判定
                                    for (const enemy of this.enemies) {
                                        const enemyDx = enemy.x - Math.round(proj.x);
                                        const enemyDy = enemy.y - Math.round(proj.y);
                                        const enemyDist = Math.sqrt(enemyDx * enemyDx + enemyDy * enemyDy);

                                        if (enemyDist < 1.2) {
                                            shouldExplode = true;
                                            break;
                                        }
                                    }

                                    if (dist <= proj.speed || shouldExplode) {
                                        this.createExplosionAtPoint(
                                            Math.round(proj.x),
                                            Math.round(proj.y),
                                            proj.splashRadius,
                                            proj.splashDamage
                                        );
                                        return false;
                                    } else {
                                        proj.x += (dx / dist) * proj.speed;
                                        proj.y += (dy / dist) * proj.speed;
                                        return true;
                                    }

                                default:
                                    return true;
                            }
                        });
                    }
                }

                if (this.gameTime >= this.nextDangerLevelChange) {
                    this.updateDangerLevel();
                    this.nextDangerLevelChange = this.gameTime + 300; // 次の変更タイミングを設定
                }

                // ポータルタイマーの更新
                if (this.isPortalActive) {
                    this.portalTimer--;

                    // プレイヤーがポータル範囲内にいる場合のみ帰還
                    if (this.portalTimer <= 0 && this.isPlayerInPortal()) {
                        this.isPortalActive = false;
                        this.addPortalEffect(this.player.x, this.player.y, 'close');

                        // HP全回復とエフェクト表示
                        const healAmount = this.player.maxHealth - this.player.health;
                        if (healAmount > 0) {
                            this.player.health = this.player.maxHealth;

                            // 回復エフェクトの追加
                            this.addDamagePopup(
                                this.player.x,
                                this.player.y,
                                healAmount,
                                {
                                    color: '#00ff00',
                                    scale: 1.2,
                                    text: `+${healAmount}`,
                                    style: `
                                color: #00ff00;
                                text-shadow: 0 0 10px #00ff00,
                                            0 0 20px #00ff00;
                                font-weight: bold;
                            `
                                }
                            );

                            // 回復時の視覚効果
                            for (let i = 0; i < 8; i++) {
                                const angle = (Math.PI * 2 * i) / 8;
                                for (let r = 1; r <= 3; r++) {
                                    const effectX = Math.round(this.player.x + Math.cos(angle) * r);
                                    const effectY = Math.round(this.player.y + Math.sin(angle) * r);

                                    this.effects.push({
                                        type: 'heal',
                                        x: effectX,
                                        y: effectY,
                                        duration: 10,
                                        frames: [['♥'], ['❤'], ['♥', '❤']],
                                        colors: ['#00ff99', '#00cc66', '#009933'],
                                        currentFrame: 0,
                                        opacity: 1 - (r / 4)
                                    });
                                }
                            }
                        }

                        this.gameState = 'home';
                        this.showHome();
                        return;
                    } else if (this.portalTimer <= 0) {
                        // 範囲外ならポータルをキャンセル
                        this.isPortalActive = false;
                        this.portalPosition = null;
                        this.portalEffects = [];
                        return;
                    }

                    // ポータルパーティクルエフェクト
                    if (this.portalTimer % 2 === 0) {
                        for (let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 * i / 8) + (this.portalTimer * 0.1);
                            const radius = 2;
                            const effectX = this.portalPosition.x + Math.cos(angle) * radius;
                            const effectY = this.portalPosition.y + Math.sin(angle) * radius;

                            this.effects.push({
                                type: 'portal_particle',
                                x: effectX,
                                y: effectY,
                                duration: 5,
                                symbol: ['∴', '∵', '∷'][Math.floor(Math.random() * 3)],
                                color: ['#4488ff', '#44aaff', '#44ddff'][Math.floor(Math.random() * 3)],
                                opacity: 0.8,
                                angle: angle
                            });
                        }
                    }
                }

                // エフェクトの更新
                if (this.effects && this.effects.length > 0) {
                    this.effects = this.effects.filter(effect => {
                        if (!effect) return false;

                        if (effect.currentFrame !== undefined) {
                            effect.currentFrame++;
                        }

                        if (effect.duration === undefined) {
                            effect.duration = 5;
                        }

                        switch (effect.type) {
                            case 'dodge':
                            case 'dodge_wave':
                            case 'dodge_text':
                                effect.duration--;
                                return effect.duration > 0;
                            case 'afterimage':
                            case 'dash_trail':
                                effect.duration--;
                                effect.opacity = effect.opacity || 1;
                                effect.opacity = Math.max(0, effect.opacity - 0.1);
                                return effect.duration > 0 && effect.opacity > 0;

                            case 'split_path':
                                effect.duration--;
                                effect.opacity = effect.opacity || 1;
                                effect.opacity = Math.max(0, effect.opacity - 0.2);
                                return effect.duration > 0 && effect.opacity > 0;

                            case 'split_center':
                                if (effect.currentFrame < effect.frames.length) {
                                    effect.currentFrame++;
                                }
                                effect.duration--;
                                return effect.duration > 0;
                            case 'ripple':
                            case 'centerPulse':
                                effect.duration--;
                                if (effect.intensity !== undefined) {
                                    effect.intensity = Math.max(0, 1 - (effect.currentFrame / effect.duration));
                                }
                                return effect.duration > 0;

                            case 'areaAttack':
                                if (effect.currentFrame % 2 === 0 && effect.expandingSymbols) {
                                    const ringIndex = Math.floor(effect.currentFrame / 2);
                                    if (ringIndex < effect.expandingSymbols.length) {
                                        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                                            const distance = effect.radius * ((ringIndex + 1) / effect.expandingSymbols.length);
                                            const effectX = Math.round(effect.x + Math.cos(angle) * distance);
                                            const effectY = Math.round(effect.y + Math.sin(angle) * distance);

                                            if (effectX >= 0 && effectX < this.width &&
                                                effectY >= 0 && effectY < this.height) {
                                                this.effects.push({
                                                    type: 'single',
                                                    x: effectX,
                                                    y: effectY,
                                                    symbol: effect.expandingSymbols[ringIndex][
                                                        Math.floor(Math.random() * effect.expandingSymbols[ringIndex].length)
                                                    ],
                                                    duration: 3,
                                                    currentFrame: 0,
                                                    color: effect.colors[Math.min(ringIndex, effect.colors.length - 1)],
                                                    intensity: 1
                                                });
                                            }
                                        }
                                    }
                                }
                                effect.duration--;
                                return effect.duration > 0;

                            case 'split':
                                if (effect.currentFrame % 2 === 0) {
                                    const radius = effect.radius * (effect.currentFrame / effect.duration);
                                    if (effect.expandingSymbols) {
                                        const ringIndex = Math.min(
                                            Math.floor(effect.currentFrame / 3),
                                            effect.expandingSymbols.length - 1
                                        );
                                        const symbols = effect.expandingSymbols[ringIndex];

                                        for (let i = 0; i < 8; i++) {
                                            const angle = (Math.PI * 2 * i) / 8;
                                            const effectX = Math.round(effect.x + Math.cos(angle) * radius);
                                            const effectY = Math.round(effect.y + Math.sin(angle) * radius);

                                            if (effectX >= 0 && effectX < this.width &&
                                                effectY >= 0 && effectY < this.height) {
                                                this.effects.push({
                                                    type: 'single',
                                                    x: effectX,
                                                    y: effectY,
                                                    symbol: symbols[Math.floor(Math.random() * symbols.length)],
                                                    duration: 3,
                                                    color: effect.colors[Math.min(ringIndex, effect.colors.length - 1)],
                                                    opacity: 1 - (effect.currentFrame / effect.duration)
                                                });
                                            }
                                        }
                                    }
                                }
                                effect.duration--;
                                return effect.duration > 0;

                            case 'reflect':
                                effect.duration--;
                                effect.currentFrame = (effect.currentFrame || 0) + 1;
                                return effect.duration > 0;

                            // update()内のエフェクト処理部分に追加
                            case 'zigzag_trail':
                            case 'circular_trail':
                                effect.duration--;
                                effect.opacity = effect.opacity || 1;
                                effect.opacity = Math.max(0, effect.opacity - 0.2);
                                return effect.duration > 0 && effect.opacity > 0;

                            case 'critical':
                            case 'laser_hit':
                            case 'death':
                            case 'heal':
                            case 'levelup':
                            case 'levelup_text':
                            case 'knockback_trail':
                            case 'direct_hit':
                            case 'single':
                                effect.duration--;
                                return effect.duration > 0;

                            default:
                                effect.duration--;
                                return effect.duration > 0;
                        }
                    });

                    // エフェクトの数が多すぎる場合はクリーンアップ
                    if (this.effects.length > 1000) {
                        this.effects = this.effects.slice(0, 1000);
                    }
                }

                // ダメージポップアップの更新
                if (this.damagePopups && this.damagePopups.length > 0) {
                    this.damagePopups = this.damagePopups.filter(popup => {
                        if (!popup) return false;
                        popup.duration--;
                        if (popup.duration <= 0 && popup.element && popup.element.parentNode) {
                            popup.element.parentNode.removeChild(popup.element);
                        }
                        return popup.duration > 0;
                    });
                }

                // 爆発エフェクトの更新
                if (this.explosions && this.explosions.length > 0) {
                    this.explosions = this.explosions.filter(explosion => {
                        if (!explosion) return false;
                        explosion.frame = (explosion.frame || 0) + 1;
                        explosion.duration--;
                        return explosion.duration > 0;
                    });
                }

                // ダメージフラッシュの更新
                if (this.damageFlash > 0) {
                    this.damageFlash--;
                }

                // ダメージエフェクトの更新
                if (this.damagedEnemies && this.damagedEnemies.length > 0) {
                    this.damagedEnemies = this.damagedEnemies.filter(damaged => {
                        if (!damaged) return false;
                        damaged.duration--;
                        return damaged.duration > 0;
                    });
                }

                // 描画更新
                this.render();
                this.needsUpdate = false;

                // 移動ディレイの更新
                if (this.player.moveDelay > 0) {
                    this.player.moveDelay--;
                    if (this.player.moveDelay === 0) {
                        this.isPlayerTurn = true;
                    }
                }

                // レベルアップチェックを修正
                if (this.player.exp >= this.player.expToLevel && !this.isLevelingUp) {
                    this.isLevelingUp = true;  // レベルアップ処理中フラグを設定
                    this.levelUp().finally(() => {
                        this.isLevelingUp = false;  // レベルアップ処理完了後にフラグをリセット
                    });
                }

                // 自動セーブ (10秒ごと)
                if (this.gameTime % 10 === 0) {
                    this.saveGame();
                }
            }

            render() {
                // ゲーム状態に応じた表示制御
                switch (this.gameState) {
                    case 'title':
                        this.showTitle();
                        return;

                    case 'nameInput':
                    case 'statAllocation':
                        // PlayerSetup が処理するので何もしない
                        return;

                    case 'weaponSelect':
                        // showWeaponSelection は handleInput から呼ばれるので、
                        // render では何もしない
                        return;
                }

                if (!this.gameStarted) {
                    this.showWeaponSelection();
                    return;
                }

                // フレームの色を計算（メソッドの先頭で定義）
                const hpPercentage = this.player.health / this.player.maxHealth;
                let frameColor;

                // 5%以下で点滅する処理
                if (hpPercentage <= 0.05) {
                    // ゲームタイムを使用して点滅（5フレームごとに切り替え）
                    frameColor = this.gameTime % 10 < 5 ? '#ff0000' : '#660000';
                }
                // それ以外は段階的に色を変化
                else if (hpPercentage > 0.9) {
                    frameColor = '#00ff00'; // 鮮やかな緑（90-100%）
                } else if (hpPercentage > 0.7) {
                    frameColor = '#44ff44'; // 明るい緑（70-90%）
                } else if (hpPercentage > 0.5) {
                    frameColor = '#88ff88'; // 薄い緑（50-70%）
                } else if (hpPercentage > 0.4) {
                    frameColor = '#ffff44'; // 黄色（40-50%）
                } else if (hpPercentage > 0.3) {
                    frameColor = '#ffaa44'; // オレンジ（30-40%）
                } else if (hpPercentage > 0.2) {
                    frameColor = '#ff7744'; // 明るい赤（20-30%）
                } else if (hpPercentage > 0.1) {
                    frameColor = '#ff4444'; // 赤（10-20%）
                } else {
                    frameColor = '#ff0000'; // 鮮やかな赤（5-10%）
                }

                let display = '';

                // 上部の境界線を更新
                display += `<span class="border-corner" style="color: ${frameColor}">╔</span>`;
                for (let x = 0; x < this.width; x++) {
                    display += `<span class="border-top" style="color: ${frameColor}">═</span>`;
                }
                display += `<span class="border-corner" style="color: ${frameColor}">╗</span>\n`;

                // 100フレーム毎に背景を更新
                if (this.backgroundUpdateCounter <= 0) {
                    this.initializeBackgroundGrid();
                    this.backgroundUpdateCounter = 10;
                }
                this.backgroundUpdateCounter--;

                // メインのゲーム領域描画部分を修正
                for (let y = 0; y < this.height; y++) {
                    display += `<span class="border-left" style="color: ${frameColor}"></span>`;
                    for (let x = 0; x < this.width; x++) {
                        // 背景シンボルを配列から取得
                        let cell = `<span style="color: #222222">${this.backgroundGrid[y][x]}</span>`;
                        let rendered = false;

                        // ポータルの背景エフェクト（地形として描画）
                        if (!rendered) {
                            // プレイヤーのポータル
                            if (this.isPortalActive && this.portalPosition) {
                                const dx = x - this.portalPosition.x;
                                const dy = y - this.portalPosition.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);

                                if (distance <= 2 && distance > 0.8) { // 中心部分を除外
                                    const angle = Math.atan2(dy, dx);
                                    const isEdge = Math.abs(distance - 2) < 0.3;
                                    let symbol = isEdge ?
                                        ['◈', '◇', '◆'][Math.floor((this.gameTime % 15) / 5)] :
                                        ['∴', '∵', '∷'][Math.floor((this.gameTime % 15) / 5)];

                                    cell = `<span class="effect" style="
                            color: #4488ff;
                            text-shadow: 0 0 10px #4488ff;
                            opacity: ${isEdge ? 0.5 : 0.3}
                        ">${symbol}</span>`;
                                }
                            }

                            // ユニークエネミーのポータル
                            if (this.uniqueEnemySystem?.isPortalActive && this.uniqueEnemySystem.portalPosition) {
                                const dx = x - this.uniqueEnemySystem.portalPosition.x;
                                const dy = y - this.uniqueEnemySystem.portalPosition.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);

                                if (distance <= 2 && distance > 0.8) { // 中心部分を除外
                                    const isEdge = Math.abs(distance - 2) < 0.3;
                                    let symbol = isEdge ?
                                        ['◈', '◇', '◆'][Math.floor((this.gameTime % 15) / 5)] :
                                        ['∴', '∵', '∷'][Math.floor((this.gameTime % 15) / 5)];
                                    const color = isEdge ?
                                        this.uniqueEnemySystem.uniqueColor.primary :
                                        this.uniqueEnemySystem.uniqueColor.secondary;

                                    cell = `<span class="effect" style="
                            color: ${color};
                            text-shadow: 0 0 10px ${color};
                            opacity: ${isEdge ? 0.5 : 0.3}
                        ">${symbol}</span>`;
                                }
                            }
                        }

                        // エネミーの描画（通常の敵とユニークエネミー）
                        // render メソッド内の該当部分を修正
                        // 敵の描画部分（rendered が false で、enemies をチェックしている箇所）
                        if (!rendered && this.enemies) {
                            for (const enemy of this.enemies) {
                                if (x === Math.round(enemy.x) && y === Math.round(enemy.y)) {
                                    if (enemy.isUnique) {
                                        // ユニークエネミーの描画
                                        const glowIntensity = 10; // 基本の発光強度
                                        const pulseIntensity = Math.sin(this.gameTime * 0.2) * 0.3 + 0.7;
                                        cell = `<span class="enemy unique-enemy" style="
                    color: ${enemy.uniqueColor.primary};
                    text-shadow: 0 0 ${glowIntensity * pulseIntensity}px ${enemy.uniqueColor.primary},
                               0 0 ${glowIntensity * 0.5}px ${enemy.uniqueColor.secondary};
                    transform: scale(${1 + (pulseIntensity * 0.1)});
                    position: relative;
                    z-index: 2;
                ">${enemy.symbol}</span>`;
                                    } else {
                                        const enemyType = this.enemyTypes[enemy.type];
                                        if (enemyType) {
                                            const glowIntensity = Math.min((enemy.tier || 0) * 2, 20);
                                            const color = this.tierColors[enemy.type][Math.min(enemy.tier || 0, this.tierColors[enemy.type].length - 1)];

                                            // 通常の敵の描画（z-indexを追加）
                                            cell = `<span class="enemy" style="
                        color: ${color};
                        text-shadow: 0 0 ${glowIntensity}px ${color};
                        position: relative;
                        z-index: 2;
                    ">${enemyType.symbol}</span>`;
                                        }
                                    }
                                    rendered = true;
                                    break;
                                }
                            }
                        }

                        // プレイヤーの描画
                        if (!rendered && x === this.player.x && y === this.player.y) {
                            const playerColor = this.damageFlash > 0 ? '#ff4444' : '#5e9dea';
                            const playerGlow = this.damageFlash > 0 ? '0 0 10px #ff0000' : '0 0 10px #adcaee';
                            cell = `<span class="player" style="
                    color: ${playerColor};
                    text-shadow: ${playerGlow};
                    position: relative;
                    z-index: 2;
                ">@</span>`;
                            rendered = true;
                        }

                        if (!rendered && this.gameState === 'looking' &&
                            x === this.lookCursor.x && y === this.lookCursor.y) {
                            cell = `<span style="color: #ffff00; text-shadow: 0 0 5px #ffff00">X</span>`;
                            rendered = true;
                        }


                        // ポータルの中心エフェクト（キャラクターの上に描画）
                        if (!rendered) {
                            // プレイヤーのポータル中心
                            if (this.isPortalActive && this.portalPosition &&
                                x === this.portalPosition.x && y === this.portalPosition.y) {
                                cell = `<span class="effect" style="
                        color: #4488ff;
                        text-shadow: 0 0 15px #4488ff;
                        opacity: 0.7;
                        position: relative;
                        z-index: 1;
                    ">◎</span>`;
                            }

                            // ユニークエネミーのポータル中心
                            if (this.uniqueEnemySystem?.isPortalActive && this.uniqueEnemySystem.portalPosition &&
                                x === this.uniqueEnemySystem.portalPosition.x && y === this.uniqueEnemySystem.portalPosition.y) {
                                const color = this.uniqueEnemySystem.uniqueColor.primary;
                                cell = `<span class="effect" style="
                        color: ${color};
                        text-shadow: 0 0 15px ${color};
                        opacity: 0.7;
                        position: relative;
                        z-index: 1;
                    ">◎</span>`;
                            }
                        }

                        if (!rendered && this.effects && this.effects.length > 0) {
                            for (const effect of this.effects) {
                                if (!effect) continue;
                                switch (effect.type) {
                                    case 'dodge':
                                        if (x === effect.x && y === effect.y) {
                                            // 基本エフェクトのアニメーション
                                            const frameIndex = Math.floor(effect.currentFrame || 0);
                                            const frame = effect.frames[frameIndex];
                                            if (frame) {
                                                const opacity = 1 - (effect.currentFrame / effect.duration);
                                                cell = `<span class="effect" style="
                            color: ${effect.color};
                            text-shadow: 0 0 8px ${effect.color};
                            opacity: ${opacity * effect.opacity}
                        ">${Array.isArray(frame) ? frame[0] : frame}</span>`;
                                                rendered = true;
                                            }
                                        }
                                        break;

                                    case 'dodge_wave':
                                        if (Math.round(effect.x) === x && Math.round(effect.y) === y) {
                                            const frameIndex = Math.floor(effect.currentFrame / 2) % effect.frames.length;
                                            const frame = effect.frames[frameIndex];
                                            if (frame) {
                                                const opacity = Math.max(0, 1 - (effect.currentFrame / effect.duration));
                                                cell = `<span class="effect" style="
                color: ${effect.color || '#88ffff'};
                text-shadow: 0 0 ${8 * opacity}px ${effect.color || '#88ffff'};
                opacity: ${opacity * (effect.opacity || 1)};
                transform: scale(${1 + (0.5 * (1 - opacity))})
            ">${Array.isArray(frame) ? frame[0] : frame}</span>`;
                                                rendered = true;
                                            }
                                        }
                                        break;

                                    case 'dodge_text':
                                        if (x === effect.x && y === effect.y - 1) {  // テキストは少し上に表示
                                            const opacity = 1 - (effect.currentFrame / effect.duration);
                                            cell = `<span class="effect" style="
                        color: #88ffff;
                        text-shadow: 0 0 8px #88ffff;
                        opacity: ${opacity};
                        font-weight: bold;
                    ">DODGE!</span>`;
                                            rendered = true;
                                        }
                                        break;
                                }

                                if (effect.type === 'areaAttack') {
                                    const frameIndex = Math.floor(effect.currentFrame / 2);
                                    if (frameIndex < effect.frames.length) {
                                        const frame = effect.frames[frameIndex];
                                        const color = effect.colors[frameIndex];
                                        const glow = effect.glowIntensity[frameIndex];

                                        const offsetX = x - effect.x;
                                        const offsetY = y - effect.y;
                                        const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);

                                        if (distance <= effect.radius) {
                                            const symbolIndex = Math.floor(Math.random() * frame.length);
                                            const symbol = frame[symbolIndex];
                                            const opacity = 1 - (distance / effect.radius);

                                            cell = `<span class="effect" style="color: ${color}; text-shadow: 0 0 ${glow}px ${color}; opacity: ${opacity}">${symbol}</span>`;
                                            rendered = true;
                                            break;
                                        }
                                    }
                                }
                                else if (effect.type === 'reflect') {
                                    if (x === effect.x && y === effect.y) {
                                        const frameIndex = Math.floor(effect.currentFrame) % effect.frames.length;
                                        const symbol = effect.frames[frameIndex];
                                        const opacity = 1 - (effect.currentFrame / effect.duration);

                                        cell = `<span class="effect" style="
            color: ${effect.color};
            text-shadow: 0 0 ${effect.glowIntensity * opacity}px ${effect.color};
            opacity: ${opacity};
            transform: scale(${1 + (0.5 * (1 - opacity))})
        ">${symbol}</span>`;
                                        rendered = true;
                                        break;
                                    }
                                }
                                else if (effect.type === 'ripple') {
                                    const progress = effect.currentFrame / effect.duration;
                                    const currentRadius = effect.startRadius + (effect.endRadius - effect.startRadius) * progress;

                                    const dx = x - effect.x;
                                    const dy = y - effect.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);

                                    if (Math.abs(distance - currentRadius) < 0.5) {
                                        const opacity = 1 - progress;
                                        cell = `<span class="effect" style="
                    color: ${effect.color}; 
                    opacity: ${opacity}; 
                    text-shadow: 0 0 ${10 * (1 - progress)}px ${effect.color}
                ">${effect.symbol}</span>`;
                                        rendered = true;
                                    }
                                }
                                else if (effect.type === 'centerPulse') {
                                    if (x === effect.x && y === effect.y) {
                                        const frameIndex = Math.floor(effect.currentFrame / 2) % effect.symbols.length;
                                        const symbol = effect.symbols[frameIndex];
                                        const intensity = effect.intensity * (1 - effect.currentFrame / effect.duration);

                                        cell = `<span class="effect" style="
                    color: ${effect.color}; 
                    opacity: ${intensity}; 
                    text-shadow: 0 0 ${20 * intensity}px ${effect.color}
                ">${symbol}</span>`;
                                        rendered = true;
                                    }
                                }
                                else if (effect.type === 'critical') {
                                    if (effect.currentFrame % 2 === 0) {
                                        const dx = x - effect.x;
                                        const dy = y - effect.y;
                                        const distance = Math.sqrt(dx * dx + dy * dy);

                                        if (distance <= 1.5) {
                                            const frameIndex = Math.floor(effect.currentFrame / 2);
                                            if (frameIndex < effect.frames.length) {
                                                const frame = effect.frames[frameIndex];
                                                const symbolIndex = Math.floor(Math.random() * frame.length);
                                                const symbol = frame[symbolIndex];
                                                const opacity = 1 - (distance / 1.5);

                                                cell = `<span class="effect" style="
                            color: ${effect.colors[frameIndex]}; 
                            text-shadow: 0 0 ${effect.glowIntensity[frameIndex]}px ${effect.colors[frameIndex]}; 
                            opacity: ${opacity}
                        ">${symbol}</span>`;
                                                rendered = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                else if (effect.type === 'afterimage' && x === effect.x && y === effect.y) {
                                    const tierColors = [
                                        effect.baseColor,
                                        '#ff9999',
                                        '#ff4444',
                                        '#ff0000',
                                        '#ff0066',
                                        '#ff00cc',
                                        '#ff00ff',
                                        '#cc00ff',
                                        '#6600ff',
                                        '#0000ff'
                                    ];
                                    const color = tierColors[Math.min(effect.tier || 0, tierColors.length - 1)];
                                    const glowIntensity = Math.min(((effect.tier || 0) * 2), 20) * effect.opacity;

                                    cell = `<span class="enemy" style="
                color: ${color}; 
                text-shadow: 0 0 ${glowIntensity}px ${color}; 
                opacity: ${effect.opacity}
            ">${effect.symbol}</span>`;
                                    rendered = true;
                                    break;
                                }
                                else if (effect.type === 'dash_trail' && x === effect.x && y === effect.y) {
                                    cell = `<span class="effect" style="
                color: #6495ED; 
                text-shadow: 0 0 8px #4169E1; 
                opacity: ${effect.opacity}
            ">${effect.symbol}</span>`;
                                    rendered = true;
                                    break;
                                }
                                else if (effect.type === 'levelup' && x === effect.x && y === effect.y) {
                                    cell = `<span class="effect" style="
                color: ${effect.color};
                text-shadow: 0 0 ${20 * effect.intensity}px ${effect.color};
                opacity: ${effect.intensity}
            ">${effect.symbol}</span>`;
                                    rendered = true;
                                    break;
                                }
                                else if (effect.type === 'levelup_text' && x === effect.x && y === effect.y) {
                                    cell = `<span class="effect" style="
                color: ${effect.color};
                text-shadow: 0 0 ${15 * effect.intensity}px ${effect.color};
                opacity: ${effect.intensity};
                font-weight: bold;
                transform: scale(1.2);
            ">${effect.text}</span>`;
                                    rendered = true;
                                    break;
                                }
                                else if (effect.type === 'knockback_trail' && x === effect.x && y === effect.y) {
                                    cell = `<span class="effect" style="
                color: #4488ff;
                text-shadow: 0 0 8px #4488ff;
                opacity: ${effect.opacity}
            ">${effect.symbol}</span>`;
                                    rendered = true;
                                    break;
                                }
                                else if (effect.type === 'death' && x === effect.x && y === effect.y) {
                                    if (effect.frames) {
                                        const frameIndex = Math.min(
                                            Math.floor(effect.currentFrame),
                                            effect.frames.length - 1
                                        );
                                        if (effect.frames[frameIndex]) {
                                            const symbolIndex = Math.floor(Math.random() * effect.frames[frameIndex].length);
                                            cell = `<span class="effect" style="
                        color: #ff5555; 
                        text-shadow: 0 0 10px #ff0000
                    ">${effect.frames[frameIndex][symbolIndex]}</span>`;
                                            rendered = true;
                                            break;
                                        }
                                    }
                                }
                                else if (effect.type === 'split_trail') {
                                    const frameIndex = Math.floor(effect.currentFrame);
                                    if (effect.frames[frameIndex]) {
                                        cell = `<span class="effect" style="
            color: ${effect.color};
            opacity: ${effect.opacity};
            text-shadow: 0 0 8px ${effect.color}
        ">${effect.frames[frameIndex]}</span>`;
                                        rendered = true;
                                    }
                                }
                                else if (effect.type === 'split_center') {
                                    const frameIndex = Math.floor(effect.currentFrame);
                                    if (effect.frames[frameIndex]) {
                                        const symbols = effect.frames[frameIndex];
                                        const symbol = symbols[Math.floor(Math.random() * symbols.length)];
                                        cell = `<span class="effect" style="
            color: ${effect.color};
            transform: scale(${effect.scale});
            text-shadow: 0 0 15px ${effect.color}
        ">${symbol}</span>`;
                                        rendered = true;
                                    }
                                }
                                else if (effect.type === 'heal' && x === effect.x && y === effect.y) {
                                    const frameIndex = Math.floor(effect.currentFrame) % effect.frames.length;
                                    const frame = effect.frames[frameIndex];
                                    const symbol = Array.isArray(frame) ?
                                        frame[Math.floor(Math.random() * frame.length)] : frame;
                                    const color = effect.colors[frameIndex] || '#00ff99';

                                    cell = `<span class="effect" style="
                color: ${color}; 
                text-shadow: 0 0 10px ${color};
                opacity: ${1 - (effect.currentFrame / effect.duration)}
            ">${symbol}</span>`;
                                    rendered = true;
                                    break;
                                }
                                else if (x === effect.x && y === effect.y) {
                                    if (effect.frames) {
                                        const frameIndex = Math.min(
                                            Math.floor(effect.currentFrame),
                                            effect.frames.length - 1
                                        );
                                        if (effect.frames[frameIndex]) {
                                            const symbols = Array.isArray(effect.frames[frameIndex]) ?
                                                effect.frames[frameIndex] : [effect.frames[frameIndex]];
                                            const symbolIndex = Math.floor(Math.random() * symbols.length);
                                            const effectColor = effect.color || '#ff5555';
                                            const effectGlow = effect.glow || '0 0 10px #ff0000';

                                            cell = `<span class="effect" style="
                        color: ${effectColor}; 
                        text-shadow: ${effectGlow};
                        opacity: ${1 - (effect.currentFrame / effect.duration)}
                    ">${symbols[symbolIndex]}</span>`;
                                            rendered = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        if (!rendered) {
                            for (let proj of this.activeProjectiles) {
                                if (proj.x === x && proj.y === y) {
                                    // レーザーの描画処理を更新
                                    if (proj.type === 'laser' || proj.type === 'laser-energy') {
                                        if (proj.type === 'laser') {
                                            const angle = proj.angle;
                                            let symbol;

                                            // 角度に基づいてシンボルを選択（8方向）
                                            const PI = Math.PI;
                                            if (angle >= -PI / 8 && angle < PI / 8) {
                                                symbol = this.laserSymbols.horizontal;
                                            } else if (angle >= PI / 8 && angle < 3 * PI / 8) {
                                                symbol = this.laserSymbols.diagonalDown;
                                            } else if (angle >= 3 * PI / 8 && angle < 5 * PI / 8) {
                                                symbol = this.laserSymbols.vertical;
                                            } else if (angle >= 5 * PI / 8 && angle < 7 * PI / 8) {
                                                symbol = this.laserSymbols.diagonalUp;
                                            } else if (angle >= 7 * PI / 8 || angle < -7 * PI / 8) {
                                                symbol = this.laserSymbols.horizontal;
                                            } else if (angle >= -7 * PI / 8 && angle < -5 * PI / 8) {
                                                symbol = this.laserSymbols.diagonalDown;
                                            } else if (angle >= -5 * PI / 8 && angle < -3 * PI / 8) {
                                                symbol = this.laserSymbols.vertical;
                                            } else {
                                                symbol = this.laserSymbols.diagonalUp;
                                            }

                                            // メインのレーザービーム
                                            const fadeClass = proj.duration <= 1 ? 'projectile-laser-fade' : '';
                                            cell = `<span class="projectile projectile-laser ${fadeClass}" style="opacity: ${proj.opacity}">${symbol || '│'}</span>`;

                                            // スプレッドレベルに基づいてエフェクトを生成
                                            const currentSpreadWidth = this.weapons.laser.spreadWidth * this.weapons.laser.spreadLevel;
                                            const spreadSymbols = ['═', '║', '╱', '╲'];
                                            const maxSpreadLayers = this.weapons.laser.spreadLevel + 2;
                                            const spreadLayerCount = Math.min(maxSpreadLayers,
                                                Math.floor((proj.maxDuration - proj.duration) / 2));

                                            // 複数レイヤーのスプレッドエフェクト
                                            for (let i = 0; i < spreadLayerCount; i++) {
                                                const spreadSymbol = spreadSymbols[Math.floor(angle / (Math.PI / 2))] || '│';
                                                const layerSpread = currentSpreadWidth * ((i + 1) / spreadLayerCount);
                                                const baseScale = 1 + layerSpread;

                                                // 中心エフェクト
                                                cell += `<span class="projectile-laser-spread" 
            style="opacity: ${0.4 - (i * 0.1)}; 
            transform: scale(${baseScale})">${spreadSymbol}</span>`;

                                                // 左右のエフェクト（スプレッド幅に応じて）
                                                if (i > 0) {
                                                    const sideSpread = layerSpread * 0.5;
                                                    cell += `<span class="projectile-laser-spread" 
                style="opacity: ${0.3 - (i * 0.08)}; 
                transform: scale(${baseScale}) translateX(${-sideSpread}em)">${spreadSymbol}</span>`;
                                                    cell += `<span class="projectile-laser-spread" 
                style="opacity: ${0.3 - (i * 0.08)}; 
                transform: scale(${baseScale}) translateX(${sideSpread}em)">${spreadSymbol}</span>`;
                                                }
                                            }

                                            // エネルギー散乱エフェクト
                                            const energyChance = 0.3 + (this.weapons.laser.spreadLevel * 0.1);
                                            if (Math.random() < energyChance * proj.opacity) {
                                                const energySymbols = ['∴', '∵', '⋰', '⋱'];
                                                const numEnergy = Math.min(3, this.weapons.laser.spreadLevel);

                                                for (let i = 0; i < numEnergy; i++) {
                                                    const energySymbol = energySymbols[Math.floor(Math.random() * energySymbols.length)];
                                                    const spreadDistance = (Math.random() - 0.5) * currentSpreadWidth * 2;
                                                    const spreadAngle = Math.random() * Math.PI * 2;

                                                    cell += `<span class="projectile-laser-energy" 
                style="opacity: ${proj.opacity * 0.8};
                transform: translate(${Math.cos(spreadAngle) * spreadDistance}em, 
                                  ${Math.sin(spreadAngle) * spreadDistance}em)">${energySymbol}</span>`;
                                                }
                                            }
                                        } else if (proj.type === 'laser-energy') {
                                            const energySymbols = ['∴', '∵', '⋰', '⋱'];
                                            const energySymbol = energySymbols[Math.floor(Math.random() * energySymbols.length)] || '∴';
                                            cell = `<span class="projectile-laser-energy" style="opacity: ${proj.opacity}">${energySymbol}</span>`;
                                        }
                                        rendered = true;
                                        break;
                                    }
                                }
                            }
                        }

                        // 爆発エフェクトの描画
                        if (!rendered && this.explosions) {
                            for (const explosion of this.explosions) {
                                const dx = x - explosion.x;
                                const dy = y - explosion.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);

                                if (distance <= explosion.radius) {
                                    const frame = Math.floor((explosion.duration / 2) * (1 - distance / explosion.radius));
                                    const pattern = explosion.pattern;
                                    const symbol = pattern[Math.min(frame, pattern.length - 1)];
                                    const opacity = 1 - (distance / explosion.radius);

                                    if (distance === 0) {
                                        cell = `<span class="effect" style="
                    color: #ff5500; 
                    text-shadow: 0 0 10px #ff0000
                ">${symbol}</span>`;
                                    } else {
                                        cell = `<span class="effect" style="
                    opacity: ${opacity}; 
                    color: #ff3300
                ">${symbol}</span>`;
                                    }
                                    rendered = true;
                                    break;
                                }
                            }
                        }

                        // ダメージエフェクトの描画
                        if (!rendered && this.damagedEnemies) {
                            for (const damaged of this.damagedEnemies) {
                                if (x === damaged.x && y === damaged.y) {
                                    const intensity = damaged.intensity || 1.0;
                                    cell = `<span class="damage-effect" style="opacity: ${intensity}">✦</span>`;
                                    rendered = true;
                                    break;
                                }
                            }
                        }

                        // ジェムの描画
                        if (!rendered && this.gems) {
                            for (const gem of this.gems) {
                                if (x === gem.x && y === gem.y) {
                                    const pulseIntensity = Math.sin(this.gameTime * 0.2) * 0.3 + 0.7;
                                    const age = this.gameTime - gem.spawnTime;
                                    const fadeIn = Math.min(age / 5, 1);

                                    cell = `<span class="gem" style="
                            color: ${gem.color};
                            text-shadow: 0 0 ${10 * pulseIntensity}px ${gem.glow};
                            opacity: ${fadeIn};
                            transform: scale(${pulseIntensity});
                        ">${gem.symbol}</span>`;
                                    rendered = true;
                                    break;
                                }
                            }
                        }

                        // プロジェクタイルの描画
                        if (!rendered && this.projectiles) {
                            for (const proj of this.projectiles) {
                                if (Math.round(proj.x) === x && Math.round(proj.y) === y) {
                                    if (proj.type === 'orbit' || proj.type === 'orbit-trail') {
                                        const color = proj.owner === 'unique_enemy' ? proj.color : '#5e9dea';
                                        const glow = proj.owner === 'unique_enemy'
                                            ? `0 0 10px ${proj.effectColor}`
                                            : '0 0 10px #adcaee';

                                        cell = `<span class="projectile projectile-orbit" style="
                    color: ${color};
                    text-shadow: ${glow};
                    opacity: ${proj.opacity || 1}
                ">${proj.symbol}</span>`;
                                        rendered = true;
                                        break;
                                    }
                                }
                            }
                        }

                        // アクティブプロジェクタイルの描画
                        if (!rendered && this.activeProjectiles) {
                            for (const proj of this.activeProjectiles) {
                                if (Math.round(proj.x) === x && Math.round(proj.y) === y) {
                                    if (proj.type === 'laser' || proj.type === 'laser-energy') {
                                        const opacity = proj.opacity || 1;
                                        const fadeClass = proj.duration <= 1 ? 'projectile-laser-fade' : '';
                                        const color = proj.owner === 'unique_enemy' ? proj.color : '#ff74ff';
                                        const glow = proj.owner === 'unique_enemy'
                                            ? `0 0 10px ${proj.effectColor}, 0 0 20px ${proj.effectColor}`
                                            : '0 0 10px #ff00ff, 0 0 20px #ff00ff';

                                        cell = `<span class="projectile projectile-${proj.type} ${fadeClass}" style="
                    color: ${color};
                    text-shadow: ${glow};
                    opacity: ${opacity}
                ">${this.getLaserSymbol(proj.angle)}</span>`;
                                        rendered = true;
                                        break;
                                    } else if (proj.type === 'missile') {
                                        const mainX = Math.round(proj.x);
                                        const mainY = Math.round(proj.y);
                                        const color = proj.owner === 'unique_enemy' ? proj.color : '#ff6600';
                                        const glow = proj.owner === 'unique_enemy'
                                            ? `0 0 10px ${proj.effectColor}`
                                            : '0 0 10px #ff3300';

                                        if (x === mainX && y === mainY) {
                                            cell = `<span class="projectile projectile-missile" style="
                        color: ${color};
                        text-shadow: ${glow}
                    ">◆</span>`;
                                            rendered = true;
                                            break;
                                        }
                                        // 軌跡の描画
                                        if (proj.trail) {
                                            for (const point of proj.trail) {
                                                if (x === Math.round(point.x) && y === Math.round(point.y)) {
                                                    const trailSymbols = ['·', '∙', '°', '○', '◦'];
                                                    const symbol = trailSymbols[Math.floor(Math.random() * trailSymbols.length)];
                                                    cell = `<span class="projectile projectile-missile" style="
                                color: ${color};
                                text-shadow: ${glow};
                                opacity: 0.5
                            ">${symbol}</span>`;
                                                    rendered = true;
                                                    break;
                                                }
                                            }
                                        }
                                    } else if (proj.type === 'motorgun') {
                                        const color = proj.owner === 'unique_enemy' ? proj.color : '#ffaa44';
                                        const glowColor = proj.owner === 'unique_enemy' ? proj.effectColor : '#ff8800';

                                        // メインの弾の描画
                                        if (Math.round(proj.x) === x && Math.round(proj.y) === y) {
                                            const opacity = 1 - (proj.traveled / proj.range);
                                            cell = `<span class="projectile" style="
                        color: ${color};
                        text-shadow: 0 0 8px ${glowColor};
                        opacity: ${opacity}
                    ">•</span>`;
                                            rendered = true;
                                            break;
                                        }

                                        // 弾道の軌跡の描画
                                        if (proj.trail) {
                                            for (const point of proj.trail) {
                                                if (Math.round(point.x) === x && Math.round(point.y) === y) {
                                                    const trailOpacity = point.opacity || 0.5;
                                                    cell = `<span class="projectile" style="
                                color: ${color};
                                text-shadow: 0 0 5px ${glowColor};
                                opacity: ${trailOpacity}
                            ">·</span>`;
                                                    rendered = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        display += cell;
                    }
                    display += `<span class="border-right" style="color: ${frameColor}"></span>\n`;  // 右の境界
                }

                display += `<span class="border-corner" style="color: ${frameColor}">╚</span>`;
                for (let x = 0; x < this.width; x++) {
                    // EXPの進捗に基づいて色を計算
                    const expProgress = this.player.exp / this.player.expToLevel;
                    const progressPoint = x / this.width;
                    let borderColor;

                    if (progressPoint <= expProgress) {
                        // 進捗バーの色を緑に
                        borderColor = '#44ff44';
                    } else {
                        // 未到達部分は灰色に
                        borderColor = '#666666';
                    }

                    display += `<span class="border-bottom" style="color: ${borderColor}">═</span>`;
                }
                display += `<span class="border-corner" style="color: ${frameColor}">╝</span>`;


                // 表示を更新
                this.display.innerHTML = display;


                // ダメージポップアップの処理
                const existingContainer = document.querySelector('.popup-container');
                if (existingContainer) {
                    existingContainer.remove();
                }

                if (this.damagePopups && this.damagePopups.length > 0) {
                    const popupContainer = document.createElement('div');
                    popupContainer.className = 'popup-container';

                    // コンテナのスタイル設定
                    this.updatePopupContainer();

                    this.damagePopups.forEach(popup => {
                        if (popup.element) {
                            popupContainer.appendChild(popup.element);
                        }
                    });

                    this.display.appendChild(popupContainer);
                }

                let statusHTML = `
<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; margin-bottom: 5px; font-size: 9px;">
    <span style="color: #44ddff; padding: 4px;">
        Time: ${Math.floor(this.gameTime / 600)}:${String(Math.floor((this.gameTime % 600) / 10)).padStart(2, '0')}
    </span>
    <span style="color: #ffdd44; padding: 4px;">
        Score: ${this.score.toString().padStart(7, '0')}
    </span>
    <span style="color: ${this.dangerLevelColors[this.dangerLevel - 1]}; padding: 4px;">
        Threat: ${this.dangerLevelNames[this.dangerLevel - 1]}
    </span>
</div>
    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; margin-bottom: 5px; font-size: 9px;">
        <span style="color: #5e9dea; padding: 4px;">
            Player: ${this.player.name} (Lv.${this.player.level})
        </span>
        <span style="color: ${this.getHPColor()}; text-shadow: 0 0 5px rgba(255,255,255,0.5); padding: 4px;">
            HP: ${Math.round(this.player.health)}/${Math.round(this.player.maxHealth)}
        </span>
        <span style="color: #ffaa44; padding: 4px;">
            EXP: ${this.player.exp}/${this.player.expToLevel}
        </span>
    </div>
    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; font-size: 9px; margin-bottom: 5px;">
        <span style="color: #ff4444;  padding: 4px;">
            ATK: ${this.player.stats.ATK} (DMG: ${Math.round(this.player.stats.finalDamageMultiplier * 100)}%)
        </span>
        <span style="color: #44ff44;  padding: 4px;">
            DEF: ${this.player.stats.DEF} (Resist: ${Math.round((1 - 1 / this.player.stats.defenseMultiplier) * 100)}%)
        </span>
        <span style="color: #44ddff;  padding: 4px;">
            SPD: ${this.player.stats.SPD} (Dodge: ${Math.round(this.player.stats.finalDodgeChance * 100)}%)
        </span>
    </div>`;

                // 武器情報も同様に調整
                if (Object.values(this.weapons).some(w => w.active)) {
                    statusHTML += `<div style="margin-top: 4px; font-size: 9px; line-height: 1.4;">`;

                    // アクティブな武器の情報を表示
                    Object.entries(this.weapons).forEach(([type, weapon]) => {
                        if (weapon.active) {
                            switch (type) {
                                case 'orbit':
                                    statusHTML += `
                <div style="color: #44aaff;">
                    Orbital Blades | 
                    <span style="color: #ffaa44">Blades: ${weapon.projectiles}</span> | 
                    <span style="color: #44ffaa">Radius: ${weapon.radius}</span> | 
                    <span style="color: #ff44aa">Power: ${weapon.damage.base}</span>
                    ${weapon.splashCooldown > 0 ?
                                            ` | <span style="color: #ff4444">[SPLASH CD: ${weapon.splashCooldown}]</span>` :
                                            ''}
                </div>`;
                                    break;

                                case 'laser':
                                    const spreadLevel = weapon.spreadLevel;
                                    const cooldownStatus = weapon.cooldown > 0 ?
                                        ` | <span style="color: #ff4444">[CD: ${weapon.cooldown}]</span>` : '';
                                    statusHTML += `
                <div style="color: #ff77ff;">
                    Quantum Laser | 
                    <span style="color: #44ffaa">Spread: ${spreadLevel}/${weapon.maxSpreadLevel}</span> | 
                    <span style="color: #44aaff">Range: ${weapon.range}</span> | 
                    <span style="color: #ff44aa">Power: ${weapon.damage.base}</span>
                    ${cooldownStatus}
                </div>`;
                                    break;

                                case 'missile':
                                    const missileReady = weapon.cooldown === 0 ?
                                        '<span style="color: #44ff44">[READY]</span>' :
                                        `<span style="color: #ff4444">[CD: ${weapon.cooldown}]</span>`;
                                    statusHTML += `
                <div style="color: #ffaa44;">
                    Nova Missiles | 
                    <span style="color: #44ffaa">Count: ${weapon.projectiles}</span> | 
                    <span style="color: #44aaff">Radius: ${weapon.splashRadius}</span> | 
                    <span style="color: #ff44aa">Power: ${weapon.damage.base}</span> | 
                    ${missileReady}
                </div>`;
                                    break;

                                case 'motorgun':
                                    // 安定性の計算
                                    const stabilityRatio = weapon.stabilizationTime / weapon.maxStabilization;
                                    const stabilityColor = stabilityRatio > 0.8 ? '#44ff44' :
                                        stabilityRatio > 0.5 ? '#ffff44' : '#ff4444';

                                    // 弾薬状態の表示
                                    let ammoStatus;
                                    if (weapon.reloadCooldown > 0) {
                                        const reloadProgress = Math.floor(
                                            ((weapon.reloadTime - weapon.reloadCooldown) / weapon.reloadTime) * 100
                                        );
                                        ammoStatus = `<span style="color: #ff4444">[RELOAD: ${reloadProgress}%]</span>`;
                                    } else {
                                        const ammoColor = weapon.ammo < weapon.maxAmmo * 0.3 ? '#ff4444' :
                                            weapon.ammo < weapon.maxAmmo * 0.6 ? '#ffff44' : '#44ff44';
                                        ammoStatus = `<span style="color: ${ammoColor}">[${weapon.ammo}/${weapon.maxAmmo}]</span>`;
                                    }

                                    // 発射レートの表示（wait状態を考慮）
                                    const currentFireRate = Math.floor(
                                        (weapon.fireRate + (weapon.maxFireRate - weapon.fireRate) * stabilityRatio) *
                                        (this.player.moveDelay === 0 ? weapon.waitBonus : 1)
                                    );

                                    statusHTML += `
                <div style="color: #ffaa44;">
                    Motor Gun | 
                    <span style="color: ${stabilityColor}">Stability: ${Math.floor(stabilityRatio * 100)}%</span> | 
                    <span style="color: #44ffaa">Rate: ${currentFireRate}</span> | 
                    <span style="color: #ff44aa">Power: ${weapon.damage.base}</span> | 
                    ${ammoStatus}
                </div>`;
                                    break;
                            }
                        }
                    });

                    statusHTML += '</div>';
                }

                // ステータス表示を更新
                this.statsDisplay.innerHTML = statusHTML;
            }

            getHPColor() {
                const hpPercentage = this.player.health / this.player.maxHealth;

                if (hpPercentage > 0.7) {
                    return '#44ff44'; // 緑色（70%以上）
                } else if (hpPercentage > 0.4) {
                    return '#ffff44'; // 黄色（40-70%）
                } else if (hpPercentage > 0.2) {
                    return '#ffaa44'; // オレンジ（20-40%）
                } else {
                    // HPが20%以下の場合は点滅効果
                    return this.gameTime % 10 < 5 ? '#ff4444' : '#ff0000';
                }
            }

            // レーザーシンボルを取得するヘルパーメソッド
            getLaserSymbol(angle) {
                const PI = Math.PI;
                if (angle >= -PI / 8 && angle < PI / 8) return this.laserSymbols.horizontal;
                if (angle >= PI / 8 && angle < 3 * PI / 8) return this.laserSymbols.diagonalDown;
                if (angle >= 3 * PI / 8 && angle < 5 * PI / 8) return this.laserSymbols.vertical;
                if (angle >= 5 * PI / 8 && angle < 7 * PI / 8) return this.laserSymbols.diagonalUp;
                if (angle >= 7 * PI / 8 || angle < -7 * PI / 8) return this.laserSymbols.horizontal;
                if (angle >= -7 * PI / 8 && angle < -5 * PI / 8) return this.laserSymbols.diagonalDown;
                if (angle >= -5 * PI / 8 && angle < -3 * PI / 8) return this.laserSymbols.vertical;
                return this.laserSymbols.diagonalUp;
            }

            // ユニークエネミーの武器エフェクト描画用のヘルパーメソッド
            renderUniqueWeaponEffect(x, y, weapon, enemy, currentCell) {
                const baseColor = this.uniqueEnemySystem.uniqueColor.primary;
                const secondaryColor = this.uniqueEnemySystem.uniqueColor.secondary;

                switch (weapon.type) {
                    case 'orbit':
                        // オービタルブレードのエフェクト
                        const orbitPos = this.calculateOrbitPosition(enemy, weapon);
                        if (Math.round(orbitPos.x) === x && Math.round(orbitPos.y) === y) {
                            currentCell = `<span class="projectile projectile-orbit" style="
                    color: ${baseColor};
                    text-shadow: 0 0 10px ${secondaryColor};
                ">${weapon.symbol}</span>`;
                        }
                        break;

                    case 'laser':
                        // レーザーのエフェクト
                        if (weapon.active && weapon.beamPath) {
                            const isOnBeamPath = weapon.beamPath.some(point =>
                                Math.round(point.x) === x && Math.round(point.y) === y
                            );
                            if (isOnBeamPath) {
                                currentCell = `<span class="projectile projectile-laser" style="
                        color: ${baseColor};
                        text-shadow: 0 0 15px ${secondaryColor};
                        opacity: ${weapon.opacity || 0.8}
                    ">${this.getLaserSymbol(weapon.angle)}</span>`;
                            }
                        }
                        break;

                    case 'missile':
                        // ミサイルのエフェクト
                        if (weapon.missiles) {
                            const isOnMissilePath = weapon.missiles.some(missile =>
                                Math.round(missile.x) === x && Math.round(missile.y) === y
                            );
                            if (isOnMissilePath) {
                                currentCell = `<span class="projectile projectile-missile" style="
                        color: ${baseColor};
                        text-shadow: 0 0 12px ${secondaryColor};
                    ">◆</span>`;
                            }
                        }
                        break;
                }

                return currentCell;
            }

            // オービタルブレードの位置計算ヘルパー
            calculateOrbitPosition(enemy, weapon) {
                const angle = weapon.angle || 0;
                const radius = weapon.radius || 3;
                return {
                    x: enemy.x + Math.cos(angle) * radius,
                    y: enemy.y + Math.sin(angle) * radius
                };
            }
        }

        class PlayerSetup {
            constructor(game) {
                this.game = game;
                this.playerName = '';
                this.totalPoints = 30;
                this.remainingPoints = 30;
                this.stats = {
                    ATK: 0,
                    DEF: 0,
                    SPD: 0
                };
                this.selectedStat = 'ATK';
            }

            showNameInput() {
                const weaponSelect = document.getElementById('weapon-select');
                weaponSelect.style.display = 'flex';
                this.updateNameDisplay();
            }

            showStatAllocation() {
                const weaponSelect = document.getElementById('weapon-select');
                weaponSelect.style.display = 'flex';
                this.updateStatDisplay();
            }

            handleNameInput(key) {
                if (this.playerName.length < 15) {
                    this.playerName += key;
                    this.updateNameDisplay();
                }
            }

            handleNameBackspace() {
                this.playerName = this.playerName.slice(0, -1);
                this.updateNameDisplay();
            }

            handleStatSelection(key) {
                const stats = ['ATK', 'DEF', 'SPD'];
                const currentIndex = stats.indexOf(this.selectedStat);
                const newIndex = (currentIndex + (key === 'ArrowDown' ? 1 : -1) + 3) % 3;
                this.selectedStat = stats[newIndex];
                this.updateStatDisplay();
            }

            handleStatAdjustment(key) {
                if (key === 'ArrowLeft' && this.stats[this.selectedStat] > 0) {
                    // 1ポイントだけ減少
                    this.stats[this.selectedStat]--;
                    this.remainingPoints++;
                } else if (key === 'ArrowRight' && this.remainingPoints > 0) {
                    // 1ポイントだけ増加
                    this.stats[this.selectedStat]++;
                    this.remainingPoints--;
                }
                this.updateStatDisplay();
            }

            updateNameDisplay() {
                const weaponSelect = document.getElementById('weapon-select');
                const display = [
                    "",
                    "      === CHARACTER CREATION ===",
                    "",
                    "      Enter Your Name:",
                    "",
                    `      > ${this.playerName}_`,
                    "",
                    "      (Press Enter to confirm)",
                    "",
                    "      Maximum 15 characters",
                    ""
                ].join('\n');

                const preElement = document.createElement('pre');
                preElement.className = 'weapon-select';
                preElement.style.backgroundColor = 'rgb(24, 24, 24)';
                preElement.style.padding = '2em';
                preElement.style.borderRadius = '8px';
                preElement.style.color = '#5e9dea';
                preElement.innerHTML = display;

                weaponSelect.innerHTML = '';
                weaponSelect.appendChild(preElement);
            }

            getStatDescription(stat) {
                switch (stat) {
                    case 'ATK':
                        return '(Increases damage dealt)';
                    case 'DEF':
                        return '(Reduces damage taken)';
                    case 'SPD':
                        return '(Improves movement and dodge)';
                    default:
                        return '';
                }
            }

            getStatsEffectDescription() {
                const speedMultiplier = 1.0 + (this.stats.SPD * 0.03);
                const moveDelay = Math.max(2, Math.round(10 / speedMultiplier));

                return {
                    damageMultiplier: (1.0 + (this.stats.ATK * 0.015)).toFixed(2),
                    defenseMultiplier: (1.0 + (this.stats.DEF * 0.008)).toFixed(2),
                    moveSpeed: `${Math.min(8, 3 * speedMultiplier).toFixed(2)} (Delay: ${moveDelay})`
                };
            }

            updateStatDisplay() {
                const weaponSelect = document.getElementById('weapon-select');
                const effects = this.getStatsEffectDescription();

                const display = [
                    "",
                    `      === CHARACTER CREATION - ${this.playerName} ===`,
                    "",
                    "      Allocate your starting stats (Remaining Points: " + this.remainingPoints + ")",
                    "      Use ↑↓ to select stat, ←→ to adjust points, Enter to confirm",
                    "",
                    `      ATK: ${this.stats.ATK.toString().padStart(2)} ${this.selectedStat === 'ATK' ? '◄' : ' '} ${this.getStatDescription('ATK')}`,
                    `      DEF: ${this.stats.DEF.toString().padStart(2)} ${this.selectedStat === 'DEF' ? '◄' : ' '} ${this.getStatDescription('DEF')}`,
                    `      SPD: ${this.stats.SPD.toString().padStart(2)} ${this.selectedStat === 'SPD' ? '◄' : ' '} ${this.getStatDescription('SPD')}`,
                    "",
                    "      Current Effects:",
                    `      • Damage Multiplier: ${effects.damageMultiplier}x`,
                    `      • Damage Reduction: ${effects.defenseMultiplier}x`,
                    `      • Move Speed: ${effects.moveSpeed}`,
                    "",
                    this.remainingPoints === 0 ? "      Press Enter to continue" : "      Allocate all points to continue",
                    ""
                ].join('\n');

                const preElement = document.createElement('pre');
                preElement.className = 'weapon-select';
                preElement.style.backgroundColor = 'rgb(24, 24, 24)';
                preElement.style.padding = '2em';
                preElement.style.borderRadius = '8px';
                preElement.style.color = '#5e9dea';
                preElement.innerHTML = display;

                weaponSelect.innerHTML = '';
                weaponSelect.appendChild(preElement);
            }

            applyStats() {
                //console.log('Applying initial stats:', this.stats);

                // PlayerStatsインスタンスを更新
                this.game.player.name = this.playerName;
                this.game.player.stats = new PlayerStats(); // 新しいインスタンスを作成

                // 基本ステータスを設定
                this.game.player.stats.ATK = this.stats.ATK;
                this.game.player.stats.DEF = this.stats.DEF;
                this.game.player.stats.SPD = this.stats.SPD;

                // 派生ステータスを更新
                this.game.player.stats.updateDerivedStats();

                // プレイヤーの基本属性を更新されたPlayerStatsから取得
                this.game.player.maxHealth = this.game.player.stats.maxHealth;
                this.game.player.health = this.game.player.maxHealth;
                this.game.player.moveSpeed = this.game.player.stats.moveSpeed;
                this.game.player.moveDelay = this.game.player.stats.moveDelay;
                this.game.player.gemAttractionRange = this.game.player.stats.gemAttractionRange;

                console.log('Player stats after initialization:', {
                    name: this.game.player.name,
                    stats: {
                        ATK: this.game.player.stats.ATK,
                        DEF: this.game.player.stats.DEF,
                        SPD: this.game.player.stats.SPD
                    },
                    derived: {
                        health: this.game.player.health,
                        moveSpeed: this.game.player.moveSpeed,
                        moveDelay: this.game.player.moveDelay
                    }
                });

                // weapon-select コンテナをクリア
                const weaponSelect = document.getElementById('weapon-select');
                weaponSelect.innerHTML = '';

                // 次の状態に移行
                this.game.gameState = 'weaponSelect';

                // 少し遅延を入れて武器選択画面を表示
                setTimeout(() => {
                    this.game.showWeaponSelection();
                }, 100);
            }
        }

        class PlayerStats {
            constructor() {
                // 基本ステータス
                this.ATK = 5;
                this.DEF = 5;
                this.SPD = 5;

                // HP関連
                this.maxHealth = 100;
                this.health = this.maxHealth; // healthをmaxHealthと同値に設定
                this.hpGrowthRate = 1.0;

                // 移動関連
                this.baseDelay = 6;
                this.moveSpeed = 5;
                this.moveDelay = 2;
                this.gemAttractionRange = 2;

                // ダメージ関連 - 初期値を調整
                this.damageMultiplier = 1.05;     // ATK 5で105%
                this.globalDamageMultiplier = 1.0;
                this.defenseMultiplier = 1.053;    // 1/(1-0.05) ≈ 1.053

                // クリティカル関連
                this.criticalChance = 0.05;      // SPD 5で5%
                this.criticalMultiplier = 1.5;

                // 反射ダメージ関連
                this.reflectDamage = 2;
                this.reflectChance = 0.05;       // DEF 5で5%
                this.reflectCooldown = 0;
                this.reflectCooldownMax = 5;
                this.reflectRadius = 1;

                // 回避関連
                this.baseDodgeChance = 0.05;     // SPD 5で5%
                this.dodgeChance = 0.05;
                this.consecutiveDodgeDebuff = 0;
                this.maxConsecutiveDodges = 3;
                this.dodgeCooldown = 0;
                this.dodgeCooldownMax = 5;
            }

            updateDerivedStats() {
                this.calculateStatBalance();

                // ATKの影響 - ダメージを10ポイントで110%に調整
                const atkPenalty = Math.pow(this.ATK / 35, 1.1);
                this.damageMultiplier = 1.0 + (this.ATK * 0.01) * (1 - this.overspecializationPenalty);
                this.defenseReduction = 1.0 + (this.ATK * 0.005);

                // DEFの影響 - 10ポイントで軽減率35%（regist 10%）に調整
                const defPenalty = Math.pow(this.DEF / 45, 1.1);
                const baseDefMultiplier = 1.0;
                const defBonus = this.DEF * 0.01; // 1ポイントあたり1%のresist
                this.defenseMultiplier = 1 / (1 - defBonus);

                // 反射関連 - 10ポイントで10%に調整
                this.reflectDamage = (2 + this.DEF * 0.1) * (1 + this.statBalanceBonus);
                this.reflectChance = (0.0 + this.DEF * 0.01) * (1 + this.statBalanceBonus);

                // SPDの影響
                const spdBonus = 1.0 + (this.SPD * 0.03);
                const speedMultiplier = Math.max(1.3, spdBonus * (1 - defPenalty * 0.7));

                // 移動関連のステータス
                this.moveSpeed = Math.min(8, 5 + (speedMultiplier - 1) * 3);
                this.moveDelay = Math.max(2, Math.ceil(6 / speedMultiplier));

                // クリティカルと回避を10ポイントで10%に調整
                this.criticalChance = (0.0 + (this.SPD * 0.01)) * (1 + this.statBalanceBonus);
                this.dodgeChance = (0.0 + (this.SPD * 0.01)) *
                    (1 + this.statBalanceBonus - this.overspecializationPenalty);

                this.applyLimitsAndFinalCorrections();
            }

            applyLimitsAndFinalCorrections() {
                // 移動関連
                this.moveSpeed = Math.max(3.0, Math.min(8, this.moveSpeed));
                this.moveDelay = Math.max(2, Math.min(6, this.moveDelay));

                // 確率上限の調整
                this.criticalChance = Math.min(0.5, this.criticalChance);
                this.dodgeChance = Math.min(0.5, this.dodgeChance);
                this.reflectChance = Math.min(0.5, this.reflectChance);

                // 最終補正値
                this.finalDodgeChance = Math.max(0.0, Math.min(0.5, this.dodgeChance));
                this.finalDamageMultiplier = Math.max(1.0, Math.min(2.5, this.damageMultiplier));

                // HP関連
                this.maxHealth = Math.floor(this.maxHealth * (1 + this.statBalanceBonus));
                this.health = Math.min(this.health, this.maxHealth);
            }

            calculateStatBalance() {
                // ステータスの合計と平均を計算
                const totalStats = this.ATK + this.DEF + this.SPD;
                const avgStat = totalStats / 3;

                // 特化度の計算（標準偏差的なアプローチ）
                const variance = Math.pow(this.ATK - avgStat, 2) +
                    Math.pow(this.DEF - avgStat, 2) +
                    Math.pow(this.SPD - avgStat, 2);
                const specialization = Math.sqrt(variance / 3) / avgStat;

                // 特化ペナルティの計算（特化が強いほどペナルティ大）
                this.overspecializationPenalty = Math.min(0.3, specialization * 0.15);

                // バランスボーナスの計算（バランスが取れているほどボーナス大）
                this.statBalanceBonus = Math.max(0, 0.2 - specialization * 0.1);
            }

            checkDodge(currentTime, incomingDamage) {
                // クールダウン中は回避不可
                if (this.dodgeCooldown > 0) {
                    return { dodged: false, isPerfect: false };
                }

                // 回避判定
                const dodgeRoll = Math.random();
                if (dodgeRoll > this.finalDodgeChance) {
                    // 回避失敗時、連続カウントをリセット
                    this.dodgeStreak = 0;
                    this.consecutiveDodgeDebuff = 0;
                    return { dodged: false, isPerfect: false };
                }

                // 回避成功
                this.dodgeStreak++;

                // 連続回避によるデバフ計算
                if (this.dodgeStreak > this.maxConsecutiveDodges) {
                    this.consecutiveDodgeDebuff += 0.1; // 10%ずつ回避率減少
                }

                // 完全回避判定
                const timeSinceLastDodge = (currentTime - this.lastDodgeTime) / 10;
                const isPerfectDodge = timeSinceLastDodge >= this.perfectDodgeWindow;

                // クールダウンと最終時間の更新
                this.dodgeCooldown = this.dodgeCooldownMax;
                this.lastDodgeTime = currentTime;

                return {
                    dodged: true,
                    isPerfect: isPerfectDodge,
                    dodgeStreak: this.dodgeStreak
                };
            }

            // ダメージ計算メソッド
            calculateDamage(baseDamage) {
                let damage = baseDamage * this.finalDamageMultiplier;

                // クリティカルヒット判定
                if (Math.random() < this.criticalChance) {
                    damage *= 1.5;
                    return { damage, isCritical: true };
                }

                return { damage, isCritical: false };
            }

            calculateReflectDamage(enemyLevel) {
                if (this.reflectCooldown > 0 || Math.random() > this.reflectChance) {
                    return 0;
                }

                // 基本反射ダメージ + 敵レベルに応じたボーナス
                const baseDamage = this.reflectDamage * (1 + (enemyLevel * 0.1));
                // ±20%のランダム変動
                const variation = (Math.random() * 0.4 - 0.2);

                this.reflectCooldown = this.reflectCooldownMax;
                return Math.round(baseDamage * (1 + variation));
            }

            updateCooldowns() {
                if (this.reflectCooldown > 0) {
                    this.reflectCooldown--;
                }
                if (this.dodgeCooldown > 0) {
                    this.dodgeCooldown--;
                }
            }

            applyDodgeBonus(isPerfect) {
                if (isPerfect) {
                    // 完全回避ボーナス
                    return {
                        tempSpeedBoost: 1.5,      // 一時的な移動速度上昇
                        tempDodgeBoost: 0.1,      // 一時的な回避率上昇
                        duration: 30               // 3秒間（10フレーム/秒として）
                    };
                }
                return null;
            }

            calculateDamageTaken(incomingDamage) {
                // 回避判定
                if (Math.random() < this.finalDodgeChance) {
                    return { damage: 0, isDodged: true, reflectDamage: 0 };
                }

                // 反射判定
                const isReflected = Math.random() < this.reflectChance && this.reflectCooldown <= 0;

                // 防御による軽減
                const reducedDamage = incomingDamage / this.defenseMultiplier;

                if (isReflected) {
                    reflectDamage = this.reflectDamage;
                    // 反射エフェクトの生成を game クラスに委譲
                    if (this.game) {  // game参照があることを確認
                        this.game.effects.push({
                            type: 'reflect',
                            x: this.x,
                            y: this.y,
                            duration: 5,
                            frames: ['↖', '↗', '↘', '↙'],
                            currentFrame: 0,
                            color: '#88ffff',
                            glowIntensity: 10
                        });
                    }
                }

                return {
                    damage: reducedDamage,
                    isDodged: false,
                    reflectDamage: isReflected ? this.reflectDamage : 0
                };
            }

            // HP成長率の計算
            calculateHPGrowth(baseGrowth) {
                return baseGrowth * this.hpGrowthRate;
            }
        }

        class UpgradeOption {
            constructor(id, name, description, type, effect) {
                this.id = id;
                this.name = name;
                this.description = description;
                this.type = type;  // 'player' or 'weapon'
                this.effect = effect;  // 実際の効果を適用する関数
            }
        }

        class UpgradeSystem {
            constructor(game) {
                this.game = game;
                this.playerUpgrades = this.definePlayerUpgrades();
                this.weaponUpgrades = this.defineWeaponUpgrades();
                this.currentSelectionType = null;  // 'player', 'weapon', or 'new_weapon'
                this.selectedOptions = [];
            }

            definePlayerUpgrades() {
                return [
                    new UpgradeOption(
                        'atkUp',
                        'Attack Mastery',
                        () => {
                            // 現在の実際のATK値を取得
                            const currentATK = this.game.player.stats.ATK;
                            return `Increase ATK by 1 (Current: ${currentATK})`;
                        },
                        'player',
                        (player) => {
                            if (!(player.stats instanceof PlayerStats)) {
                                player.stats = new PlayerStats();
                            }
                            // ATKを1だけ増加
                            player.stats.ATK += 1;
                            player.stats.updateDerivedStats();
                            //('ATK upgraded to:', player.stats.ATK); // デバッグログ
                        }
                    ),
                    new UpgradeOption(
                        'defUp',
                        'Defense Mastery',
                        () => {
                            // 現在の実際のDEF値を取得
                            const currentDEF = this.game.player.stats.DEF;
                            return `Increase DEF by 1 (Current: ${currentDEF})`;
                        },
                        'player',
                        (player) => {
                            if (!(player.stats instanceof PlayerStats)) {
                                player.stats = new PlayerStats();
                            }
                            // DEFを1だけ増加
                            player.stats.DEF += 1;
                            player.stats.updateDerivedStats();
                            //console.log('DEF upgraded to:', player.stats.DEF); // デバッグログ
                        }
                    ),
                    new UpgradeOption(
                        'spdUp',
                        'Speed Mastery',
                        () => {
                            // 現在の実際のSPD値を取得
                            const currentSPD = this.game.player.stats.SPD;
                            return `Increase SPD by 1 (Current: ${currentSPD})`;
                        },
                        'player',
                        (player) => {
                            if (!(player.stats instanceof PlayerStats)) {
                                player.stats = new PlayerStats();
                            }
                            // SPDを1だけ増加
                            player.stats.SPD += 1;
                            player.stats.updateDerivedStats();
                            //  console.log('SPD upgraded to:', player.stats.SPD); // デバッグログ
                        }
                    ),
                    new UpgradeOption(
                        'gemAttraction',
                        'Magnetic Field',
                        () => {
                            const currentRange = this.game.player.gemAttractionRange || 1;
                            return `Increase gem attraction range by 1 (Current: ${currentRange})`;
                        },
                        'player',
                        (player) => {
                            if (!(player.stats instanceof PlayerStats)) {
                                player.stats = new PlayerStats();
                            }
                            // 宝石吸収範囲を1だけ増加
                            player.stats.gemAttractionRange += 1;
                            player.stats.updateDerivedStats();
                        }
                    )
                ];
            }

            defineWeaponUpgrades() {
                return {
                    orbit: [
                        new UpgradeOption(
                            'orbitDamage',
                            'Sharpened Blades',
                            'Increase orbital blade damage by 20%',
                            'weapon',
                            (weapon) => {
                                // デバッグログを追加
                                console.log('Before orbit damage upgrade:', weapon.damage.base);
                                weapon.damage.base = Math.round(weapon.damage.base * 1.2);
                                console.log('After orbit damage upgrade:', weapon.damage.base);
                            }
                        ),
                        new UpgradeOption(
                            'orbitSplashCooldown',
                            'Quick Splash',
                            'Reduce splash effect cooldown by 20%',
                            'weapon',
                            (weapon) => {
                                weapon.maxSplashCooldown = Math.max(2, Math.floor(weapon.maxSplashCooldown * 0.8));
                                console.log('Orbit splash cooldown reduced to:', weapon.maxSplashCooldown);
                            }
                        ),
                        new UpgradeOption(
                            'orbitSplash',
                            'Expanding Force',
                            'Increase splash damage by 25%',
                            'weapon',
                            (weapon) => {
                                // デバッグログを追加
                                console.log('Before splash damage upgrade:', weapon.splashDamage.base);
                                weapon.splashDamage.base = Math.round(weapon.splashDamage.base * 1.25);
                                console.log('After splash damage upgrade:', weapon.splashDamage.base);
                            }
                        ),
                        new UpgradeOption(
                            'orbitCount',
                            'Additional Blade',
                            'Add one more orbital blade (Max: 4)',
                            'weapon',
                            (weapon) => {
                                if (weapon.projectiles < 4) {
                                    weapon.projectiles++;
                                    console.log('Orbit blades increased to:', weapon.projectiles);
                                }
                            }
                        ),
                        new UpgradeOption(
                            'orbitRadius',
                            'Extended Reach',
                            'Increase orbital radius',
                            'weapon',
                            (weapon) => {
                                if (weapon.radius < 6) {
                                    weapon.radius++;
                                    console.log('Orbit radius increased to:', weapon.radius);
                                }
                            }
                        )
                    ],
                    missile: [
                        new UpgradeOption(
                            'missileDamage',
                            'Explosive Force',
                            'Increase missile damage by 20%',
                            'weapon',
                            (weapon) => {
                                console.log('Before missile damage upgrade:', weapon.damage.base);
                                weapon.damage.base = Math.round(weapon.damage.base * 1.2);
                                console.log('After missile damage upgrade:', weapon.damage.base);
                            }
                        ),
                        new UpgradeOption(
                            'missileCooldown',
                            'Rapid Launch',
                            'Reduce missile launch cooldown by 15%',
                            'weapon',
                            (weapon) => {
                                weapon.maxCooldown = Math.max(5, Math.floor(weapon.maxCooldown * 0.85));
                                console.log('Missile cooldown reduced to:', weapon.maxCooldown);
                            }
                        ),
                        new UpgradeOption(
                            'missileRadius',
                            'Devastating Blast',
                            'Increase explosion radius',
                            'weapon',
                            (weapon) => {
                                if (weapon.splashRadius < 5) {
                                    weapon.splashRadius++;
                                    weapon.splashDamage.base = Math.round(weapon.splashDamage.base * 1.1);
                                    console.log('Missile splash radius increased to:', weapon.splashRadius);
                                    console.log('Splash damage increased to:', weapon.splashDamage.base);
                                }
                            }
                        ),
                        new UpgradeOption(
                            'missileCount',
                            'Additional Missile',
                            'Add one more missile (Max: 6)',
                            'weapon',
                            (weapon) => {
                                if (!weapon.projectiles) weapon.projectiles = 1;
                                if (weapon.projectiles < 6) {
                                    weapon.projectiles++;
                                    console.log('Missile count increased to:', weapon.projectiles);
                                }
                            }
                        ),
                        new UpgradeOption(
                            'missileSpeed',
                            'Swift Strike',
                            'Increase missile speed by 25%',
                            'weapon',
                            (weapon) => {
                                weapon.speed = (weapon.speed || 0.5) * 1.25;
                                console.log('Missile speed increased to:', weapon.speed);
                            }
                        )
                    ],
                    laser: [
                        new UpgradeOption(
                            'laserDamage',
                            'Focused Beam',
                            'Increase laser damage by 20%',
                            'weapon',
                            (weapon) => {
                                console.log('Before laser damage upgrade:', weapon.damage.base);
                                weapon.damage.base = Math.round(weapon.damage.base * 1.2);
                                console.log('After laser damage upgrade:', weapon.damage.base);
                            }
                        ),
                        new UpgradeOption(
                            'laserSpread',
                            'Wider Beam',
                            'Increase spread effect',
                            'weapon',
                            (weapon) => {
                                if (weapon.spreadLevel < weapon.maxSpreadLevel) {
                                    weapon.spreadLevel++;
                                    weapon.spreadWidth += 0.05;
                                    console.log('Laser spread level increased to:', weapon.spreadLevel);
                                    console.log('Spread width increased to:', weapon.spreadWidth);
                                }
                            }
                        ),
                        new UpgradeOption(
                            'laserDuration',
                            'Sustained Beam',
                            'Increase laser duration by 8 frames (Max: 64)',
                            'weapon',
                            (weapon) => {
                                const maxDuration = 64;
                                if (weapon.duration < maxDuration) {
                                    weapon.duration += 8;
                                    console.log(`Laser duration increased: ${weapon.duration - 8} -> ${weapon.duration}`);
                                }
                            }
                        ),
                        new UpgradeOption(
                            'laserRange',  // 新しいアップグレードを追加
                            'Extended Beam',
                            'Increase laser range by 3 (Max: 25)',
                            'weapon',
                            (weapon) => {
                                const maxRange = 25;
                                if (weapon.range < maxRange) {
                                    const oldRange = weapon.range;
                                    weapon.range = Math.min(maxRange, weapon.range + 3);
                                    console.log(`Laser range increased: ${oldRange} -> ${weapon.range}`);
                                }
                            }
                        ),
                        new UpgradeOption(
                            'laserCooldown',
                            'Rapid Fire',
                            'Reduce laser cooldown by 15%',
                            'weapon',
                            (weapon) => {
                                weapon.maxCooldown = Math.max(5, Math.floor(weapon.maxCooldown * 0.85));
                                console.log('Laser cooldown reduced to:', weapon.maxCooldown);
                            }
                        )
                    ],
                    motorgun: [
                        new UpgradeOption(
                            'motorgunDamage',
                            'Enhanced Rounds',
                            'Increase motorgun damage by 20%',
                            'weapon',
                            (weapon) => {
                                console.log('Before motorgun damage upgrade:', weapon.damage.base);
                                weapon.damage.base = Math.round(weapon.damage.base * 1.2);
                                console.log('After motorgun damage upgrade:', weapon.damage.base);
                            }
                        ),
                        new UpgradeOption(
                            'motorgunReload',
                            'Quick Reload System',
                            'Decrease reload time by 20%',
                            'weapon',
                            (weapon) => {
                                const oldReloadTime = weapon.reloadTime;
                                // 最小リロード時間を15フレームに設定
                                weapon.reloadTime = Math.max(15, Math.floor(weapon.reloadTime * 0.8));
                                console.log(`Motorgun reload time reduced: ${oldReloadTime} -> ${weapon.reloadTime} frames`);

                                // 現在進行中のリロードにも効果を適用
                                if (weapon.reloadCooldown > 0) {
                                    weapon.reloadCooldown = Math.floor(weapon.reloadCooldown * 0.8);
                                }
                            }
                        ),
                        new UpgradeOption(
                            'motorgunStabilization',
                            'Stabilizer Enhancement',
                            'Reduce spread while stationary by 25%',
                            'weapon',
                            (weapon) => {
                                weapon.minSpread = Math.max(0.05, weapon.minSpread * 0.75);
                                console.log('Motorgun min spread reduced to:', weapon.minSpread);
                            }
                        ),
                        new UpgradeOption(
                            'motorgunRange',
                            'Extended Barrel',
                            'Increase range by 20%',
                            'weapon',
                            (weapon) => {
                                weapon.range = Math.min(20, Math.floor(weapon.range * 1.2));
                                console.log('Motorgun range increased to:', weapon.range);
                            }
                        ),
                        new UpgradeOption(
                            'motorgunProjectileSpeed',
                            'High Velocity Rounds',
                            'Increase projectile speed by 25%',
                            'weapon',
                            (weapon) => {
                                weapon.projectileSpeed = Math.min(1.5, weapon.projectileSpeed * 1.25);
                                console.log('Motorgun projectile speed increased to:', weapon.projectileSpeed);
                            }
                        )
                    ]
                };
            }

            showUpgradeSelection() {
                // 選択画面表示前に現在の状態を保存
                this.game.saveGame();

                // レベル5ごとの武器追加をスキップし、直接プレイヤーアップグレードを表示
                this.currentSelectionType = 'player';
                this.displayUpgradeOptions();
            }

            displayNewWeaponSelection() {
                const weaponSelect = document.getElementById('weapon-select');
                weaponSelect.style.display = 'flex';

                const unequippedWeapons = this.getUnequippedWeapons();
                let display = [
                    "",
                    "                  === NEW WEAPON UNLOCK ===",
                    "      Choose an additional weapon to add to your arsenal",
                    ""
                ];

                unequippedWeapons.forEach((weapon, index) => {
                    display.push(`      [${index + 1}] ${this.game.availableWeapons[weapon].name}`);
                    display.push(`          ${this.getWeaponAscii(weapon)}`);
                    display.push(`          ${this.game.availableWeapons[weapon].description}`);
                    display.push("");
                });

                display.push("      Press 1-" + unequippedWeapons.length + " to select your new weapon");
                display.push("");

                const preElement = document.createElement('pre');
                preElement.className = 'weapon-select';
                preElement.style.backgroundColor = 'rgb(24, 24, 24)';
                preElement.style.padding = '2em';
                preElement.style.borderRadius = '8px';
                preElement.innerHTML = display.join('\n');

                weaponSelect.innerHTML = '';
                weaponSelect.appendChild(preElement);

                // キー入力ハンドラーを設定
                const handleNewWeaponSelection = (event) => {
                    const key = event.key;
                    const index = parseInt(key) - 1;

                    if (index >= 0 && index < unequippedWeapons.length) {
                        // キーハンドラーを削除
                        document.removeEventListener('keydown', handleNewWeaponSelection);

                        // 新しい武器を追加
                        this.addNewWeapon(unequippedWeapons[index]);
                    }
                };

                // 既存のキーハンドラーを削除（もしあれば）
                document.removeEventListener('keydown', handleNewWeaponSelection);
                // 新しいキーハンドラーを追加
                document.addEventListener('keydown', handleNewWeaponSelection);
            }

            getUnequippedWeapons() {
                const weaponTypes = ['orbit', 'laser', 'missile'];
                const activeWeaponsCount = Object.values(this.game.weapons).filter(w => w.active).length;

                // 装備可能な残りスロット数がある場合のみ、未装備の武器を返す
                if (activeWeaponsCount < 3) {
                    return weaponTypes.filter(type => !this.game.weapons[type]?.active);
                }
                return [];
            }

            getWeaponAscii(weaponType) {
                return this.game.availableWeapons[weaponType].ascii.join('\n          ');
            }

            displayUpgradeOptions() {
                const weaponSelect = document.getElementById('weapon-select');
                weaponSelect.style.display = 'flex';

                if (this.currentSelectionType === 'player') {
                    // プレイヤーアップグレードの表示
                    const options = this.getRandomPlayerUpgrades(3);
                    this.displayUpgradeMenu(options, 'PLAYER UPGRADE');
                } else {
                    // 武器選択画面を表示
                    const activeWeapons = this.getActiveWeapons();
                    this.displayWeaponSelectionMenu(activeWeapons);
                }
            }

            displayWeaponSelectionMenu(activeWeapons) {
                const display = [
                    "",
                    "      === WEAPON UPGRADE ===",
                    "      Choose a weapon to upgrade:",
                    ""
                ];

                activeWeapons.forEach((weapon, index) => {
                    display.push(`      [${index + 1}] ${weapon.name}`);
                    display.push(`          ${weapon.ascii.join('\n          ')}`);
                    display.push("");
                });

                display.push("      Press 1-" + activeWeapons.length + " to select weapon to upgrade");
                display.push("");

                const preElement = document.createElement('pre');
                preElement.className = 'weapon-select';
                preElement.style.backgroundColor = 'rgb(24, 24, 24)';
                preElement.style.padding = '2em';
                preElement.style.borderRadius = '8px';
                preElement.innerHTML = display.join('\n');

                const weaponSelect = document.getElementById('weapon-select');
                weaponSelect.innerHTML = '';
                weaponSelect.appendChild(preElement);

                // 武器選択のイベントリスナーを設定
                this.setupWeaponSelectionListener(activeWeapons);
            }

            setupWeaponSelectionListener(activeWeapons) {
                const handler = (event) => {
                    const key = event.key;
                    const index = parseInt(key) - 1;

                    if (index >= 0 && index < activeWeapons.length) {
                        document.removeEventListener('keydown', handler);
                        const selectedWeapon = activeWeapons[index];
                        this.displayWeaponUpgradeOptions(selectedWeapon.type);
                    }
                };
                document.addEventListener('keydown', handler);
            }

            displayWeaponUpgradeOptions(weaponType) {
                const upgrades = this.getRandomWeaponUpgrades(3, weaponType);
                this.displayUpgradeMenu(
                    upgrades,
                    `UPGRADE ${this.game.availableWeapons[weaponType].name.toUpperCase()}`
                );
            }

            getRandomPlayerUpgrades(count) {
                // 利用可能なアップグレードをフィルタリング
                const availableUpgrades = this.playerUpgrades.filter(upgrade => {
                    switch (upgrade.id) {
                        case 'critRate':
                            // クリティカル率が50%未満の場合のみ選択可能
                            return (this.game.player.criticalChance || 0.1) < 0.5;
                        case 'critDamage':
                            // クリティカルダメージが3.0未満の場合のみ選択可能
                            return (this.game.player.criticalMultiplier || 1.5) < 3.0;
                        case 'defense':
                            // 防御力が0.4より大きい場合のみ選択可能（これ以上の減衰は許可しない）
                            return (this.game.player.defense || 1.0) > 0.4;
                        default:
                            return true;
                    }
                });

                return this.shuffleArray([...availableUpgrades]).slice(0, Math.min(count, availableUpgrades.length));
            }


            getRandomWeaponUpgrades(count, weaponType) {
                // デバッグログを追加
                console.log(`Getting upgrades for ${weaponType}:`, this.game.weapons[weaponType]);

                const availableUpgrades = this.weaponUpgrades[weaponType].filter(upgrade => {
                    const weapon = this.game.weapons[weaponType];

                    // デバッグログ
                    console.log(`Checking upgrade ${upgrade.id}:`, {
                        projectiles: weapon.projectiles,
                        maxProjectiles: weapon.maxProjectiles
                    });

                    switch (upgrade.id) {
                        case 'orbitCount':
                            // オービタルブレードの枚数上限チェック
                            const canAddOrbit = weapon.projectiles < 4;
                            console.log('Can add orbit:', canAddOrbit);
                            return canAddOrbit;

                        case 'missileCount':
                            // ミサイルの数上限チェック
                            const canAddMissile = weapon.projectiles < 6;
                            console.log('Can add missile:', canAddMissile);
                            return canAddMissile;

                        case 'orbitRadius':
                            // 半径の上限チェック
                            return weapon.radius < (weapon.maxRadius || 6);

                        case 'missileRadius':
                            // 爆発範囲の上限チェック
                            return weapon.splashRadius < (weapon.maxSplashRadius || 5);

                        case 'laserSpread':
                            // レーザーの拡散レベル上限チェック
                            return weapon.spreadLevel < weapon.maxSpreadLevel;

                        default:
                            // その他のアップグレードは常に利用可能
                            return true;
                    }
                });

                // 利用可能なアップグレードの確認
                console.log(`Available upgrades for ${weaponType}:`, availableUpgrades);

                // 利用可能なアップグレードが0の場合は、基本的なアップグレードを追加
                if (availableUpgrades.length === 0) {
                    const defaultUpgrade = this.weaponUpgrades[weaponType].find(u => u.id === `${weaponType}Damage`);
                    if (defaultUpgrade) {
                        availableUpgrades.push(defaultUpgrade);
                    }
                }

                return this.shuffleArray([...availableUpgrades])
                    .slice(0, Math.min(count, availableUpgrades.length));
            }

            getActiveWeapons() {
                return Object.entries(this.game.weapons)
                    .filter(([_, weapon]) => weapon.active)
                    .map(([type, weapon]) => ({
                        type,
                        name: this.game.availableWeapons[type].name,
                        ascii: this.game.availableWeapons[type].ascii
                    }));
            }

            getActiveWeapon() {
                for (const [type, weapon] of Object.entries(this.game.weapons)) {
                    if (weapon.active) return { ...weapon, type };
                }
                return null;
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            setupKeyListener() {
                const handler = (event) => {
                    const key = event.key;
                    if (['1', '2', '3'].includes(key)) {
                        const index = parseInt(key) - 1;
                        if (index < this.selectedOptions.length) {
                            if (this.currentSelectionType === 'new_weapon') {
                                this.addNewWeapon(this.selectedOptions[index]);
                            } else {
                                this.applyUpgrade(this.selectedOptions[index]);
                            }
                            document.removeEventListener('keydown', handler);
                        }
                    }
                };
                document.addEventListener('keydown', handler);
            }


            addNewWeapon(weaponType) {
                console.log('Adding new weapon:', weaponType);

                // 武器の基本設定を適用
                this.game.weapons[weaponType] = {
                    ...this.game.availableWeapons[weaponType],
                    active: true
                };

                // 武器タイプ別の初期化処理
                this.game.weapons[weaponType] = {
                    ...this.game.weapons[weaponType],
                    ...this.game.availableWeapons[weaponType].defaults
                };

                // デバッグログ
                console.log(`Initialized ${weaponType} weapon:`, this.game.weapons[weaponType]);

                // 武器選択画面を閉じる
                document.getElementById('weapon-select').style.display = 'none';

                // ゲームを再開
                this.game.gameStarted = true;
                this.game.gameState = 'playing';
            }

            displayUpgradeMenu(options, title) {
                const display = [
                    "",
                    `      === ${title} ===`,
                    "      Choose your upgrade:",
                    ""
                ];

                options.forEach((option, index) => {
                    display.push(`      [${index + 1}] ${option.name}`);
                    // description が関数の場合は実行して文字列を取得
                    const description = typeof option.description === 'function'
                        ? option.description()
                        : option.description;
                    display.push(`          ${description}`);
                    display.push("");
                });

                display.push("      Press 1-" + options.length + " to select upgrade");
                display.push("");

                // 以下は変更なし
                const preElement = document.createElement('pre');
                preElement.className = 'weapon-select';
                preElement.style.backgroundColor = 'rgb(24, 24, 24)';
                preElement.style.padding = '2em';
                preElement.style.borderRadius = '8px';
                preElement.innerHTML = display.join('\n');

                const weaponSelect = document.getElementById('weapon-select');
                weaponSelect.innerHTML = '';
                weaponSelect.appendChild(preElement);

                this.selectedOptions = options;
                this.setupKeyListener();
            }

            // applyUpgrade を修正
            applyUpgrade(upgrade) {
                console.log('Applying upgrade:', upgrade);
                this.game.saveGame();

                try {
                    if (upgrade.type === 'player') {
                        // プレイヤーアップグレードの適用
                        upgrade.effect(this.game.player);

                        console.log('Player stats after upgrade:', {
                            health: this.game.player.health,
                            maxHealth: this.game.player.maxHealth,
                            defense: this.game.player.defense,
                            globalDamageMultiplier: this.game.player.globalDamageMultiplier,
                            criticalChance: this.game.player.criticalChance,
                            criticalMultiplier: this.game.player.criticalMultiplier
                        });

                        this.currentSelectionType = 'weapon';
                        this.displayUpgradeOptions();
                    } else if (upgrade.type === 'weapon') {
                        // アクティブな武器を特定してアップグレード
                        const activeWeapons = Object.entries(this.game.weapons)
                            .filter(([_, weapon]) => weapon.active);

                        if (activeWeapons.length > 0) {
                            activeWeapons.forEach(([type, weapon]) => {
                                console.log('Applying upgrade to weapon:', type);
                                console.log('Weapon before upgrade:', { ...weapon });
                                upgrade.effect(weapon);
                                console.log('Weapon after upgrade:', { ...weapon });
                            });
                        }

                        // 武器選択画面を閉じる
                        document.getElementById('weapon-select').style.display = 'none';
                        this.game.gameStarted = true;
                        this.game.gameState = 'playing';
                    }

                    this.game.saveGame();
                } catch (error) {
                    console.error('Error applying upgrade:', error);
                } finally {
                    // 必ず入力を再有効化
                    this.game.inputEnabled = true;
                    console.log('Input re-enabled after upgrade');
                }
            }
        }

        class Enemy {
            constructor(x, y, baseStats, tier = 0) {
                this.x = x;
                this.y = y;
                this.tier = tier;
                this.moveDelay = 0;

                // baseStats が null または undefined の場合のデフォルト値を設定
                const defaultStats = {
                    health: 30,
                    damage: {
                        base: 10,
                        variationPercent: 0.25
                    },
                    moveSpeed: 3,
                    symbol: 'e',
                    behavior: 'normal',
                    color: '#ff6666',
                    expValue: 1
                };

                // 実際の baseStats とデフォルト値をマージ
                const stats = { ...defaultStats, ...(baseStats || {}) };

                // 基本ステータスの設定とティア補正の適用
                this.health = Math.round(stats.health * (1 + tier * 0.5));
                this.maxHealth = this.health;
                this.damage = {
                    base: Math.round(stats.damage.base * (1 + tier * 0.4)),
                    variationPercent: stats.damage.variationPercent
                };
                this.moveSpeed = stats.moveSpeed;
                this.symbol = stats.symbol;
                this.behavior = stats.behavior;
                this.color = stats.color;
                this.expValue = Math.round(stats.expValue * (1 + tier * 0.3));

                // 特殊能力の設定
                this.abilities = stats.abilities || [];
                this.abilityTimers = {};
                this.abilities.forEach(ability => {
                    this.abilityTimers[ability.name] = 0;
                });
            }

            // 色とティアに基づいた表示用HTMLを生成
            getDisplayHTML() {
                const tierColors = [
                    this.color,                      // Tier 0: 基本色
                    '#ff9999',                       // Tier 1: 赤みがかった色
                    '#ff4444',                       // Tier 2: より濃い赤
                    '#ff0000',                       // Tier 3: 純赤
                    '#ff0066',                       // Tier 4: 赤紫
                    '#ff00cc',                       // Tier 5: 濃いピンク
                    '#ff00ff',                       // Tier 6: マゼンタ
                    '#cc00ff',                       // Tier 7: 紫
                    '#6600ff',                       // Tier 8: 濃い紫
                    '#0000ff'                        // Tier 9: 青
                ];

                const glowIntensity = Math.min(this.tier * 2, 20);
                const color = tierColors[Math.min(this.tier, tierColors.length - 1)];

                return `<span class="enemy" style="color: ${color}; text-shadow: 0 0 ${glowIntensity}px ${color}">${this.symbol}</span>`;
            }

            updateBasicWeapon(type, weapon, game) {
                if (weapon.cooldown > 0) {
                    weapon.cooldown--;
                    return;
                }

                // 通常の敵は基本的な攻撃のみ
                const damage = this.calculateDamage();
                game.activeProjectiles.push({
                    type: 'enemy_basic',
                    owner: 'enemy',
                    x: this.x,
                    y: this.y,
                    targetX: game.player.x,
                    targetY: game.player.y,
                    speed: 0.5,
                    damage: { base: damage },
                    color: '#ff6666'
                });

                weapon.cooldown = weapon.maxCooldown;
            }

            update(game) {
                // ターゲットの選択
                let target = game.player;
                let minDistance = Math.sqrt(
                    Math.pow(game.player.x - this.x, 2) +
                    Math.pow(game.player.y - this.y, 2)
                );

                // ユニークエネミーとの距離を確認
                game.enemies.forEach(enemy => {
                    if (enemy.isUnique) {
                        const distance = Math.sqrt(
                            Math.pow(enemy.x - this.x, 2) +
                            Math.pow(enemy.y - this.y, 2)
                        );
                        // より近いユニークエネミーを発見した場合、ターゲットを切り替え
                        if (distance < minDistance) {
                            minDistance = distance;
                            target = enemy;
                        }
                    }
                });

                // 基本的な行動更新（ターゲットに向かって移動）
                if (this.moveDelay <= 0) {
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 0) {
                        this.x += (dx / distance) * (this.moveSpeed * 0.1);
                        this.y += (dy / distance) * (this.moveSpeed * 0.1);
                    }

                    this.moveDelay = Math.floor(10 / this.moveSpeed);
                } else {
                    this.moveDelay--;
                }

                // 武器の更新（ターゲットに向けて攻撃）
                if (this.weapons) {
                    Object.entries(this.weapons).forEach(([type, weapon]) => {
                        if (weapon.active) {
                            if (weapon.cooldown > 0) {
                                weapon.cooldown--;
                                return;
                            }

                            const damage = this.calculateDamage();
                            game.activeProjectiles.push({
                                type: 'enemy_basic',
                                owner: 'enemy',
                                x: this.x,
                                y: this.y,
                                targetX: target.x,
                                targetY: target.y,
                                speed: 0.5,
                                damage: { base: damage },
                                color: '#ff6666'
                            });

                            weapon.cooldown = weapon.maxCooldown;
                        }
                    });
                }
            }
        }

        class UniqueEnemy extends Enemy {

            constructor(x, y, baseStats, game) {
                // 最初に親クラスのコンストラクタを1回だけ呼び出す
                super(x, y, baseStats);

                this.game = game;
                this.isUnique = true;
                // 一意のIDを生成
                this.id = crypto.randomUUID();

                // 名前と外観の生成
                this.name = this.generateName();
                this.symbol = this.generateSymbol();
                this.uniqueColor = this.generateUniqueColor();

                // PlayerStatsベースのステータスシステム
                this.stats = new PlayerStats();
                this.applyTimeAndDangerLevelBonus();

                // 基本ステータスの設定
                this.health = this.stats.maxHealth;
                this.maxHealth = this.stats.maxHealth;
                this.moveSpeed = this.stats.moveSpeed;
                this.moveDelay = this.stats.moveDelay;

                // 武器の初期化
                this.initializeWeapon();
            }

            // セーブデータからの再構築メソッド
            static fromSaveData(savedData, game) {
                const enemy = new UniqueEnemy(savedData.x, savedData.y, null, game);

                // 保存されたデータで上書き
                if (savedData.health) enemy.health = savedData.health;
                if (savedData.maxHealth) enemy.maxHealth = savedData.maxHealth;
                if (savedData.name) enemy.name = savedData.name;
                if (savedData.symbol) enemy.symbol = savedData.symbol;
                if (savedData.uniqueColor) enemy.uniqueColor = savedData.uniqueColor;

                // Stats の復元
                if (savedData.stats) {
                    Object.assign(enemy.stats, savedData.stats);
                    enemy.stats.updateDerivedStats();
                }

                // 武器の復元
                if (savedData.weapons) {
                    enemy.weapons = savedData.weapons;
                } else {
                    enemy.initializeWeapon();  // 武器データがない場合は新規作成
                }

                return enemy;
            }

            initializeWeapon() {
                // 利用可能な武器タイプからランダムに選択
                const weaponTypes = ['orbit', 'laser', 'missile', 'motorgun'];
                const selectedType = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];

                console.log('Selected weapon type:', selectedType); // デバッグログ

                this.weapons = {};

                // 深いコピーを使用して武器の基本データを複製
                this.weapons[selectedType] = JSON.parse(JSON.stringify({
                    ...this.game.availableWeapons[selectedType],
                    active: true
                }));

                // 選択された武器の基本プロパティを設定
                const weapon = this.weapons[selectedType];
                weapon.active = true;
                weapon.color = this.uniqueColor.primary;
                weapon.effectColor = this.uniqueColor.secondary;

                // 武器タイプ別の特別な初期化
                switch (selectedType) {
                    case 'orbit':
                        weapon.angle = 0;
                        weapon.radius = 3;
                        weapon.projectiles = 2;
                        weapon.damageRadius = 2;
                        weapon.splashCooldown = 0;
                        weapon.maxSplashCooldown = 30;
                        weapon.splashDuration = 3;
                        weapon.splashActive = false;
                        weapon.damage = {
                            base: Math.round(this.stats.ATK * 3),
                            variationPercent: 0.35
                        };
                        weapon.splashDamage = {
                            base: Math.round(this.stats.ATK * 1.5),
                            variationPercent: 0.30
                        };
                        break;

                    case 'laser':
                        weapon.cooldown = 0;
                        weapon.maxCooldown = 15;
                        weapon.range = 8;
                        weapon.duration = 20;
                        weapon.spreadLevel = 1;
                        weapon.maxSpreadLevel = 6;
                        weapon.spreadWidth = 0.05;
                        weapon.width = 1;
                        weapon.damage = {
                            base: Math.round(this.stats.ATK * 2),
                            variationPercent: 0.40
                        };
                        break;

                    case 'missile':
                        weapon.cooldown = 0;
                        weapon.maxCooldown = 20;
                        weapon.projectiles = 1;
                        weapon.maxProjectiles = 6;
                        weapon.splashRadius = 2;
                        weapon.speed = 0.3;
                        weapon.splashDuration = 3;
                        weapon.damage = {
                            base: Math.round(this.stats.ATK * 4),
                            variationPercent: 0.35
                        };
                        weapon.splashDamage = {
                            base: Math.round(this.stats.ATK * 2),
                            variationPercent: 0.30
                        };
                        break;

                    case 'motorgun':
                        weapon.cooldown = 0;
                        weapon.stabilizationTime = 0;
                        weapon.fireRate = 2;
                        weapon.maxFireRate = 4;
                        weapon.spread = 0.2;
                        weapon.minSpread = 0.15;
                        weapon.maxSpread = 0.5;
                        weapon.projectileSpeed = 0.8;
                        weapon.maxCooldown = 3;
                        weapon.range = 12;
                        weapon.maxStabilization = 30;
                        weapon.ammo = 30;
                        weapon.maxAmmo = 30;
                        weapon.reloadTime = 30;
                        weapon.reloadCooldown = 0;
                        weapon.waitBonus = 1.5;
                        weapon.damage = {
                            base: Math.round(this.stats.ATK * 2.5),
                            variationPercent: 0.25
                        };
                        break;
                }

                // デバッグログで初期化された武器の状態を確認
                console.log(`Initialized ${selectedType} weapon for unique enemy:`, this.weapons[selectedType]);
            }

            // 武器のアップデート処理のディスパッチャー
            updateWeapon() {
                // アクティブな武器を取得
                const activeWeapon = Object.entries(this.weapons).find(([_, w]) => w.active);
                if (!activeWeapon) return;

                // プレイヤーとの距離を計算
                const playerDx = this.game.player.x - this.x;
                const playerDy = this.game.player.y - this.y;
                const playerDist = Math.sqrt(playerDx * playerDx + playerDy * playerDy);

                let bestTarget = this.game.player;  // デフォルトはプレイヤー
                let shortestDist = playerDist;

                // 通常の敵（非ユニーク）のみを対象とする
                this.game.enemies.forEach(enemy => {
                    // 自分自身とユニークエネミーは対象外
                    if (!enemy.isUnique && enemy !== this) {
                        const dx = enemy.x - this.x;
                        const dy = enemy.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < shortestDist) {
                            shortestDist = dist;
                            bestTarget = enemy;
                        }
                    }
                });

                // 武器の種類に応じた更新処理
                const [type, weapon] = activeWeapon;
                if (bestTarget) {  // ターゲットが見つかった場合のみ攻撃
                    switch (type) {
                        case 'orbit':
                            this.updateOrbitWeapon(weapon);
                            break;
                        case 'laser':
                            this.updateLaserWeapon(weapon, bestTarget);
                            break;
                        case 'missile':
                            this.updateMissileWeapon(weapon, bestTarget);
                            break;
                        case 'motorgun':
                            this.updateMotorgunWeapon(weapon, bestTarget);
                            break;
                    }
                }
            }

            updateOrbitWeapon(weapon) {
                // 回転角度の更新
                weapon.angle += 0.4;

                // クールダウンの更新
                if (weapon.splashCooldown > 0) {
                    weapon.splashCooldown--;
                }

                // プロジェクタイルの生成
                for (let i = 0; i < weapon.projectiles; i++) {
                    let angle = weapon.angle + (i * (2 * Math.PI / weapon.projectiles));
                    let x = this.x + Math.cos(angle) * weapon.radius;
                    let y = this.y + Math.sin(angle) * weapon.radius;

                    // メインのプロジェクタイル
                    this.game.projectiles.push({
                        owner: 'unique_enemy',
                        sourceId: this.id,  // IDを追加
                        type: 'orbit',
                        x: Math.round(x),
                        y: Math.round(y),
                        damage: weapon.damage,
                        splashDamage: weapon.splashDamage,
                        symbol: '◢',
                        color: this.uniqueColor.primary,
                        effectColor: this.uniqueColor.secondary
                    });

                    // 軌道エフェクト
                    if (weapon.projectiles > 1) {
                        let nextI = (i + 1) % weapon.projectiles;
                        let nextAngle = weapon.angle + (nextI * (2 * Math.PI / weapon.projectiles));
                        let midX = this.x + Math.cos((angle + nextAngle) / 2) * weapon.radius;
                        let midY = this.y + Math.sin((angle + nextAngle) / 2) * weapon.radius;

                        this.game.projectiles.push({
                            owner: 'unique_enemy',
                            sourceId: this.id,  // IDを追加
                            type: 'orbit-trail',
                            x: Math.round(midX),
                            y: Math.round(midY),
                            damage: weapon.splashDamage,
                            symbol: '━',
                            color: this.uniqueColor.secondary,
                            effectColor: this.uniqueColor.accent,
                            opacity: 0.7
                        });
                    }
                }
            }

            updateLaserWeapon(weapon, target) {
                if (weapon.cooldown > 0) {
                    weapon.cooldown--;
                    return;
                }

                if (!target || target === this) return;
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const angle = Math.atan2(dy, dx);

                const spreadAngles = [angle];
                const spreadLevel = weapon.spreadLevel;
                const angleStep = weapon.spreadWidth;

                for (let i = 1; i <= spreadLevel; i++) {
                    spreadAngles.push(angle + (angleStep * i));
                    spreadAngles.push(angle - (angleStep * i));
                }

                spreadAngles.forEach(beamAngle => {
                    let currentX = this.x;
                    let currentY = this.y;
                    const stepX = Math.cos(beamAngle);
                    const stepY = Math.sin(beamAngle);

                    for (let i = 1; i <= weapon.range; i++) {
                        currentX += stepX;
                        currentY += stepY;

                        const x = Math.floor(currentX);
                        const y = Math.floor(currentY);

                        if (x < 0 || x >= this.game.width || y < 0 || y >= this.game.height) break;

                        this.game.activeProjectiles.push({
                            owner: 'unique_enemy',
                            sourceId: this.id,  // ここでIDを追加
                            type: 'laser',
                            x: x,
                            y: y,
                            damage: weapon.damage,
                            angle: beamAngle,
                            duration: weapon.duration,
                            maxDuration: weapon.duration,
                            hasDealtDamage: false,
                            opacity: 1,
                            color: this.uniqueColor.primary,
                            effectColor: this.uniqueColor.secondary
                        });
                    }
                });

                weapon.cooldown = weapon.maxCooldown;
            }

            updateMissileWeapon(weapon, target) {
                if (weapon.cooldown > 0) {
                    weapon.cooldown--;
                    return;
                }

                if (!target || target === this) return;

                const activeMissiles = this.game.activeProjectiles.filter(
                    p => p.type === 'missile' && p.owner === 'unique_enemy'
                ).length;

                const availableSlots = weapon.projectiles - activeMissiles;
                if (availableSlots <= 0) return;

                this.game.activeProjectiles.push({
                    owner: 'unique_enemy',
                    sourceId: this.id,  // ここでIDを追加
                    type: 'missile',
                    x: this.x,
                    y: this.y,
                    targetX: target.x,
                    targetY: target.y,
                    damage: weapon.damage,
                    splashRadius: weapon.splashRadius,
                    splashDamage: weapon.splashDamage,
                    speed: weapon.speed,
                    trail: [],
                    color: this.uniqueColor.primary,
                    effectColor: this.uniqueColor.secondary
                });

                weapon.cooldown = weapon.maxCooldown;
            }

            updateMotorgunWeapon(weapon, target) {
                if (weapon.reloadCooldown > 0) {
                    weapon.reloadCooldown--;
                    if (weapon.reloadCooldown === 0) {
                        weapon.ammo = weapon.maxAmmo;
                    }
                    return;
                }

                if (weapon.ammo <= 0) {
                    weapon.reloadCooldown = weapon.reloadTime;
                    return;
                }

                if (weapon.cooldown > 0) {
                    weapon.cooldown--;
                    return;
                }

                if (!target || target === this) return;

                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const baseAngle = Math.atan2(dy, dx);

                const stabilizationRatio = weapon.stabilizationTime / weapon.maxStabilization;
                const currentSpread = weapon.maxSpread - (weapon.maxSpread - weapon.minSpread) * stabilizationRatio;
                const spreadAngle = (Math.random() - 0.5) * currentSpread;
                const finalAngle = baseAngle + spreadAngle;

                this.game.activeProjectiles.push({
                    owner: 'unique_enemy',
                    sourceId: this.id,  // ここでIDを追加
                    type: 'motorgun',
                    x: this.x,
                    y: this.y,
                    angle: finalAngle,
                    speed: weapon.projectileSpeed,
                    damage: weapon.damage,
                    range: weapon.range,
                    traveled: 0,
                    hasHit: false,
                    trail: [],
                    color: this.uniqueColor.primary,
                    effectColor: this.uniqueColor.secondary
                });

                weapon.ammo--;
                weapon.cooldown = weapon.maxCooldown;
            }

            reconstruct(savedData) {
                // 基本プロパティの復元
                this.health = savedData.health;
                this.maxHealth = savedData.maxHealth;
                this.name = savedData.name;
                this.uniqueColor = savedData.uniqueColor;

                // Stats の復元
                if (savedData.stats) {
                    Object.assign(this.stats, savedData.stats);
                    this.stats.updateDerivedStats();
                }

                return this;
            }

            generateName() {
                if (!this.game) {
                    console.error('Game reference is missing in UniqueEnemy');
                    return 'Unknown Enemy';
                }

                const prefixes = ['Corrupted', 'Ancient', 'Legendary', 'Mythical', 'Eternal',
                    'Celestial', 'Abyssal', 'Divine', 'Infernal', 'Astral'];
                const titles = ['Guardian', 'Harbinger', 'Destroyer', 'Watcher', 'Executioner',
                    'Sovereign', 'Nemesis', 'Archon', 'Overseer', 'Vanquisher'];

                const dangerLevel = this.game.dangerLevel || 1;
                const gameTime = this.game.gameTime || 0;

                let prefixIndex = Math.min(
                    Math.floor((dangerLevel - 1 + gameTime / 3000) * prefixes.length / 5),
                    prefixes.length - 1
                );
                let titleIndex = Math.min(
                    Math.floor((dangerLevel - 1 + gameTime / 3000) * titles.length / 5),
                    titles.length - 1
                );

                return `${prefixes[prefixIndex]} ${titles[titleIndex]}`;
            }


            generateSymbol() {
                const symbols = ['❖', '✺', '❈', '✲', '❋', '✴', '✵', '✷', '❂', '◈'];
                const dangerLevel = this.game.dangerLevel;
                const index = Math.min(
                    Math.floor((dangerLevel - 1 + Math.random()) * symbols.length / 5),
                    symbols.length - 1
                );
                return symbols[index];
            }

            generateUniqueColor() {
                const colorSets = [
                    {
                        primary: '#ff1493',    // ディープピンク
                        secondary: '#9400d3',  // ダークバイオレット
                        accent: '#ff00ff'      // マゼンタ
                    },
                    {
                        primary: '#4169e1',    // ロイヤルブルー
                        secondary: '#0000cd',  // ミディアムブルー
                        accent: '#1e90ff'      // ドジャーブルー
                    },
                    {
                        primary: '#ffd700',    // ゴールド
                        secondary: '#daa520',  // ゴールデンロッド
                        accent: '#ffa500'      // オレンジ
                    },
                    {
                        primary: '#32cd32',    // ライムグリーン
                        secondary: '#228b22',  // フォレストグリーン
                        accent: '#00ff00'      // ライム
                    },
                    {
                        primary: '#ff4500',    // オレンジレッド
                        secondary: '#ff8c00',  // ダークオレンジ
                        accent: '#ff6347'      // トマト
                    }
                ];

                const dangerLevel = this.game.dangerLevel;
                const gameTime = this.game.gameTime;
                const colorIndex = Math.min(
                    Math.floor((dangerLevel - 1 + gameTime / 3000) * colorSets.length / 5),
                    colorSets.length - 1
                );

                return colorSets[colorIndex];
            }

            applyTimeAndDangerLevelBonus() {
                const gameTime = this.game.gameTime;
                const dangerLevel = this.game.dangerLevel;

                const timeBonus = Math.min(gameTime / 6000, 1.0);
                const dangerBonus = (dangerLevel - 1) * 0.2;
                const totalBonus = 1.0 + timeBonus + dangerBonus;

                this.stats.ATK = Math.round(10 * totalBonus);
                this.stats.DEF = Math.round(8 * totalBonus);
                this.stats.SPD = Math.round(6 * totalBonus);
                this.stats.updateDerivedStats();
            }

            evaluateThreat(entity) {
                if (!entity) return 0;

                const distance = Math.sqrt(
                    Math.pow(entity.x - this.x, 2) +
                    Math.pow(entity.y - this.y, 2)
                );

                // 範囲外は脅威なし
                if (distance > 12) return 0;

                let threat = 0;

                // プレイヤーの場合
                if (entity === this.game.player) {
                    threat = entity.stats.ATK * 2 + entity.stats.SPD;
                }
                // ユニークエネミーの場合
                else if (entity.isUnique) {
                    threat = entity.stats.ATK * 2.5 + entity.stats.SPD;
                }
                // 通常の敵の場合
                else {
                    threat = entity.damage.base + entity.moveSpeed;
                    // グループで行動している敵はより脅威
                    const nearbyEnemies = this.game.enemies.filter(e =>
                        !e.isUnique &&
                        Math.sqrt(Math.pow(e.x - entity.x, 2) + Math.pow(e.y - entity.y, 2)) < 3
                    ).length;
                    threat *= (1 + nearbyEnemies * 0.2);
                }

                // 距離による減衰
                threat *= 1 - (distance / 12);

                // HP状態による調整
                const healthRatio = entity.health / entity.maxHealth;
                threat *= healthRatio;

                return threat;
            }

            // 基本的な更新処理
            update(game) {
                this.updateMovement();
                this.updateWeapon();
            }

            updateMovement() {
                // 最も近い敵（プレイヤーまたは他のユニークエネミー）を見つける
                let nearestTarget = this.game.player;
                let targetDistance = Math.sqrt(
                    Math.pow(this.game.player.x - this.x, 2) +
                    Math.pow(this.game.player.y - this.y, 2)
                );

                this.game.enemies.forEach(enemy => {
                    if (enemy !== this && enemy.isUnique) {
                        const distance = Math.sqrt(
                            Math.pow(enemy.x - this.x, 2) +
                            Math.pow(enemy.y - this.y, 2)
                        );
                        if (distance < targetDistance) {
                            nearestTarget = enemy;
                            targetDistance = distance;
                        }
                    }
                });

                const weaponRange = this.getWeaponRange();
                const idealRange = weaponRange * 0.7;
                const minSafeDistance = 3;  // minDistance を minSafeDistance に変更

                const dx = nearestTarget.x - this.x;
                const dy = nearestTarget.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                let moveSpeed = this.stats.moveSpeed * 0.1;

                if (distance < minSafeDistance) {
                    // 近すぎる場合は急いで離れる
                    this.x -= (dx / distance) * moveSpeed * 1.5;
                    this.y -= (dy / distance) * moveSpeed * 1.5;
                }
                else if (Math.abs(distance - idealRange) > 2) {
                    if (distance > idealRange) {
                        // 遠すぎる場合は接近
                        this.x += (dx / distance) * moveSpeed;
                        this.y += (dy / distance) * moveSpeed;
                    } else {
                        // 近すぎる場合は離れる
                        this.x -= (dx / distance) * moveSpeed;
                        this.y -= (dy / distance) * moveSpeed;
                    }
                } else {
                    // 理想距離では横移動
                    const perpX = -dy / distance;
                    const perpY = dx / distance;
                    this.x += perpX * moveSpeed * 0.5;
                    this.y += perpY * moveSpeed * 0.5;
                }

                this.avoidCollisions();

                // 画面端の処理
                this.x = Math.max(0, Math.min(this.game.width - 1, this.x));
                this.y = Math.max(0, Math.min(this.game.height - 1, this.y));
            }

            // 武器の射程範囲を取得
            getWeaponRange() {
                const activeWeapon = Object.entries(this.weapons).find(([_, w]) => w.active);
                if (!activeWeapon) return 6; // デフォルト値

                const [type, weapon] = activeWeapon;
                switch (type) {
                    case 'orbit':
                        return weapon.radius + 3;
                    case 'laser':
                        return weapon.range;
                    case 'missile':
                        return 8;
                    case 'motorgun':
                        return weapon.range;
                    default:
                        return 6;
                }
            }

            avoidCollisions() {
                const avoidanceRange = 4;
                const entities = [...this.game.enemies, this.game.player];

                for (const entity of entities) {
                    if (entity === this) continue;

                    const dx = entity.x - this.x;
                    const dy = entity.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < avoidanceRange) {
                        // 近すぎる実体から離れる
                        const pushForce = (avoidanceRange - distance) * 0.05;
                        this.x -= (dx / distance) * pushForce;
                        this.y -= (dy / distance) * pushForce;
                    }
                }
            }

            // ダメージ計算やダメージを受けた際の処理
            takeDamage(amount, source) {
                // 回避判定
                if (Math.random() < this.stats.dodgeChance) {
                    // 基本のドッジエフェクト
                    this.game.effects.push({
                        type: 'dodge',
                        x: this.x,
                        y: this.y,
                        currentFrame: 0,
                        duration: 5,
                        frames: [
                            ['∵'],
                            ['∴'],
                            ['∷'],
                            ['∵'],
                            ['∴']
                        ],
                        color: this.uniqueColor.primary,
                        opacity: 0.8
                    });

                    // 波動エフェクト
                    const numWaves = 8;
                    for (let i = 0; i < numWaves; i++) {
                        const angle = (Math.PI * 2 * i) / numWaves;
                        const radius = 2;
                        this.game.effects.push({
                            type: 'dodge_wave',
                            x: this.x + Math.cos(angle) * radius,
                            y: this.y + Math.sin(angle) * radius,
                            currentFrame: 0,
                            duration: 10,
                            frames: [['◇'], ['◆'], ['◈'], ['◆']],
                            color: this.uniqueColor.secondary,
                            opacity: 0.6,
                            angle: angle
                        });
                    }

                    this.game.addDamagePopup(
                        this.x,
                        this.y - 1,
                        'DODGE!',
                        {
                            color: this.uniqueColor.primary,
                            scale: 1.2,
                            text: 'DODGE!',
                            style: `
                    color: ${this.uniqueColor.primary};
                    text-shadow: 0 0 10px ${this.uniqueColor.secondary},
                                0 0 20px ${this.uniqueColor.accent},
                                2px 2px 2px rgba(0,0,0,0.5);
                    font-weight: bold;
                `
                        }
                    );

                    return 0;
                }

                // 防御計算
                const damageReduction = this.stats.defenseMultiplier;
                const actualDamage = Math.round(amount / damageReduction);

                this.health = Math.max(0, this.health - actualDamage);

                // ダメージ表示
                if (actualDamage > 0) {
                    this.game.addDamagePopup(
                        this.x,
                        this.y,
                        actualDamage,
                        {
                            color: '#ff4444',
                            scale: 1.2,
                            text: `-${actualDamage}`,
                            style: `
                    color: #ff4444;
                    text-shadow: 0 0 10px #ff0000,
                                0 0 20px #ff0000;
                    font-weight: bold;
                `
                        }
                    );
                }

                return actualDamage;
            }

            onDeath() {
                // 派手な死亡エフェクト
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i) / 8;
                    const distance = 1.5;
                    this.game.effects.push({
                        type: 'death',
                        x: this.x + Math.cos(angle) * distance,
                        y: this.y + Math.sin(angle) * distance,
                        duration: 10,
                        color: this.uniqueColor.primary,
                        symbol: ['✧', '✦', '✴'][Math.floor(Math.random() * 3)],
                        opacity: 1
                    });
                }

                // 経験値ジェムのドロップ
                const gemCount = Math.floor(2 + Math.random() * 3);
                for (let i = 0; i < gemCount; i++) {
                    const angle = (Math.PI * 2 * i) / gemCount;
                    const distance = 0.5;
                    this.game.gems.push({
                        x: this.x + Math.cos(angle) * distance,
                        y: this.y + Math.sin(angle) * distance,
                        type: 'unique',
                        value: Math.floor(5 * (1 + this.game.dangerLevel * 0.2)),
                        color: this.uniqueColor.primary,
                        symbol: '✦',
                        spawnTime: this.game.gameTime
                    });
                }
            }

            getDisplayInfo() {
                const healthPercentage = Math.round((this.health / this.maxHealth) * 100);
                const info = [];  // 配列を明示的に初期化

                // 基本情報
                info.push(`Name: ${this.name}`);
                info.push(`Health: ${this.health}/${this.maxHealth} (${healthPercentage}%)`);
                info.push(``);

                // ステータス情報
                info.push(`Stats:`);
                info.push(`ATK: ${this.stats.ATK} (DMG: ${Math.round(this.stats.damageMultiplier * 100)}%)`);
                info.push(`DEF: ${this.stats.DEF} (Resist: ${Math.round((1 - 1 / this.stats.defenseMultiplier) * 100)}%)`);
                info.push(`SPD: ${this.stats.SPD} (Dodge: ${Math.round(this.stats.dodgeChance * 100)}%, Crit: ${Math.round(this.stats.criticalChance * 100)}%)`);
                info.push(``);

                // 武器情報
                info.push(`Weapon:`);
                const activeWeapon = Object.entries(this.weapons).find(([_, w]) => w.active);
                if (activeWeapon) {
                    const [type, weapon] = activeWeapon;
                    const weaponName = this.game.availableWeapons[type].name;
                    info.push(`Type: ${weaponName}`);
                    info.push(`Base Damage: ${weapon.damage.base}`);

                    // 武器タイプ別の追加情報
                    switch (type) {
                        case 'orbit':
                            info.push(`Blades: ${weapon.projectiles}`);
                            info.push(`Radius: ${weapon.radius}`);
                            break;
                        case 'laser':
                            info.push(`Range: ${weapon.range}`);
                            info.push(`Spread Level: ${weapon.spreadLevel}/${weapon.maxSpreadLevel}`);
                            break;
                        case 'missile':
                            info.push(`Projectiles: ${weapon.projectiles}`);
                            info.push(`Splash Radius: ${weapon.splashRadius}`);
                            break;
                        case 'motorgun':
                            info.push(`Ammo: ${weapon.ammo}/${weapon.maxAmmo}`);
                            info.push(`Fire Rate: ${weapon.fireRate}`);
                            break;
                    }
                } else {
                    info.push(`No weapon equipped`);
                }

                // デバッグログ
                console.log('Display info generated:', info);

                return info;
            }
        }

        // ユニークエネミー生成システム
        class UniqueEnemySpawnSystem {
            constructor(game) {
                this.game = game; // game参照を保存
                this.spawnCooldown = 0;
                this.portalTimer = 0;
                this.maxPortalTime = 100;
                this.isPortalActive = false;
                this.portalPosition = null;
                this.uniqueColor = this.generateUniqueColor();
            }

            generateUniqueColor() {
                return {
                    primary: '#ff1493',
                    secondary: '#9400d3',
                    accent: '#ff00ff'
                };
            }

            // UniqueEnemySpawnSystem クラス内の update メソッドを修正
            update() {
                // 既存のユニークエネミーがいる場合は新しく出現させない
                if (this.game.enemies.some(enemy => enemy.isUnique)) {
                    return;
                }

                // ポータルがアクティブな場合の更新
                if (this.isPortalActive) {
                    this.portalTimer--;

                    // パーティクルエフェクトの生成（2フレームに1回）
                    if (this.portalTimer % 2 === 0) {
                        this.createPortalParticles();
                    }

                    // ポータル完成時にユニークエネミー出現
                    if (this.portalTimer <= 0) {
                        this.spawnUniqueEnemy();
                        this.closePortal();
                    }
                    return;
                }

                // スポーンクールダウンの更新
                if (this.spawnCooldown > 0) {
                    this.spawnCooldown--;
                    return;
                }

                // 危険度変更時の出現判定
                if (this.game.gameTime >= this.game.nextDangerLevelChange - 10) {
                    const spawnChance = this.game.dangerLevel * 0.1;
                    if (Math.random() < spawnChance) {
                        this.activatePortal();
                        this.spawnCooldown = 300;
                    }
                }
            }

            activatePortal() {
                const x = Math.floor(Math.random() * this.game.width);
                const y = Math.floor(Math.random() * this.game.height);

                this.isPortalActive = true;
                this.portalTimer = this.maxPortalTime;
                this.portalPosition = { x, y };

                // 開始時のポータルエフェクト
                this.game.addPortalEffect(x, y, 'open', {
                    symbols: this.getPortalSymbols(),
                    colors: [this.uniqueColor.primary, this.uniqueColor.secondary, this.uniqueColor.accent]
                });
            }

            createPortalParticles() {
                const particleCount = 8;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i / particleCount) + (this.portalTimer * 0.1);
                    const radius = 2;
                    const effectX = this.portalPosition.x + Math.cos(angle) * radius;
                    const effectY = this.portalPosition.y + Math.sin(angle) * radius;

                    this.game.effects.push({
                        type: 'portal_particle',
                        x: effectX,
                        y: effectY,
                        duration: 5,
                        symbol: ['∴', '∵', '∷'][Math.floor(Math.random() * 3)],
                        color: [
                            this.uniqueColor.primary,
                            this.uniqueColor.secondary,
                            this.uniqueColor.accent
                        ][Math.floor(Math.random() * 3)],
                        opacity: 0.8,
                        angle: angle
                    });
                }
            }

            getPortalSymbols() {
                return {
                    open: [
                        ['◎', '○', '◌'],
                        ['○', '◎', '○'],
                        ['◌', '○', '◎']
                    ],
                    close: [
                        ['◎', '○', '◌'],
                        ['○', '◌', '○'],
                        ['◌', '○', '◎']
                    ]
                };
            }

            closePortal() {
                if (this.portalPosition) {
                    this.game.addPortalEffect(
                        this.portalPosition.x,
                        this.portalPosition.y,
                        'close',
                        {
                            symbols: this.getPortalSymbols(),
                            colors: [
                                this.uniqueColor.primary,
                                this.uniqueColor.secondary,
                                this.uniqueColor.accent
                            ]
                        }
                    );
                }

                this.isPortalActive = false;
                this.portalPosition = null;
            }

            spawnUniqueEnemy() {
                if (!this.game) {
                    console.error('Game reference is missing in UniqueEnemySpawnSystem');
                    return;
                }

                if (!this.portalPosition) {
                    console.error('Portal position is not set');
                    return;
                }

                // enemyTypeを確実に取得
                const baseEnemyType = this.game.enemyTypes.guardian || this.game.enemyTypes.grunt;

                const uniqueEnemy = new UniqueEnemy(
                    this.portalPosition.x,
                    this.portalPosition.y,
                    baseEnemyType,
                    this.game  // game参照を確実に渡す
                );

                if (uniqueEnemy) {
                    this.game.enemies.push(uniqueEnemy);
                    // デバッグログ
                    console.log('Unique enemy spawned:', {
                        position: { x: uniqueEnemy.x, y: uniqueEnemy.y },
                        name: uniqueEnemy.name,
                        health: uniqueEnemy.health,
                        game: !!uniqueEnemy.game // game参照の存在確認
                    });
                }

                this.closePortal();
            }

        }

        class DamagePopupManager {
            constructor() {
                this.activePopups = new Map(); // 座標ごとのポップアップを管理
            }

            // ポップアップの位置を計算
            calculatePopupPosition(x, y) {
                const key = `${x},${y}`;
                const existingPopups = this.activePopups.get(key) || [];

                // 新しいポップアップの位置をオフセット
                let offsetX = 0;
                let offsetY = -1; // 基本的に上方向に表示

                // 同じ座標に既存のポップアップがある場合
                if (existingPopups.length > 0) {
                    // ジグザグパターンでオフセットを計算
                    const index = existingPopups.length;
                    offsetX = (index % 2 === 0) ? index / 2 : -(Math.floor(index / 2) + 1);
                    offsetY = -1 - Math.floor(index / 2);
                }

                // アクティブなポップアップリストを更新
                existingPopups.push({ offsetX, offsetY });
                this.activePopups.set(key, existingPopups);

                return { offsetX, offsetY };
            }

            // ポップアップの削除時の処理
            removePopup(x, y) {
                const key = `${x},${y}`;
                const existingPopups = this.activePopups.get(key);
                if (existingPopups && existingPopups.length > 0) {
                    existingPopups.shift(); // 最も古いポップアップを削除
                    if (existingPopups.length === 0) {
                        this.activePopups.delete(key);
                    } else {
                        this.activePopups.set(key, existingPopups);
                    }
                }
            }

            // 定期的なクリーンアップ
            cleanup() {
                this.activePopups.clear();
            }
        }

        // ゲームの初期化と開始
        const game = new Game();
        game.render();
    </script>
</body>

</html>